
Ruta: app\(auth)\forgot-password\page.tsx
"use client";

import { useState } from "react";
import { AuthLayout } from "@/components/auth/auth-layout";
import { AuthForm } from "@/components/auth/auth-form";
import { FormField, FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import Link from "next/link";
import { CheckCircleIcon } from "lucide-react";

export default function ForgotPasswordPage() {
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(event.currentTarget);
    const email = formData.get("email") as string;

    try {
      // Usar la API correcta según tu configuración
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/auth/request-reset-password`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ email }),
        }
      );

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Error al enviar el correo");
      }

      setSuccess(true);
    } catch (error: any) {
      console.error("Error al solicitar recuperación de contraseña:", error);
      setError(
        error.message || "Ocurrió un error al intentar enviar el correo"
      );
    } finally {
      setIsLoading(false);
    }
  }

  if (success) {
    return (
      <AuthLayout
        title="Revisa tu correo"
        subtitle="Te hemos enviado un enlace para restablecer tu contraseña"
      >
        <div className="bg-background rounded-xl border border-border p-8 text-center space-y-6">
          <div className="mx-auto w-12 h-12 rounded-full bg-success/10 flex items-center justify-center">
            <CheckCircleIcon className="w-6 h-6 text-success" />
          </div>
          <p className="text-sm text-content">
            Si existe una cuenta con ese correo, recibirás instrucciones para
            restablecer tu contraseña.
          </p>
          <Link
            href="/login"
            className="text-primary hover:text-primary-hover font-medium block"
          >
            Volver al inicio de sesión
          </Link>
        </div>
      </AuthLayout>
    );
  }

  return (
    <AuthLayout
      title="Recuperar contraseña"
      subtitle="Te enviaremos un correo con instrucciones para restablecer tu contraseña"
    >
      <AuthForm
        onSubmit={handleSubmit}
        error={error}
        isLoading={isLoading}
        submitText="Enviar instrucciones"
      >
        <FormField>
          <FormLabel htmlFor="email">Correo electrónico</FormLabel>
          <Input
            id="email"
            name="email"
            type="email"
            required
            placeholder="tu@email.com"
            disabled={isLoading}
          />
        </FormField>

        <div className="text-sm text-center">
          <Link
            href="/login"
            className="text-primary hover:text-primary-hover font-medium"
          >
            Volver al inicio de sesión
          </Link>
        </div>
      </AuthForm>
    </AuthLayout>
  );
}


Ruta: app\(auth)\layout.tsx
import { Metadata } from "next";

export const metadata: Metadata = {
  title: {
    template: "%s ",
    default: "Autenticación ",
  },
};

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}


Ruta: app\(auth)\login\page.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn, useSession } from "next-auth/react";
import { AuthLayout } from "@/components/auth/auth-layout";
import { AuthForm } from "@/components/auth/auth-form";
import { FormField, FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import Link from "next/link";
import { Suspense } from "react";

function LoginPageContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { status } = useSession();
  const [error, setError] = useState<string | null>(
    searchParams.get("error") === "CredentialsSignin"
      ? "Credenciales inválidas"
      : null
  );
  const [isLoading, setIsLoading] = useState(false);

  // Obtener y decodificar correctamente la URL de callback
  const encodedCallbackUrl = searchParams.get("callbackUrl") || "/dashboard";
  const callbackUrl = decodeURIComponent(encodedCallbackUrl);

  // Redireccionar si ya está autenticado
  useEffect(() => {
    if (status === "authenticated") {
      router.push(callbackUrl);
    }
  }, [status, router, callbackUrl]);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(event.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("Credenciales inválidas");
        setIsLoading(false);
        return;
      }

      // Redireccionar a la URL de callback decodificada
      router.push(callbackUrl);
      router.refresh();
    } catch (error) {
      console.error("Error durante el inicio de sesión:", error);
      setError("Ocurrió un error al intentar iniciar sesión");
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <AuthLayout
      title="Iniciar sesión"
      subtitle="¡Bienvenido de vuelta! Por favor, ingresa tus credenciales."
    >
      <AuthForm
        onSubmit={handleSubmit}
        error={error}
        isLoading={isLoading}
        submitText="Iniciar sesión"
      >
        <FormField>
          <FormLabel>Correo electrónico</FormLabel>
          <Input
            id="email"
            name="email"
            type="email"
            autoComplete="email"
            required
            placeholder="tu@email.com"
            disabled={isLoading}
          />
        </FormField>

        <FormField>
          <FormLabel>Contraseña</FormLabel>
          <Input
            id="password"
            name="password"
            type="password"
            autoComplete="current-password"
            required
            placeholder="••••••••"
            disabled={isLoading}
          />
        </FormField>

        <div className="flex items-center justify-between">
          <Link
            href="/forgot-password"
            className="text-sm font-medium text-primary hover:text-primary-hover"
          >
            ¿Olvidaste tu contraseña?
          </Link>
          {/* <Link
            href="/register"
            className="text-sm font-medium text-primary hover:text-primary-hover"
          >
            Crear cuenta
          </Link> */}
        </div>
      </AuthForm>
    </AuthLayout>
  );
}

export default function LoginPage() {
  return (
    <Suspense fallback={<div>Cargando...</div>}>
      <LoginPageContent />
    </Suspense>
  );
}


Ruta: app\(auth)\register\page.tsx
// app/(auth)/register/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { AuthLayout } from "@/components/auth/auth-layout";
import { AuthForm } from "@/components/auth/auth-form";
import { FormField, FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import Link from "next/link";
import { register } from "@/services/auth";

export default function RegisterPage() {
  const router = useRouter();
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(event.currentTarget);
    const name = formData.get("name") as string;
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirmPassword") as string;

    if (password !== confirmPassword) {
      setError("Las contraseñas no coinciden");
      setIsLoading(false);
      return;
    }

    try {
      // Llamar a la función register del servicio de auth
      const response = await register(name, email, password);

      if (response.error) {
        setError(response.error || "Error al registrar el usuario");
        setIsLoading(false);
        return;
      }

      // Si el registro es exitoso, redirigir a la página de login
      router.push("/login?registered=true");
    } catch (error) {
      console.error("Error durante el registro:", error);
      setError("Ocurrió un error al intentar registrarse. Intente nuevamente.");
    } finally {
      setIsLoading(false);
    }
  }

  return <>Registro deshabilitados</>;

  return (
    <AuthLayout
      title="Crear cuenta"
      subtitle="¡Bienvenido! Por favor, completa tus datos para comenzar."
      showDemoAlert={false}
    >
      <AuthForm
        onSubmit={handleSubmit}
        error={error}
        isLoading={isLoading}
        submitText="Crear cuenta"
        footerContent="O continúa con"
      >
        <FormField>
          <FormLabel>Nombre completo</FormLabel>
          <Input
            id="name"
            name="name"
            type="text"
            required
            placeholder="John Doe"
            disabled={isLoading}
          />
        </FormField>

        <FormField>
          <FormLabel>Correo electrónico</FormLabel>
          <Input
            id="email"
            name="email"
            type="email"
            autoComplete="email"
            required
            placeholder="tu@email.com"
            disabled={isLoading}
          />
        </FormField>

        <FormField>
          <FormLabel>Contraseña</FormLabel>
          <Input
            id="password"
            name="password"
            type="password"
            autoComplete="new-password"
            required
            placeholder="••••••••"
            disabled={isLoading}
          />
        </FormField>

        <FormField>
          <FormLabel>Confirmar contraseña</FormLabel>
          <Input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            autoComplete="new-password"
            required
            placeholder="••••••••"
            disabled={isLoading}
          />
        </FormField>

        <div className="flex items-center justify-end">
          <Link
            href="/login"
            className="text-sm font-medium text-primary hover:text-primary-hover"
          >
            ¿Ya tienes una cuenta? Inicia sesión
          </Link>
        </div>
      </AuthForm>
    </AuthLayout>
  );
}


Ruta: app\(auth)\reset-password\page.tsx
"use client";

import { Suspense, useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { AuthLayout } from "@/components/auth/auth-layout";
import { AuthForm } from "@/components/auth/auth-form";
import { FormField, FormLabel, FormDescription } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { CheckCircleIcon, XCircleIcon } from "lucide-react";
import Link from "next/link";

function ResetPasswordPageContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isValidatingToken, setIsValidatingToken] = useState(true);
  const [isTokenValid, setIsTokenValid] = useState(false);
  const [success, setSuccess] = useState(false);

  // Obtener token de la URL
  const token = searchParams.get("token");

  // Validar token al cargar la página
  useEffect(() => {
    const validateToken = async () => {
      if (!token) {
        setIsValidatingToken(false);
        return;
      }

      try {
        const response = await fetch(
          `${process.env.NEXT_PUBLIC_API_URL}/auth/validate-reset-token/${token}`,
          {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          setIsTokenValid(true);
        } else {
          setIsTokenValid(false);
        }
      } catch (error) {
        console.error("Error validando token:", error);
        setIsTokenValid(false);
      } finally {
        setIsValidatingToken(false);
      }
    };

    validateToken();
  }, [token]);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsLoading(true);
    const formData = new FormData(event.currentTarget);
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirmPassword") as string;

    if (password !== confirmPassword) {
      setError("Las contraseñas no coinciden");
      setIsLoading(false);
      return;
    }

    try {
      // Añadir await aquí para esperar la respuesta
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/reset-password`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          token,
          password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Error al restablecer la contraseña");
      }

      setSuccess(true);
      // Redirección automática después de 3 segundos
      setTimeout(() => {
        router.push("/login");
      }, 3000);
    } catch (error: any) {
      console.error("Error al restablecer contraseña:", error);
      setError(
        error.message ||
          "Ocurrió un error al intentar restablecer la contraseña"
      );
    } finally {
      setIsLoading(false);
    }
  }

  // Mostrar pantalla de carga mientras se valida el token
  if (isValidatingToken) {
    return (
      <AuthLayout
        title="Validando enlace"
        subtitle="Por favor espera mientras validamos tu enlace"
        showDemoAlert={false}
      >
        <div className="flex justify-center items-center p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
        </div>
      </AuthLayout>
    );
  }

  // Mostrar error si el token no es válido
  if (!isTokenValid) {
    return (
      <AuthLayout
        title="Enlace inválido"
        subtitle="Este enlace para restablecer la contraseña no es válido o ha expirado"
        showDemoAlert={false}
      >
        <div className="bg-background rounded-xl border border-border p-8 text-center space-y-6">
          <div className="mx-auto w-12 h-12 rounded-full bg-error/10 flex items-center justify-center">
            <XCircleIcon className="w-6 h-6 text-error" />
          </div>
          <p className="text-sm text-content">
            Por favor, solicita un nuevo enlace para restablecer tu contraseña.
          </p>
          <Link
            href="/forgot-password"
            className="text-primary hover:text-primary-hover font-medium block"
          >
            Solicitar nuevo enlace
          </Link>
        </div>
      </AuthLayout>
    );
  }

  // Mostrar pantalla de éxito después de cambiar la contraseña
  if (success) {
    return (
      <AuthLayout
        title="¡Contraseña actualizada!"
        subtitle="Tu contraseña ha sido restablecida exitosamente"
        showDemoAlert={false}
      >
        <div className="bg-background rounded-xl border border-border p-8 text-center space-y-6">
          <div className="mx-auto w-12 h-12 rounded-full bg-success/10 flex items-center justify-center">
            <CheckCircleIcon className="w-6 h-6 text-success" />
          </div>
          <p className="text-sm text-content">
            Serás redirigido al inicio de sesión en unos segundos...
          </p>
          <Link
            href="/login"
            className="text-primary hover:text-primary-hover font-medium block"
          >
            Ir al inicio de sesión
          </Link>
        </div>
      </AuthLayout>
    );
  }

  // Formulario para resetear contraseña
  return (
    <AuthLayout
      title="Restablecer contraseña"
      subtitle="Ingresa y confirma tu nueva contraseña"
      showDemoAlert={false}
    >
      <AuthForm
        onSubmit={handleSubmit}
        error={error}
        isLoading={isLoading}
        submitText="Guardar nueva contraseña"
      >
        <FormField>
          <FormLabel htmlFor="password">Nueva contraseña</FormLabel>
          <Input
            id="password"
            name="password"
            type="password"
            required
            placeholder="••••••••"
            disabled={isLoading}
          />
          <FormDescription>
            La contraseña debe tener al menos 8 caracteres
          </FormDescription>
        </FormField>
        <FormField>
          <FormLabel htmlFor="confirmPassword">Confirmar contraseña</FormLabel>
          <Input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            required
            placeholder="••••••••"
            disabled={isLoading}
          />
        </FormField>
        <input type="hidden" name="token" value={token ?? ""} />
      </AuthForm>
    </AuthLayout>
  );
}

export default function ResetPasswordPage() {
  return (
    <Suspense fallback={<div>Cargando...</div>}>
      <ResetPasswordPageContent />
    </Suspense>
  );
}

Ruta: app\(dashboard)\dashboard\agenda\page.tsx
// web\app\(dashboard)\dashboard\agenda\page.tsx
"use client";

import React, { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useSession } from "next-auth/react";
import { useNotification } from "@/contexts/NotificationContext";
import {
  Calendar,
  CheckCircle,
  ArrowLeft,
  ArrowRight,
  Clock,
  AlertTriangle,
  MapPin,
  Loader2,
  Eye,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  getWorkerTasks,
  finalizeTask,
  startTask,
  FinalizeTaskData,
  Task,
} from "@/services/tasks";
import FinalizeTaskForm from "@/components/tasks/FinalizeTaskForm";
import DownloadTaskReportButton from "@/components/tasks/DownloadTaskReportButton";
import { formatDate, formatTime, getWeekDayName } from "@/utils/date-format";
import TaskDetail from "@/components/tasks/TaskDetail";

export default function AgendaPage() {
  const { data: session } = useSession();
  const { addNotification } = useNotification();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isStartingTask, setIsStartingTask] = useState<number | null>(null);
  const [viewMode, setViewMode] = useState<"daily" | "weekly" | "monthly">(
    "weekly"
  );
  const [selectedDate, setSelectedDate] = useState(
    new Date().toISOString().split("T")[0]
  );
  const [isFinalizing, setIsFinalizing] = useState(false);
  const [isViewingDetails, setIsViewingDetails] = useState(false);
  const [currentTask, setCurrentTask] = useState<Task | null>(null);
  const [filterState, setFilterState] = useState<string>("all");
  const [isChangingDate, setIsChangingDate] = useState(false);

  // Formatear rango de fechas para el título
  const getDateRangeTitle = () => {
    const date = new Date(selectedDate);

    if (viewMode === "daily") {
      return formatDate(date, "dd MMMM yyyy");
    }

    if (viewMode === "weekly") {
      // Encontrar el primer día de la semana (domingo)
      const day = date.getDay();
      const startOfWeek = new Date(date);
      startOfWeek.setDate(date.getDate() - day);

      const endOfWeek = new Date(startOfWeek);
      endOfWeek.setDate(startOfWeek.getDate() + 6);

      return `${formatDate(startOfWeek, "dd MMM")} - ${formatDate(
        endOfWeek,
        "dd MMM yyyy"
      )}`;
    }

    if (viewMode === "monthly") {
      return formatDate(date, "MMMM yyyy");
    }

    return formatDate(date);
  };

  // Cargar tareas al cambiar la fecha o el modo de vista
  useEffect(() => {
    fetchWorkerTasks();
  }, [selectedDate, viewMode]);

  const fetchWorkerTasks = async () => {
    setIsLoading(true);
    try {
      // Parámetros para la solicitud
      const queryParams = new URLSearchParams();
      queryParams.append("date", selectedDate);
      queryParams.append("view", viewMode);

      const data = await getWorkerTasks(queryParams.toString());

      if (data && data.tasks) {
        setTasks(data.tasks);
        addNotification("success", "Tareas cargadas correctamente");
      } else {
        setTasks([]);
        console.error("Formato de datos inválido:", data);
      }
    } catch (error) {
      console.error("Error al cargar tareas:", error);
      addNotification("error", "Error al cargar tareas");
      setTasks([]);
    } finally {
      setIsLoading(false);
      setIsChangingDate(false);
    }
  };

  // Manejar inicio de tarea
  const handleStartTask = async (task: Task) => {
    try {
      setIsStartingTask(task.id);
      const result = await startTask(task.id);
      if (result && result.task) {
        setTasks((prev) =>
          prev.map((t) => (t.id === result.task.id ? result.task : t))
        );
        addNotification("success", "Tarea iniciada correctamente");
      } else {
        throw new Error("No se pudo iniciar la tarea");
      }
    } catch (error) {
      console.error("Error iniciando tarea:", error);
      addNotification("error", "Error al iniciar la tarea");
    } finally {
      setIsStartingTask(null);
    }
  };

  // Función para navegar a la fecha anterior
  const goToPreviousDate = () => {
    setIsChangingDate(true);
    const date = new Date(selectedDate);

    if (viewMode === "daily") {
      date.setDate(date.getDate() - 1);
    } else if (viewMode === "weekly") {
      date.setDate(date.getDate() - 7);
    } else if (viewMode === "monthly") {
      date.setMonth(date.getMonth() - 1);
    }

    setSelectedDate(date.toISOString().split("T")[0]);
  };

  // Función para navegar a la fecha siguiente
  const goToNextDate = () => {
    setIsChangingDate(true);
    const date = new Date(selectedDate);

    if (viewMode === "daily") {
      date.setDate(date.getDate() + 1);
    } else if (viewMode === "weekly") {
      date.setDate(date.getDate() + 7);
    } else if (viewMode === "monthly") {
      date.setMonth(date.getMonth() + 1);
    }

    setSelectedDate(date.toISOString().split("T")[0]);
  };

  // Función para ir a la fecha actual
  const goToToday = () => {
    setIsChangingDate(true);
    setSelectedDate(new Date().toISOString().split("T")[0]);
  };

  // Manejar finalización de tarea
  const handleFinalizeSubmit = async (data: FinalizeTaskData) => {
    try {
      const result = await finalizeTask(data);
      if (result && result.task) {
        setTasks((prev) =>
          prev.map((t) => (t.id === result.task.id ? result.task : t))
        );
        addNotification("success", "Tarea finalizada correctamente");
        setIsFinalizing(false);
        setCurrentTask(null);
      } else {
        throw new Error("No se pudo finalizar la tarea");
      }
    } catch (error) {
      console.error("Error finalizando tarea:", error);
      addNotification("error", "Error al finalizar la tarea");
    }
  };

  // Ver detalles de la tarea
  const handleViewDetails = (task: Task) => {
    setCurrentTask(task);
    setIsViewingDetails(true);
  };

  // Obtener estado formateado
  const getStateDisplay = (state: string) => {
    switch (state) {
      case "PENDIENTE":
        return (
          <Badge variant="warning" className="flex items-center gap-1">
            <Clock className="h-3 w-3" />
            <span>Pendiente</span>
          </Badge>
        );
      case "EN_CURSO":
        return (
          <Badge variant="info" className="flex items-center gap-1">
            <Clock className="h-3 w-3" />
            <span>En curso</span>
          </Badge>
        );
      case "FINALIZADO":
        return (
          <Badge variant="success" className="flex items-center gap-1">
            <CheckCircle className="h-3 w-3" />
            <span>Finalizado</span>
          </Badge>
        );
      default:
        return <Badge variant="secondary">{state}</Badge>;
    }
  };

  // Verificar si una tarea está vencida
  const isTaskOverdue = (task: Task) => {
    if (task.state === "FINALIZADO") return false;

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const taskDate = new Date(task.startDate);
    taskDate.setHours(0, 0, 0, 0);

    return taskDate < today;
  };

  // Filtrar tareas según el estado seleccionado
  const filteredTasks = tasks.filter((task) => {
    if (filterState === "all") return true;
    if (filterState === "overdue") return isTaskOverdue(task);
    return task.state === filterState;
  });

  // Renderizar tarjetas para móvil
  const renderTaskCard = (task: Task) => {
    const date = new Date(task.startDate);
    const isTaskStarting = isStartingTask === task.id;

    return (
      <Card key={task.id} className="mb-4 overflow-hidden">
        <div className="p-4 border-b">
          <div className="flex justify-between items-start mb-1">
            <div className="font-medium text-lg">{task.title}</div>
            {getStateDisplay(task.state)}
          </div>
          {task.description && (
            <p className="text-sm text-content-subtle mb-2 line-clamp-2">
              {task.description}
            </p>
          )}
        </div>

        <div className="p-4 border-b bg-accent/10">
          <div className="grid grid-cols-2 gap-2">
            <div>
              <p className="text-xs text-content-subtle">Fecha</p>
              <div className="flex items-center">
                <Calendar className="h-3 w-3 mr-1 text-content-subtle" />
                <span className="text-sm">{formatDate(date)}</span>
              </div>
            </div>
            <div>
              <p className="text-xs text-content-subtle">Hora</p>
              <div className="flex items-center">
                <Clock className="h-3 w-3 mr-1 text-content-subtle" />
                <span className="text-sm">
                  {formatTime(date)} - {getWeekDayName(date, true)}
                </span>
              </div>
            </div>
          </div>
        </div>

        <div className="p-4">
          <div className="mb-3">
            <p className="text-xs font-medium text-content-subtle mb-1">
              Cliente
            </p>
            {task.client ? (
              <div>
                <p className="text-sm font-medium">{task.client.name}</p>
                {task.client.address && (
                  <div className="text-xs text-content-subtle flex items-center">
                    <MapPin className="h-3 w-3 mr-1" />
                    <span className="truncate">{task.client.address}</span>
                  </div>
                )}
              </div>
            ) : (
              <span className="text-sm text-content-subtle">Sin cliente</span>
            )}
          </div>

          <div className="flex flex-wrap gap-1 mb-4">
            {task.types &&
              task.types.map((type) => (
                <Badge key={type} variant="outline" className="text-xs">
                  {type}
                </Badge>
              ))}
          </div>

          <div className="flex flex-wrap gap-2">
            {task.state === "PENDIENTE" && (
              <Button
                variant="default"
                size="sm"
                className="flex-1"
                onClick={() => handleStartTask(task)}
                disabled={isTaskStarting === task.id}
              >
                {isTaskStarting === task.id ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                    Iniciando...
                  </>
                ) : (
                  <>
                    <Clock className="h-4 w-4 mr-1" />
                    Iniciar
                  </>
                )}
              </Button>
            )}
            {task.state === "EN_CURSO" && (
              <Button
                variant="default"
                size="sm"
                className="flex-1"
                onClick={() => {
                  setCurrentTask(task);
                  setIsFinalizing(true);
                }}
              >
                <CheckCircle className="h-4 w-4 mr-1" />
                Finalizar
              </Button>
            )}
            <Button
              variant="outline"
              size="sm"
              className="flex-1"
              onClick={() => handleViewDetails(task)}
            >
              <Eye className="h-4 w-4 mr-1" />
              Ver Detalles
            </Button>
            {task.state === "FINALIZADO" && task.id && (
              <DownloadTaskReportButton
                taskId={task.id}
                variant="outline"
                size="sm"
                label="Descargar"
                showIcon={true}
                className="flex-1"
              />
            )}
          </div>
        </div>
      </Card>
    );
  };

  // Columnas para la DataTable
  const columns: ColumnDef<Task>[] = [
    {
      accessorKey: "title",
      header: "Título",
      cell: ({ row }) => (
        <div>
          <div className="font-medium">{row.original.title}</div>
          {row.original.description && (
            <div className="text-sm text-content-subtle truncate max-w-md">
              {row.original.description}
            </div>
          )}
        </div>
      ),
    },
    {
      accessorKey: "startDate",
      header: "Fecha y Hora",
      cell: ({ row }) => {
        const date = new Date(row.original.startDate);
        return (
          <div className="space-y-1">
            <div className="flex items-center">
              <Calendar className="h-4 w-4 mr-1 text-content-subtle" />
              <span>{formatDate(date)}</span>
            </div>
            <div className="text-sm text-content-subtle">
              {formatTime(date)} - {getWeekDayName(date)}
            </div>
            {isTaskOverdue(row.original) && (
              <div className="flex items-center text-error text-xs">
                <AlertTriangle className="h-3 w-3 mr-1" />
                <span>Vencida</span>
              </div>
            )}
          </div>
        );
      },
    },
    {
      accessorKey: "client",
      header: "Cliente",
      cell: ({ row }) => (
        <div>
          {row.original.client ? (
            <>
              <div className="font-medium">{row.original.client.name}</div>
              {row.original.client.address && (
                <div className="text-sm text-content-subtle flex items-center">
                  <MapPin className="h-3 w-3 mr-1" />
                  {row.original.client.address}
                </div>
              )}
            </>
          ) : (
            <span className="text-content-subtle">Sin cliente</span>
          )}
        </div>
      ),
    },
    {
      accessorKey: "state",
      header: "Estado",
      cell: ({ row }) => getStateDisplay(row.original.state),
    },
    {
      accessorKey: "types",
      header: "Tipo",
      cell: ({ row }) => (
        <div className="flex flex-wrap gap-1">
          {row.original.types &&
            row.original.types.map((type) => (
              <Badge key={type} variant="outline" className="text-xs">
                {type}
              </Badge>
            ))}
        </div>
      ),
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          {row.original.state === "PENDIENTE" && (
            <Button
              variant="default"
              size="sm"
              onClick={() => handleStartTask(row.original)}
              disabled={isStartingTask === row.original.id}
            >
              {isStartingTask === row.original.id ? (
                <>
                  <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                  Iniciando...
                </>
              ) : (
                <>
                  <Clock className="h-4 w-4 mr-1" />
                  Iniciar
                </>
              )}
            </Button>
          )}
          {row.original.state === "EN_CURSO" && (
            <Button
              variant="default"
              size="sm"
              onClick={() => {
                setCurrentTask(row.original);
                setIsFinalizing(true);
              }}
            >
              <CheckCircle className="h-4 w-4 mr-1" />
              Finalizar
            </Button>
          )}
          {row.original.state === "FINALIZADO" && row.original.id && (
            <DownloadTaskReportButton
              taskId={row.original.id}
              variant="outline"
              size="sm"
              label="Descargar"
              showIcon={true}
            />
          )}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handleViewDetails(row.original)}
          >
            <Eye className="h-4 w-4 mr-1" />
            Ver Detalles
          </Button>
        </div>
      ),
    },
  ];

  // Componente de carga (loading)
  if (isLoading) {
    return (
      <div className="space-y-8">
        <div>
          <h1 className="text-3xl font-bold">Agenda</h1>
          <p className="text-content-subtle mt-1">
            Gestiona tus tareas asignadas y reportes técnicos
          </p>
        </div>

        <div className="h-[500px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Cargando tareas...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Agenda</h1>
        <p className="text-content-subtle mt-1">
          Gestiona tus tareas asignadas y reportes técnicos
        </p>
      </div>

      <div className="flex flex-col md:flex-row gap-4 justify-between">
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="icon"
            onClick={goToPreviousDate}
            title="Anterior"
            disabled={isChangingDate}
          >
            <ArrowLeft className="h-4 w-4" />
          </Button>

          <Button
            variant="outline"
            onClick={goToToday}
            className="whitespace-nowrap"
            disabled={isChangingDate}
          >
            {isChangingDate ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : null}
            Hoy
          </Button>

          <Button
            variant="outline"
            size="icon"
            onClick={goToNextDate}
            title="Siguiente"
            disabled={isChangingDate}
          >
            <ArrowRight className="h-4 w-4" />
          </Button>

          <h2 className="text-lg font-semibold px-2">{getDateRangeTitle()}</h2>
        </div>

        <div className="flex flex-col md:flex-row gap-2">
          <Select
            value={viewMode}
            onValueChange={(value: "daily" | "weekly" | "monthly") => {
              setIsChangingDate(true);
              setViewMode(value);
            }}
            disabled={isChangingDate}
          >
            <SelectTrigger className="w-full md:w-32">
              <SelectValue placeholder="Vista" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="daily">Diaria</SelectItem>
              <SelectItem value="weekly">Semanal</SelectItem>
              <SelectItem value="monthly">Mensual</SelectItem>
            </SelectContent>
          </Select>

          <Select
            value={filterState}
            onValueChange={setFilterState}
            disabled={isChangingDate}
          >
            <SelectTrigger className="w-full md:w-40">
              <SelectValue placeholder="Filtrar por estado" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">Todos</SelectItem>
              <SelectItem value="PENDIENTE">Pendientes</SelectItem>
              <SelectItem value="EN_CURSO">En Curso</SelectItem>
              <SelectItem value="FINALIZADO">Finalizados</SelectItem>
              <SelectItem value="overdue">Vencidos</SelectItem>
            </SelectContent>
          </Select>

          <Input
            type="date"
            value={selectedDate}
            onChange={(e) => {
              setIsChangingDate(true);
              setSelectedDate(e.target.value);
            }}
            className="w-full md:w-auto"
            disabled={isChangingDate}
          />
        </div>
      </div>

      {/* Vista móvil - Tarjetas */}
      <div className="lg:hidden">
        {filteredTasks.length === 0 ? (
          <div className="text-center py-12 bg-accent/10 rounded-lg">
            <Calendar className="h-12 w-12 mx-auto text-content-subtle mb-2" />
            <h3 className="text-lg font-medium">No hay tareas</h3>
            <p className="text-content-subtle">
              No se encontraron tareas para el período seleccionado
            </p>
          </div>
        ) : (
          filteredTasks.map((task) => renderTaskCard(task))
        )}
      </div>

      {/* Vista desktop - Tabla */}
      <div className="hidden lg:block">
        <Card>
          <DataTable
            columns={columns}
            data={filteredTasks}
            isLoading={isLoading}
          />
        </Card>
      </div>

      {/* Modal para finalizar tarea */}
      <FinalizeTaskForm
        isOpen={isFinalizing}
        task={currentTask}
        onSave={handleFinalizeSubmit}
        onClose={() => {
          setIsFinalizing(false);
          setCurrentTask(null);
        }}
      />

      {/* Modal para ver detalles de la tarea */}
      {isViewingDetails && currentTask && (
        <Dialog
          open={isViewingDetails}
          onOpenChange={(open) => {
            if (!open) {
              setIsViewingDetails(false);
              setCurrentTask(null);
            }
          }}
        >
          <DialogContent className="max-w-7xl max-h-[90vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle>Detalles de la Tarea</DialogTitle>
            </DialogHeader>
            <TaskDetail
              task={currentTask}
              isAdmin={false}
              onEdit={() => {}}
              onDelete={() => {}}
              onStart={(task) => handleStartTask(task)}
              onFinalize={(task) => {
                setIsViewingDetails(false);
                setCurrentTask(task);
                setIsFinalizing(true);
              }}
            />
            <div className="flex justify-end mt-4">
              <Button
                onClick={() => setIsViewingDetails(false)}
                variant="outline"
              >
                Cerrar
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\customers\page.tsx
"use client";

import { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import { Plus, Trash, Edit } from "lucide-react";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import {
  getClients,
  createClient,
  updateClient,
  deleteClient,
} from "@/services/clients";
import { CustomerForm } from "@/components/clients/CustomerForm";
import { EmailBadge } from "@/components/clients/EmailBadge";

interface Customer {
  id: string;
  name: string;
  email: string;
  emailSecondary?: string;
  emailTertiary?: string;
  phone: string;
  rut?: string;
  address?: string;
  commune?: string;
  administrator?: string;
  butler?: string;
  notes?: string;
}

export default function CustomersPage() {
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [isEditing, setIsEditing] = useState(false);
  const [currentCustomer, setCurrentCustomer] = useState<Customer | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [customerToDelete, setCustomerToDelete] = useState<Customer | null>(
    null
  );
  const [isDeletingCustomer, setIsDeletingCustomer] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Obtener clientes del backend al cargar el componente
  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        const data = await getClients();
        setCustomers(data);
      } catch (err) {
        setError("Error al cargar los clientes");
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };
    fetchCustomers();
  }, []);

  const handleAddCustomer = () => {
    setIsEditing(true);
    setCurrentCustomer(null);
    setError(null);
  };

  const handleEditCustomer = (customer: Customer) => {
    setIsEditing(true);
    setCurrentCustomer(customer);
    setError(null);
  };

  const openDeleteConfirm = (customer: Customer) => {
    setCustomerToDelete(customer);
    setIsDeleteConfirmOpen(true);
  };

  const handleDeleteCustomer = async () => {
    if (!customerToDelete) return;

    try {
      setIsDeletingCustomer(true);
      await deleteClient(customerToDelete.id);
      setCustomers(
        customers.filter((customer) => customer.id !== customerToDelete.id)
      );
      setError(null);
    } catch (err) {
      setError("Error al eliminar el cliente");
      console.error(err);
    } finally {
      setIsDeletingCustomer(false);
      setCustomerToDelete(null);
      setIsDeleteConfirmOpen(false);
    }
  };

  const handleSaveCustomer = async (customer: Customer) => {
    try {
      setIsSubmitting(true);
      if (currentCustomer) {
        // Editar cliente existente
        const updatedCustomer = await updateClient(customer.id, customer);
        setCustomers(
          customers.map((c) => (c.id === customer.id ? updatedCustomer : c))
        );
      } else {
        // Crear nuevo cliente
        const newCustomer = await createClient(customer);
        setCustomers([...customers, newCustomer]);
      }
      setIsEditing(false);
      setError(null);
    } catch (err) {
      setError("Error al guardar el cliente");
      console.error(err);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Componente para mostrar emails con badge
  const EmailsDisplay = ({ customer }: { customer: Customer }) => {
    const emails = [
      customer.email,
      customer.emailSecondary,
      customer.emailTertiary
    ].filter(email => email && email.trim() !== "");
    
    return (
      <div className="flex items-center">
        <span>{customer.email}</span>
        <EmailBadge emails={emails} />
      </div>
    );
  };

  const columns: ColumnDef<Customer>[] = [
    { accessorKey: "name", header: "Nombre" },
    { 
      id: "emails",
      header: "Correos",
      cell: ({ row }) => <EmailsDisplay customer={row.original} />
    },
    { accessorKey: "phone", header: "Teléfono" },
    { accessorKey: "address", header: "Dirección" },
    { accessorKey: "commune", header: "Comuna" },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => handleEditCustomer(row.original)}
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => openDeleteConfirm(row.original)}
          >
            <Trash className="h-4 w-4" />
          </Button>
        </div>
      ),
    },
  ];

  // Filtrar clientes por nombre o por cualquiera de los tres emails
  const filteredCustomers = customers.filter((customer) =>
    customer.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    customer.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (customer.emailSecondary && customer.emailSecondary.toLowerCase().includes(searchTerm.toLowerCase())) ||
    (customer.emailTertiary && customer.emailTertiary.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">Clientes</h1>
        <p className="text-content-subtle mt-2">
          Administra tus clientes y sus datos
        </p>
      </div>
      <Card className="p-6">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">Lista de Clientes</h2>
          <div className="flex items-center gap-4">
            <Input
              placeholder="Buscar por nombre o email..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="max-w-xs"
            />
            <Button onClick={handleAddCustomer}>
              <Plus className="mr-2 h-4 w-4" />
              Agregar Cliente
            </Button>
          </div>
        </div>
        {isLoading ? (
          <div className="text-center h-96 flex items-center justify-center">
            <p>Cargando clientes...</p>
          </div>
        ) : (
          <DataTable columns={columns} data={filteredCustomers} />
        )}
      </Card>

      {isEditing && (
        <CustomerForm
          customer={currentCustomer}
          onSave={handleSaveCustomer}
          onCancel={() => setIsEditing(false)}
          isSubmitting={isSubmitting}
          error={error}
        />
      )}

      <ConfirmDialog
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Eliminar Cliente"
        description={`¿Estás seguro que deseas eliminar al cliente "${customerToDelete?.name}"? Esta acción no se puede deshacer.`}
        onConfirm={handleDeleteCustomer}
        confirmLabel="Eliminar"
        isLoading={isDeletingCustomer}
      />
    </div>
  );
}

Ruta: app\(dashboard)\dashboard\maintenance\page.tsx
// app/(dashboard)/dashboard/maintenance/page.tsx
"use client";

import React, { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useNotification } from "@/contexts/NotificationContext";
import {
  getAllMaintenances,
  getUpcomingMaintenances,
  createMaintenance,
  updateMaintenance,
  deleteMaintenance,
  getMaintenancesByClient, // Importar la nueva función
  type Maintenance,
} from "@/services/maintenance";
import ClientSelect from "@/components/clients/ClientSelect";
import {
  Plus,
  Search,
  Calendar as CalendarIconLucide, // Renombrar para evitar conflicto
  Edit,
  Trash,
  AlertTriangle,
  CheckCircle,
  Clock,
  Loader2,
  RefreshCcw,
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { formatDate } from "@/utils/date-format";
import {
  calculateNextMaintenanceDate,
  getMaintenanceStatus,
} from "@/utils/maintenance-utils";
import { getClients, Client } from "@/services/clients"; // Importar Client

export default function MaintenancePage() {
  const [maintenances, setMaintenances] = useState<Maintenance[]>([]);
  const [filteredMaintenances, setFilteredMaintenances] = useState<
    Maintenance[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState<"all" | "upcoming">("all");
  const [upcomingDays, setUpcomingDays] = useState(30);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [currentMaintenance, setCurrentMaintenance] =
    useState<Maintenance | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [maintenanceToDelete, setMaintenanceToDelete] =
    useState<Maintenance | null>(null);
  const { addNotification } = useNotification();
  const [allClients, setAllClients] = useState<Client[]>([]); // Para el filtro de cliente
  const [selectedClientFilter, setSelectedClientFilter] = useState<
    string | undefined
  >(undefined); // Para el filtro
  const [isLoadingClients, setIsLoadingClients] = useState(true);

  useEffect(() => {
    const loadClients = async () => {
      setIsLoadingClients(true);
      try {
        const clientsData = await getClients();
        setAllClients(clientsData || []);
      } catch (error) {
        console.error("Error al cargar clientes para filtro:", error);
        addNotification("error", "Error al cargar lista de clientes");
      } finally {
        setIsLoadingClients(false);
      }
    };
    loadClients();
  }, [addNotification]);

  useEffect(() => {
    fetchMaintenances();
  }, [viewMode, upcomingDays, selectedClientFilter]); // Añadir selectedClientFilter a las dependencias

  useEffect(() => {
    const filtered = maintenances.filter(
      (m) =>
        (m.client?.name || "")
          .toLowerCase()
          .includes(searchTerm.toLowerCase()) ||
        (m.notes || "").toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredMaintenances(filtered);
  }, [searchTerm, maintenances]);

  const fetchMaintenances = async () => {
    setIsLoading(true);
    try {
      let data;
      if (selectedClientFilter && selectedClientFilter !== "ALL") {
        data = await getMaintenancesByClient(selectedClientFilter);
      } else if (viewMode === "upcoming") {
        data = await getUpcomingMaintenances(upcomingDays);
      } else {
        data = await getAllMaintenances();
      }
      setMaintenances(data);
      setFilteredMaintenances(data); // Actualizar también aquí
      // addNotification("success", "Mantenimientos cargados correctamente"); // Puede ser muy ruidoso
    } catch (error) {
      console.error("Error al cargar mantenimientos:", error);
      addNotification("error", "Error al cargar mantenimientos");
    } finally {
      setIsLoading(false);
    }
  };

  const openModal = (maintenance?: Maintenance) => {
    setCurrentMaintenance(maintenance || null);
    setIsModalOpen(true);
  };

  const closeModal = () => {
    setIsModalOpen(false);
    setCurrentMaintenance(null);
  };

  const handleDelete = async () => {
    if (!maintenanceToDelete || !maintenanceToDelete.id) return;
    setIsDeleting(true);
    try {
      await deleteMaintenance(maintenanceToDelete.id.toString());
      setMaintenances((prev) =>
        prev.filter((m) => m.id !== maintenanceToDelete.id)
      );
      // setFilteredMaintenances((prev) => prev.filter((m) => m.id !== maintenanceToDelete.id)); // Se actualiza por el useEffect
      addNotification("success", "Mantenimiento eliminado correctamente");
    } catch (error) {
      addNotification("error", "Error al eliminar mantenimiento");
    } finally {
      setIsDeleting(false);
      setMaintenanceToDelete(null);
    }
  };

  const handleFormSubmit = async (maintenanceData: Maintenance) => {
    try {
      if (currentMaintenance && currentMaintenance.id) {
        const response = await updateMaintenance(
          currentMaintenance.id.toString(),
          maintenanceData
        );
        setMaintenances((prev) =>
          prev.map((m) =>
            m.id === currentMaintenance.id ? response.maintenance : m
          )
        );
        addNotification("success", "Mantenimiento actualizado");
      } else {
        const response = await createMaintenance(maintenanceData);
        setMaintenances((prev) => [...prev, response.maintenance]);
        addNotification("success", "Mantenimiento creado");
      }
      closeModal();
      fetchMaintenances(); // Recargar la lista después de guardar
    } catch (error) {
      addNotification("error", "Error al guardar mantenimiento");
    }
  };

  const getStatusBadge = (nextDate: string) => {
    const status = getMaintenanceStatus(nextDate);
    switch (status) {
      case "overdue":
        return (
          <div className="flex items-center gap-1 text-error">
            <AlertTriangle className="h-4 w-4" /> <span>Vencido</span>
          </div>
        );
      case "urgent":
        return (
          <div className="flex items-center gap-1 text-warning">
            <Clock className="h-4 w-4" /> <span>Urgente</span>
          </div>
        );
      case "upcoming":
        return (
          <div className="flex items-center gap-1 text-info">
            <CalendarIconLucide className="h-4 w-4" /> <span>Próximo</span>
          </div>
        );
      default:
        return (
          <div className="flex items-center gap-1 text-success">
            <CheckCircle className="h-4 w-4" /> <span>Programado</span>
          </div>
        );
    }
  };

  const columns: ColumnDef<Maintenance>[] = [
    {
      accessorKey: "client",
      header: "Cliente",
      cell: ({ row }) => (
        <span>{row.original.client?.name || "Sin cliente"}</span>
      ),
    },
    {
      accessorKey: "lastMaintenanceDate",
      header: "Último mantenimiento",
      cell: ({ row }) => (
        <span>{formatDate(row.original.lastMaintenanceDate)}</span>
      ),
    },
    {
      accessorKey: "nextMaintenanceDate",
      header: "Próximo mantenimiento",
      cell: ({ row }) => (
        <span>{formatDate(row.original.nextMaintenanceDate)}</span>
      ),
    },
    {
      accessorKey: "status",
      header: "Estado",
      cell: ({ row }) => getStatusBadge(row.original.nextMaintenanceDate),
    },
    {
      accessorKey: "frequency",
      header: "Frecuencia",
      cell: ({ row }) => {
        const frequencyMap: Record<string, string> = {
          MENSUAL: "Mensual",
          BIMESTRAL: "Bimestral",
          TRIMESTRAL: "Trimestral",
          SEMESTRAL: "Semestral",
          ANUAL: "Anual",
        };
        return (
          <span>
            {frequencyMap[row.original.frequency] || row.original.frequency}
          </span>
        );
      },
    },
    {
      accessorKey: "notes",
      header: "Notas",
      cell: ({ row }) => (
        <span className="truncate max-w-xs">{row.original.notes}</span>
      ),
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => openModal(row.original)}
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setMaintenanceToDelete(row.original)}
          >
            <Trash className="h-4 w-4" />
          </Button>
        </div>
      ),
    },
  ];

  const MaintenanceForm = ({
    maintenance,
    onSave,
    onCancel,
  }: {
    maintenance: Maintenance | null;
    onSave: (data: Maintenance) => void;
    onCancel: () => void;
  }) => {
    const [clientId, setClientId] = useState(
      maintenance ? maintenance.clientId.toString() : ""
    );
    const [lastMaintenanceDate, setLastMaintenanceDate] = useState(
      maintenance
        ? formatDate(maintenance.lastMaintenanceDate, "yyyy-MM-dd")
        : formatDate(new Date(), "yyyy-MM-dd")
    );
    const [nextMaintenanceDate, setNextMaintenanceDate] = useState(
      maintenance
        ? formatDate(maintenance.nextMaintenanceDate, "yyyy-MM-dd")
        : formatDate(
            new Date(Date.now() + 90 * 24 * 60 * 60 * 1000),
            "yyyy-MM-dd"
          )
    );
    const [frequency, setFrequency] = useState<
      "MENSUAL" | "BIMESTRAL" | "TRIMESTRAL" | "SEMESTRAL" | "ANUAL"
    >(maintenance ? maintenance.frequency : "TRIMESTRAL");
    const [notes, setNotes] = useState(
      maintenance ? maintenance.notes || "" : ""
    );
    const [formClients, setFormClients] = useState<Client[]>([]); // Clientes para el select dentro del formulario
    const [isLoadingFormClients, setIsLoadingFormClients] = useState(true);

    useEffect(() => {
      const loadFormClients = async () => {
        setIsLoadingFormClients(true);
        try {
          const clientsData = await getClients();
          setFormClients(clientsData || []);
        } catch (error) {
          addNotification(
            "error",
            "Error al cargar clientes para el formulario."
          );
        } finally {
          setIsLoadingFormClients(false);
        }
      };
      loadFormClients();
    }, [addNotification]);

    useEffect(() => {
      if (lastMaintenanceDate) {
        const nextDate = calculateNextMaintenanceDate(
          new Date(lastMaintenanceDate),
          frequency
        );
        setNextMaintenanceDate(formatDate(nextDate, "yyyy-MM-dd"));
      }
    }, [lastMaintenanceDate, frequency]);

    const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      if (!clientId) {
        addNotification("error", "Debes seleccionar un cliente");
        return;
      }
      if (!lastMaintenanceDate || !nextMaintenanceDate) {
        addNotification("error", "Las fechas son obligatorias");
        return;
      }
      const maintenanceData: Maintenance = {
        clientId: parseInt(clientId),
        lastMaintenanceDate,
        nextMaintenanceDate,
        frequency,
        notes,
      };
      if (maintenance && maintenance.taskIds) {
        maintenanceData.taskIds = maintenance.taskIds;
      }
      onSave(maintenanceData);
    };

    return (
      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="space-y-4">
          <div>
            <ClientSelect
              clients={formClients}
              value={clientId}
              onValueChange={(val) => setClientId(val)}
              placeholder="Seleccionar cliente"
              isLoading={isLoadingFormClients}
            />
          </div>
          <div>
            <label className="block text-sm font-medium">
              Último mantenimiento
            </label>
            <Input
              type="date"
              value={lastMaintenanceDate}
              onChange={(e) => setLastMaintenanceDate(e.target.value)}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium">Frecuencia</label>
            <Select
              value={frequency}
              onValueChange={(
                val:
                  | "MENSUAL"
                  | "BIMESTRAL"
                  | "TRIMESTRAL"
                  | "SEMESTRAL"
                  | "ANUAL"
              ) => setFrequency(val)}
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Seleccionar frecuencia" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="MENSUAL">Mensual</SelectItem>
                <SelectItem value="BIMESTRAL">Bimestral</SelectItem>
                <SelectItem value="TRIMESTRAL">Trimestral</SelectItem>
                <SelectItem value="SEMESTRAL">Semestral</SelectItem>
                <SelectItem value="ANUAL">Anual</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div>
            <label className="block text-sm font-medium">
              Próximo mantenimiento
            </label>
            <Input
              type="date"
              value={nextMaintenanceDate}
              onChange={(e) => setNextMaintenanceDate(e.target.value)}
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium">Notas</label>
            <textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              className="w-full border rounded-md p-2 min-h-[100px]"
              placeholder="Notas adicionales..."
            />
          </div>
        </div>
        <div className="flex justify-end space-x-2">
          <Button variant="outline" type="button" onClick={onCancel}>
            Cancelar
          </Button>
          <Button type="submit">Guardar</Button>
        </div>
      </form>
    );
  };

  if (isLoading && !maintenances.length) {
    // Mostrar loader principal solo si no hay mantenimientos y se está cargando
    return (
      <div className="space-y-8">
        <div>
          <h1 className="text-3xl font-bold">Mantenimientos</h1>
          <p className="text-content-subtle mt-1">
            Gestiona los mantenimientos programados
          </p>
        </div>
        <div className="h-[500px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Cargando mantenimientos...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">Mantenimientos</h1>
          <p className="text-content-subtle mt-1">
            Gestiona los mantenimientos programados
          </p>
        </div>
        <Button onClick={() => openModal()} disabled={isLoadingClients}>
          <Plus className="mr-2 h-4 w-4" />
          Agregar Mantenimiento
        </Button>
      </div>

      <div className="flex flex-col md:flex-row gap-4 justify-between">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="flex-1 md:w-64">
            <div className="relative">
              <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              <Input
                placeholder="Buscar por cliente o notas..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-8 w-full"
                disabled={isLoading}
              />
            </div>
          </div>

          {/* Filtro por Cliente */}
          <Select
            value={selectedClientFilter || "ALL"}
            onValueChange={(value) =>
              setSelectedClientFilter(value === "ALL" ? undefined : value)
            }
            disabled={isLoadingClients || isLoading}
          >
            <SelectTrigger className="w-full md:w-52">
              {isLoadingClients ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <SelectValue placeholder="Filtrar por cliente" />
              )}
            </SelectTrigger>
            <SelectContent style={{ maxHeight: "300px", overflowY: "auto" }}>
              <SelectItem value="ALL">Todos los clientes</SelectItem>
              {allClients.map((client) => (
                <SelectItem key={client.id} value={client.id!.toString()}>
                  {client.name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Select
            value={viewMode}
            onValueChange={(val: "all" | "upcoming") => setViewMode(val)}
            disabled={isLoading}
          >
            <SelectTrigger className="w-full md:w-44">
              <SelectValue placeholder="Modo de vista" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">Todos</SelectItem>
              <SelectItem value="upcoming">Próximos</SelectItem>
            </SelectContent>
          </Select>

          {viewMode === "upcoming" && (
            <Select
              value={upcomingDays.toString()}
              onValueChange={(val) => setUpcomingDays(parseInt(val))}
              disabled={isLoading}
            >
              <SelectTrigger className="w-full md:w-44">
                <SelectValue placeholder="Período" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="7">Próximos 7 días</SelectItem>
                <SelectItem value="15">Próximos 15 días</SelectItem>
                <SelectItem value="30">Próximos 30 días</SelectItem>
                <SelectItem value="60">Próximos 60 días</SelectItem>
                <SelectItem value="90">Próximos 90 días</SelectItem>
              </SelectContent>
            </Select>
          )}
        </div>
        <Button
          variant="outline"
          onClick={fetchMaintenances}
          className="self-start"
          disabled={isLoading}
        >
          <RefreshCcw className="h-4 w-4 mr-2" />
          Actualizar
        </Button>
      </div>

      <Card>
        <DataTable
          columns={columns}
          data={filteredMaintenances}
          isLoading={isLoading}
        />
      </Card>

      <ConfirmDialog
        open={!!maintenanceToDelete}
        onOpenChange={(open) => {
          if (!open) setMaintenanceToDelete(null);
        }}
        title="Eliminar Mantenimiento"
        description={`¿Estás seguro de eliminar el mantenimiento del cliente ${maintenanceToDelete?.client?.name}?`}
        onConfirm={handleDelete}
        confirmLabel="Eliminar"
        isLoading={isDeleting}
      />

      {isModalOpen && (
        <Dialog
          open={isModalOpen}
          onOpenChange={(open) => {
            if (!open) closeModal();
          }}
        >
          <DialogContent className="max-w-md">
            <DialogHeader>
              <DialogTitle>
                {currentMaintenance
                  ? "Editar Mantenimiento"
                  : "Nuevo Mantenimiento"}
              </DialogTitle>
            </DialogHeader>
            <MaintenanceForm
              maintenance={currentMaintenance}
              onSave={handleFormSubmit}
              onCancel={closeModal}
            />
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useSession } from "next-auth/react";
import {
  Loader2,
  CalendarClock,
  Calendar,
  Clock,
  Users,
  CheckCircle,
  AlertTriangle,
  ChevronRight,
  TrendingUp,
  DollarSign,
  FileText,
  BarChart2,
  Package as PackageIcon,
  UserCircle,
  RefreshCcw,
} from "lucide-react";
import Link from "next/link";
import { formatDate } from "@/utils/date-format";
import { formatCurrency } from "@/utils/number-format";
import {
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
} from "recharts";

// Importación de los servicios necesarios
import { getTasksByDate, type Task } from "@/services/tasks";
import { getQuotationStats } from "@/services/quotations";
import { getSalesStats, getTopProducts } from "@/services/reports";
import { getUpcomingMaintenances } from "@/services/maintenance";
import { DateRangePicker } from "@/components/dashboard/date-range-picker";
import { StatsCard } from "@/components/dashboard/stats-card";
import { useNotification } from "@/contexts/NotificationContext";

// Colores para gráficos
const COLORS = [
  "#b42516",
  "#2563eb",
  "#16a34a",
  "#eab308",
  "#8b5cf6",
  "#ec4899",
];

export default function DashboardPage() {
  const { data: session } = useSession();
  const { addNotification } = useNotification();
  const [isLoading, setIsLoading] = useState(true);
  const isInitialMount = useRef(true);

  // Estados para la vista de técnicos
  const [upcomingTasks, setUpcomingTasks] = useState<Task[]>([]);
  const [overdueItems, setOverdueItems] = useState(0);
  const [tasksToday, setTasksToday] = useState(0);
  const [tasksThisWeek, setTasksThisWeek] = useState(0);
  const [tasksCompleted, setTasksCompleted] = useState(0);
  const [weeklyTasks, setWeeklyTasks] = useState<Task[]>([]);
  const [pendingMonthTasks, setPendingMonthTasks] = useState<Task[]>([]);
  const [completedMonthTasks, setCompletedMonthTasks] = useState<Task[]>([]);

  // Estados para la vista de administradores
  const monthStart = new Date();
  monthStart.setDate(1); // Primer día del mes actual
  const [dateRange, setDateRange] = useState({
    start: new Date(new Date().setMonth(new Date().getMonth() - 1)),
    end: new Date(),
  });
  const [salesData, setSalesData] = useState<any[]>([]);
  const [quotationStats, setQuotationStats] = useState<any>(null);
  const [topProducts, setTopProducts] = useState<any[]>([]);
  const [upcomingMaintenances, setUpcomingMaintenances] = useState<any[]>([]);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [initialDataLoaded, setInitialDataLoaded] = useState(false);

  // Verificar si el usuario es admin
  const isAdmin = session?.user?.role === "ADMIN";

  // Obtener la fecha actual para mostrar
  const today = new Date();
  const formattedDate = formatDate(today, "EEEE, dd 'de' MMMM yyyy");

  // Función para obtener el primer y último día de la semana actual
  const getWeekDates = () => {
    const curr = new Date();
    const first = curr.getDate() - curr.getDay() + 1; // Primer día es lunes
    const last = first + 6; // Último día es domingo

    const firstDay = new Date(curr.setDate(first));
    firstDay.setHours(0, 0, 0, 0);

    const lastDay = new Date(curr.setDate(last));
    lastDay.setHours(23, 59, 59, 999);

    return { firstDay, lastDay };
  };

  // Función para obtener el primer y último día del mes actual
  const getMonthDates = () => {
    const curr = new Date();
    const firstDay = new Date(curr.getFullYear(), curr.getMonth(), 1);
    firstDay.setHours(0, 0, 0, 0);

    const lastDay = new Date(curr.getFullYear(), curr.getMonth() + 1, 0);
    lastDay.setHours(23, 59, 59, 999);

    return { firstDay, lastDay };
  };

  // Cargar datos para dashboard de técnicos
  useEffect(() => {
    if (!isAdmin && session) {
      fetchTechnicianData();
    }
  }, [isAdmin, session]);

  // Cargar datos iniciales para dashboard de administradores
  useEffect(() => {
    if (isAdmin && session && !initialDataLoaded) {
      fetchAdminData();
      fetchUpcomingMaintenances();
      setInitialDataLoaded(true);
    }
  }, [isAdmin, session, initialDataLoaded]);

  // Efecto para manejar cambios en el dateRange
  useEffect(() => {
    if (isAdmin && initialDataLoaded && !isInitialMount.current) {
      setIsLoading(true);
      fetchAdminData();
    }

    if (isInitialMount.current) {
      isInitialMount.current = false;
    }
  }, [dateRange, isAdmin, initialDataLoaded]);

  // Función para manejar cambios en el rango de fechas
  const handleDateRangeChange = (range: { start: Date; end: Date }) => {
    // Solo actualizar el estado si ambas fechas están presentes
    if (range.start && range.end) {
      // Crear un nuevo objeto de rango para asegurar que se actualiza el estado
      const newDateRange = {
        start: new Date(range.start),
        end: new Date(range.end),
      };

      // Actualizar el estado
      setDateRange(newDateRange);
    }
  };

  // Funciones para cargar datos del dashboard de administradores
  const fetchAdminData = async () => {
    setIsLoading(true);
    try {
      await Promise.all([
        fetchSalesData(),
        fetchQuotationStats(),
        fetchTopProducts(),
      ]);
    } catch (error) {
      console.error("Error al cargar datos del dashboard admin:", error);
      addNotification("error", "Error al cargar datos del dashboard");
    } finally {
      setIsLoading(false);
    }
  };

  const refreshAdminData = async () => {
    setIsRefreshing(true);
    try {
      // Resetear los datos para evitar mostrar datos antiguos mientras se cargan los nuevos
      setSalesData([]);
      setQuotationStats(null);
      setTopProducts([]);

      await Promise.all([
        fetchSalesData(),
        fetchQuotationStats(),
        fetchTopProducts(),
        fetchUpcomingMaintenances(),
      ]);
      addNotification("success", "Datos actualizados correctamente");
    } catch (error) {
      console.error("Error al actualizar datos:", error);
      addNotification("error", "Error al actualizar datos");
    } finally {
      setIsRefreshing(false);
    }
  };

  const fetchSalesData = async () => {
    try {
      if (!dateRange.start || !dateRange.end) return;

      const startDate = formatDate(dateRange.start, "yyyy-MM-dd");
      const endDate = formatDate(dateRange.end, "yyyy-MM-dd");

      const data = await getSalesStats("month", startDate, endDate);

      if (data && data.monthlySales && data.monthlySales.length > 0) {
        // Transformar los datos para el gráfico
        const formattedData = data.monthlySales.map((item) => ({
          mes: item.month,
          valor: item.total || 0,
          cantidad: item.count || 0,
        }));

        setSalesData(formattedData);
      } else {
        // Si no hay datos, establecer un array vacío
        setSalesData([]);
      }
    } catch (error) {
      console.error("Error al cargar datos de ventas:", error);
      // Establecer un array vacío para que la UI no se rompa
      setSalesData([]);
    }
  };

  const fetchQuotationStats = async () => {
    try {
      if (!dateRange.start || !dateRange.end) return;

      const startDate = formatDate(dateRange.start, "yyyy-MM-dd");
      const endDate = formatDate(dateRange.end, "yyyy-MM-dd");

      const stats = await getQuotationStats({
        startDate,
        endDate,
      });

      if (stats && stats.summary) {
        setQuotationStats(stats);
      } else {
        // Proporcionar datos vacíos si no se recibe respuesta
        setQuotationStats({
          summary: {
            totalCount: 0,
            previousCount: 0,
            percentChange: 0,
            totalAmount: 0,
            previousAmount: 0,
            amountPercentChange: 0,
            tasksCount: 0,
            previousTasksCount: 0,
            tasksPercentChange: 0,
            approvalRate: 0,
            previousApprovalRate: 0,
            approvalRateChange: 0,
          },
          byStatus: [],
        });
      }
    } catch (error) {
      console.error("Error al cargar estadísticas de cotizaciones:", error);
      // Proporcionar datos vacíos si hay un error
      setQuotationStats({
        summary: {
          totalCount: 0,
          previousCount: 0,
          percentChange: 0,
          totalAmount: 0,
          previousAmount: 0,
          amountPercentChange: 0,
          tasksCount: 0,
          previousTasksCount: 0,
          tasksPercentChange: 0,
          approvalRate: 0,
          previousApprovalRate: 0,
          approvalRateChange: 0,
        },
        byStatus: [],
      });
    }
  };

  const fetchTopProducts = async () => {
    try {
      if (!dateRange.start || !dateRange.end) return;

      const startDate = formatDate(dateRange.start, "yyyy-MM-dd");
      const endDate = formatDate(dateRange.end, "yyyy-MM-dd");

      const data = await getTopProducts(5, startDate, endDate);

      if (data && Array.isArray(data) && data.length > 0) {
        setTopProducts(data);
      } else {
        setTopProducts([]);
      }
    } catch (error) {
      console.error("Error al cargar productos más vendidos:", error);
      setTopProducts([]);
    }
  };

  const fetchUpcomingMaintenances = async () => {
    try {
      const data = await getUpcomingMaintenances(30);

      if (data && Array.isArray(data) && data.length > 0) {
        setUpcomingMaintenances(data.slice(0, 5));
      } else {
        setUpcomingMaintenances([]);
      }
    } catch (error) {
      console.error("Error al cargar mantenimientos próximos:", error);
      setUpcomingMaintenances([]);
    }
  };

  // Función para cargar datos del dashboard de técnicos
  const fetchTechnicianData = async () => {
    setIsLoading(true);
    try {
      // Obtener tareas de hoy
      const todayResponse = await getTasksByDate({
        date: new Date().toISOString().split("T")[0],
        view: "daily",
      });

      // Obtener tareas de la semana
      const weekResponse = await getTasksByDate({
        date: new Date().toISOString().split("T")[0],
        view: "weekly",
      });

      // Obtener tareas del mes
      const monthResponse = await getTasksByDate({
        date: new Date().toISOString().split("T")[0],
        view: "monthly",
      });

      if (todayResponse?.tasks) {
        // Tareas para hoy
        const todayTasksFiltered = todayResponse.tasks.filter(
          (task) => task.state !== "FINALIZADO"
        );
        setTasksToday(todayTasksFiltered.length);

        // Tareas pendientes (próximas para mostrar)
        const pendingTasks = todayResponse.tasks
          .filter((task) => task.state === "PENDIENTE")
          .slice(0, 3);
        setUpcomingTasks(pendingTasks);
      }

      if (weekResponse?.tasks) {
        // Tareas de la semana
        const weeklyTasksFiltered = weekResponse.tasks.filter(
          (task) => task.state !== "FINALIZADO"
        );
        setTasksThisWeek(weeklyTasksFiltered.length);
        setWeeklyTasks(weekResponse.tasks);

        // Tareas vencidas
        const overdue = weekResponse.tasks.filter((task) => {
          const taskDate = new Date(task.startDate);
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          return task.state !== "FINALIZADO" && taskDate < today;
        });
        setOverdueItems(overdue.length);

        // Tareas completadas esta semana
        const completed = weekResponse.tasks.filter(
          (task) => task.state === "FINALIZADO"
        );
        setTasksCompleted(completed.length);
      }

      if (monthResponse?.tasks) {
        // Tareas pendientes del mes actual
        const pendingTasks = monthResponse.tasks.filter(
          (task) => task.state !== "FINALIZADO"
        );
        setPendingMonthTasks(pendingTasks);

        // Tareas completadas del mes actual
        const completedTasks = monthResponse.tasks.filter(
          (task) => task.state === "FINALIZADO"
        );
        setCompletedMonthTasks(completedTasks);
      }
    } catch (error) {
      console.error("Error al cargar tareas:", error);
      addNotification("error", "Error al cargar tareas");
    } finally {
      setIsLoading(false);
    }
  };

  // Componentes de carga
  if (isLoading) {
    return (
      <div className="flex flex-col justify-center items-center h-96">
        <Loader2 className="h-12 w-12 animate-spin text-primary mb-4" />
        <p className="text-lg text-content-subtle">
          Cargando panel de control...
        </p>
      </div>
    );
  }

  // Dashboard para administradores
  if (isAdmin) {
    // Verificar si hay datos para mostrar
    const hasQuotationStats = quotationStats?.summary?.totalCount > 0;
    const hasSalesData = salesData.length > 0;
    const hasTopProducts = topProducts.length > 0;
    const hasMaintenances = upcomingMaintenances.length > 0;

    // Preparar datos para gráficos solo si hay datos
    const quotationByStatusData = hasQuotationStats
      ? quotationStats?.byStatus?.map((item) => ({
          name: getStatusLabel(item.status),
          value: item.count,
          amount: item.amount,
        })) || []
      : [];

    const topProductsData = hasTopProducts
      ? topProducts.map((product) => ({
          name: product.name,
          valor: product.totalSales || 0,
          cantidad: product.count || 0,
        }))
      : [];

    return (
      <div className="space-y-6">
        {/* Cabecera con título y filtros */}
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold text-content-emphasis">
              Dashboard
            </h1>
            <p className="text-sm text-content-subtle">
              {dateRange.start && formatDate(dateRange.start, "dd MMM yyyy")} -{" "}
              {dateRange.end && formatDate(dateRange.end, "dd MMM yyyy")}
            </p>
          </div>

          <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
            <DateRangePicker
              value={dateRange}
              onChange={handleDateRangeChange}
              className="w-full sm:w-auto"
            />
            <Button
              variant="outline"
              size="icon"
              className="hidden sm:flex"
              onClick={refreshAdminData}
              disabled={isRefreshing}
            >
              {isRefreshing ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <RefreshCcw className="h-4 w-4" />
              )}
            </Button>
          </div>
        </div>

        {/* Tarjetas de resumen */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          <StatsCard
            title="Cotizaciones"
            value={quotationStats?.summary?.totalCount?.toString() || "0"}
            change={
              quotationStats?.summary?.percentChange
                ? `${quotationStats.summary.percentChange.toFixed(1)}%`
                : undefined
            }
            trend={quotationStats?.summary?.percentChange >= 0 ? "up" : "down"}
            icon={FileText}
          />
          <StatsCard
            title="Ventas totales"
            value={formatCurrency(quotationStats?.summary?.totalAmount || 0)}
            change={
              quotationStats?.summary?.amountPercentChange
                ? `${quotationStats.summary.amountPercentChange.toFixed(1)}%`
                : undefined
            }
            trend={
              quotationStats?.summary?.amountPercentChange >= 0 ? "up" : "down"
            }
            icon={DollarSign}
          />
          <StatsCard
            title="Tareas asignadas"
            value={quotationStats?.summary?.tasksCount?.toString() || "0"}
            change={
              quotationStats?.summary?.tasksPercentChange
                ? `${quotationStats.summary.tasksPercentChange.toFixed(1)}%`
                : undefined
            }
            trend={
              quotationStats?.summary?.tasksPercentChange >= 0 ? "up" : "down"
            }
            icon={CalendarClock}
          />
          <StatsCard
            title="Tasa de aprobación"
            value={`${(quotationStats?.summary?.approvalRate || 0).toFixed(
              1
            )}%`}
            change={
              quotationStats?.summary?.approvalRateChange
                ? `${quotationStats.summary.approvalRateChange.toFixed(1)}%`
                : undefined
            }
            trend={
              quotationStats?.summary?.approvalRateChange >= 0 ? "up" : "down"
            }
            icon={TrendingUp}
          />
        </div>

        {/* Gráficos principales */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Gráfico de ventas */}
          <Card className="p-6">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold">Resumen de ventas</h3>
            </div>
            <div className="h-80">
              {hasSalesData ? (
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={salesData}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="mes" />
                    <YAxis yAxisId="left" orientation="left" stroke="#b42516" />
                    <YAxis
                      yAxisId="right"
                      orientation="right"
                      stroke="#2563eb"
                    />
                    <Tooltip
                      formatter={(value) =>
                        typeof value === "number"
                          ? value.toLocaleString("es-CL")
                          : value
                      }
                    />
                    <Legend />
                    <Bar
                      yAxisId="left"
                      dataKey="valor"
                      name="Monto ($)"
                      fill="#b42516"
                      barSize={20}
                    />
                    <Bar
                      yAxisId="right"
                      dataKey="cantidad"
                      name="Cantidad"
                      fill="#2563eb"
                      barSize={20}
                    />
                  </BarChart>
                </ResponsiveContainer>
              ) : (
                <div className="flex flex-col items-center justify-center h-full">
                  <BarChart2 className="h-12 w-12 text-content-subtle mb-2 opacity-50" />
                  <p className="text-content-subtle">
                    No hay datos de ventas disponibles
                  </p>
                  <p className="text-content-subtle text-sm mt-1">
                    No existen ventas en el período seleccionado
                  </p>
                </div>
              )}
            </div>
          </Card>

          {/* Gráfico de cotizaciones por estado */}
          <Card className="p-6">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold">Cotizaciones por estado</h3>
            </div>
            <div className="h-80">
              {quotationByStatusData.length > 0 ? (
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Pie
                      data={quotationByStatusData}
                      cx="50%"
                      cy="50%"
                      outerRadius={100}
                      fill="#8884d8"
                      dataKey="value"
                      nameKey="name"
                      label={({ name, percent }) =>
                        `${name}: ${(percent * 100).toFixed(0)}%`
                      }
                    >
                      {quotationByStatusData.map((entry, index) => (
                        <Cell
                          key={`cell-${index}`}
                          fill={COLORS[index % COLORS.length]}
                        />
                      ))}
                    </Pie>
                    <Tooltip
                      formatter={(value, name, props) => [value, name]}
                    />
                    <Legend />
                  </PieChart>
                </ResponsiveContainer>
              ) : (
                <div className="flex flex-col items-center justify-center h-full">
                  <PieChart className="h-12 w-12 text-content-subtle mb-2 opacity-50" />
                  <p className="text-content-subtle">
                    No hay datos de cotizaciones disponibles
                  </p>
                  <p className="text-content-subtle text-sm mt-1">
                    No existen cotizaciones en el período seleccionado
                  </p>
                </div>
              )}
            </div>
          </Card>
        </div>

        {/* Secciones secundarias */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Productos más vendidos */}
          <Card className="overflow-hidden">
            <div className="p-6 border-b">
              <h3 className="text-lg font-semibold flex items-center">
                <PackageIcon className="h-5 w-5 mr-2 text-primary" />
                Productos más vendidos
              </h3>
            </div>
            <div className="p-0">
              {hasTopProducts ? (
                <div className="divide-y">
                  {topProductsData.map((product, index) => (
                    <div
                      key={index}
                      className="p-4 hover:bg-accent/5 flex justify-between items-center"
                    >
                      <div className="flex items-center">
                        <div className="w-8 h-8 rounded-full bg-accent/20 flex items-center justify-center mr-3">
                          <span className="font-semibold text-sm">
                            {index + 1}
                          </span>
                        </div>
                        <div>
                          <h4 className="font-medium">{product.name}</h4>
                          <p className="text-sm text-content-subtle">
                            {product.cantidad} unidades vendidas
                          </p>
                        </div>
                      </div>
                      <span className="font-semibold">
                        {formatCurrency(product.valor)}
                      </span>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
                  <PackageIcon className="h-12 w-12 text-content-subtle mb-4 opacity-50" />
                  <h3 className="text-lg font-medium">
                    Sin datos de productos
                  </h3>
                  <p className="text-content-subtle mt-2">
                    No hay información de ventas de productos en el período
                    seleccionado
                  </p>
                </div>
              )}
            </div>
            <div className="p-4 border-t bg-accent/5">
              <Link href="/dashboard/products">
                <Button variant="outline" className="w-full">
                  Ver todos los productos
                </Button>
              </Link>
            </div>
          </Card>

          {/* Mantenimientos próximos */}
          <Card className="overflow-hidden">
            <div className="p-6 border-b">
              <h3 className="text-lg font-semibold flex items-center">
                <Calendar className="h-5 w-5 mr-2 text-primary" />
                Mantenimientos próximos
              </h3>
            </div>
            <div className="p-0">
              {hasMaintenances ? (
                <div className="divide-y">
                  {upcomingMaintenances.map((maintenance) => (
                    <div key={maintenance.id} className="p-4 hover:bg-accent/5">
                      <div className="flex justify-between items-start">
                        <div>
                          <h4 className="font-medium">
                            {maintenance.client
                              ? maintenance.client.name
                              : "Cliente sin asignar"}
                          </h4>
                          <p className="text-sm text-content-subtle mt-1">
                            Próximo:{" "}
                            {formatDate(
                              new Date(maintenance.nextMaintenanceDate),
                              "dd MMM yyyy"
                            )}
                          </p>
                        </div>
                        <Badge
                          className={getMaintenanceStatusClass(
                            maintenance.nextMaintenanceDate
                          )}
                        >
                          {getMaintenanceStatusLabel(
                            maintenance.nextMaintenanceDate
                          )}
                        </Badge>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
                  <Calendar className="h-12 w-12 text-content-subtle mb-4 opacity-50" />
                  <h3 className="text-lg font-medium">
                    Sin mantenimientos próximos
                  </h3>
                  <p className="text-content-subtle mt-2">
                    No hay mantenimientos programados para los próximos 30 días
                  </p>
                </div>
              )}
            </div>
            <div className="p-4 border-t bg-accent/5">
              <Link href="/dashboard/maintenance">
                <Button variant="outline" className="w-full">
                  Ver todos los mantenimientos
                </Button>
              </Link>
            </div>
          </Card>
        </div>
      </div>
    );
  }

  // Dashboard para trabajadores
  return (
    <div className="space-y-8">
      {/* Cabecera con saludo y fecha */}
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">
          Hola, {session?.user?.name?.split(" ")[0] || "Técnico"}
        </h1>
        <p className="text-content-subtle mt-1">{formattedDate}</p>
      </div>

      {/* Tarjetas de resumen */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card className="p-6 flex flex-col">
          <div className="flex items-center gap-3 mb-2">
            <div className="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center">
              <Clock className="h-5 w-5 text-blue-600" />
            </div>
            <span className="font-medium text-content-subtle">Tareas Hoy</span>
          </div>
          <span className="text-3xl font-bold mt-2">{tasksToday}</span>
          <Link
            href="/dashboard/agenda"
            className="text-primary text-sm mt-auto font-medium flex items-center"
          >
            Ver agenda <ChevronRight className="h-4 w-4 ml-1" />
          </Link>
        </Card>

        <Card className="p-6 flex flex-col">
          <div className="flex items-center gap-3 mb-2">
            <div className="w-10 h-10 rounded-full bg-green-100 flex items-center justify-center">
              <CalendarClock className="h-5 w-5 text-green-600" />
            </div>
            <span className="font-medium text-content-subtle">Esta semana</span>
          </div>
          <span className="text-3xl font-bold mt-2">{tasksThisWeek}</span>
          <span className="text-xs text-content-subtle mt-1">
            {getWeekDates().firstDay.toLocaleDateString()} -{" "}
            {getWeekDates().lastDay.toLocaleDateString()}
          </span>
        </Card>

        <Card className="p-6 flex flex-col">
          <div className="flex items-center gap-3 mb-2">
            <div className="w-10 h-10 rounded-full bg-red-100 flex items-center justify-center">
              <AlertTriangle className="h-5 w-5 text-red-600" />
            </div>
            <span className="font-medium text-content-subtle">Vencidas</span>
          </div>
          <span className="text-3xl font-bold mt-2">{overdueItems}</span>
          <span className="text-xs text-content-subtle mt-1">
            Tareas con fecha pasada
          </span>
        </Card>

        <Card className="p-6 flex flex-col">
          <div className="flex items-center gap-3 mb-2">
            <div className="w-10 h-10 rounded-full bg-purple-100 flex items-center justify-center">
              <CheckCircle className="h-5 w-5 text-purple-600" />
            </div>
            <span className="font-medium text-content-subtle">Completadas</span>
          </div>
          <span className="text-3xl font-bold mt-2">{tasksCompleted}</span>
          <span className="text-xs text-content-subtle mt-1">
            En la semana actual
          </span>
        </Card>
      </div>

      {/* Tareas de la semana actual */}
      <Card className="overflow-hidden">
  <div className="p-6 border-b">
    <h2 className="text-xl font-semibold flex items-center">
      <CalendarClock className="mr-2 h-5 w-5 text-primary" />
      Tareas para esta semana
    </h2>
  </div>
  <div className="p-0">
    {tasksThisWeek > 0 ? (
      <div className="divide-y">
        {/* Vista de escritorio: Grid de 7 columnas */}
        <div className="hidden md:block">
          <div className="grid grid-cols-7 p-2 bg-accent/10 border-b">
            <div className="text-center font-semibold">Lunes</div>
            <div className="text-center font-semibold">Martes</div>
            <div className="text-center font-semibold">Miércoles</div>
            <div className="text-center font-semibold">Jueves</div>
            <div className="text-center font-semibold">Viernes</div>
            <div className="text-center font-semibold">Sábado</div>
            <div className="text-center font-semibold">Domingo</div>
          </div>
          <div className="grid grid-cols-7 gap-1 p-2 min-h-32">
            {Array(7).fill(0).map((_, index) => (
              <div key={index} className="border rounded p-2 min-h-full">
                {weeklyTasks.filter(task => {
                  const taskDate = new Date(task.startDate);
                  const dayOfWeek = taskDate.getDay();
                  const adjustedDayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                  return adjustedDayOfWeek === index;
                }).map(task => (
                  <div key={task.id} className="mb-2 bg-accent/5 p-2 rounded text-sm">
                    <p className="font-medium truncate">{task.title}</p>
                    <p className="text-xs text-content-subtle">
                      {formatDate(new Date(task.startDate), "HH:mm")}
                    </p>
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>

        {/* Vista móvil: Lista simple agrupada por día */}
        <div className="md:hidden">
          {['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'].map((day, idx) => {
            const tasksForDay = weeklyTasks.filter(task => {
              const taskDate = new Date(task.startDate);
              const dayOfWeek = taskDate.getDay();
              const adjustedDayOfWeek = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
              return adjustedDayOfWeek === idx;
            });

            if (tasksForDay.length === 0) return null;

            // Determinar si es hoy para resaltarlo
            const today = new Date().getDay();
            const adjustedToday = today === 0 ? 6 : today - 1;
            const isToday = adjustedToday === idx;

            return (
              <div key={idx} className={`p-3 ${isToday ? 'bg-accent/10' : ''}`}>
                <h4 className={`font-medium text-sm mb-2 ${isToday ? 'text-primary font-semibold' : 'text-content-subtle'}`}>
                  {day} {isToday && <span className="text-xs ml-1 bg-primary text-white px-1.5 py-0.5 rounded-full">Hoy</span>}
                </h4>
                <div className="space-y-2">
                  {tasksForDay.map(task => (
                    <div key={task.id} className="bg-accent/5 p-3 rounded">
                      <p className="font-medium">{task.title}</p>
                      <p className="text-xs text-content-subtle mt-1">
                        {formatDate(new Date(task.startDate), "HH:mm")}
                        {task.client && ` - ${task.client.name}`}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    ) : (
      <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
        <CheckCircle className="h-12 w-12 text-green-500 mb-4" />
        <h3 className="text-lg font-medium">¡Semana sin tareas pendientes!</h3>
        <p className="text-content-subtle mt-2">
          No tienes tareas asignadas para esta semana
        </p>
      </div>
    )}
  </div>
  <div className="p-4 border-t bg-accent/5">
    <Link href="/dashboard/agenda">
      <Button variant="outline" className="w-full">
        Ver agenda completa
      </Button>
    </Link>
  </div>
</Card>

      {/* Secciones de Tareas Pendientes y Trabajos Realizados */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Tareas pendientes del mes */}
        <Card className="overflow-hidden">
          <div className="p-6 border-b">
            <h3 className="text-lg font-semibold flex items-center">
              <Calendar className="h-5 w-5 mr-2 text-primary" />
              Tareas pendientes del mes
            </h3>
          </div>
          <div className="p-0">
            {pendingMonthTasks.length > 0 ? (
              <div className="divide-y max-h-80 overflow-y-auto">
                {pendingMonthTasks.map((task) => (
                  <div key={task.id} className="p-4 hover:bg-accent/5">
                    <div className="flex justify-between items-start">
                      <div>
                        <h4 className="font-medium">{task.title}</h4>
                        <p className="text-sm text-content-subtle mt-1">
                          {formatDate(
                            new Date(task.startDate),
                            "dd MMM - HH:mm"
                          )}
                          {task.client && ` - ${task.client.name}`}
                        </p>
                      </div>
                      <Badge
                        className={
                          new Date(task.startDate) < new Date()
                            ? "bg-red-100 text-red-800"
                            : "bg-blue-100 text-blue-800"
                        }
                      >
                        {new Date(task.startDate) < new Date()
                          ? "Vencida"
                          : "Pendiente"}
                      </Badge>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
                <CheckCircle className="h-12 w-12 text-green-500 mb-4" />
                <h3 className="text-lg font-medium">Sin tareas pendientes</h3>
                <p className="text-content-subtle mt-2">
                  No tienes tareas pendientes para este mes
                </p>
              </div>
            )}
          </div>
          <div className="p-4 border-t bg-accent/5">
            <Link href="/dashboard/agenda?filter=pending">
              <Button variant="outline" className="w-full">
                Ver todas las tareas pendientes
              </Button>
            </Link>
          </div>
        </Card>

        {/* Trabajos realizados en el mes */}
        <Card className="overflow-hidden">
          <div className="p-6 border-b">
            <h3 className="text-lg font-semibold flex items-center">
              <CheckCircle className="h-5 w-5 mr-2 text-primary" />
              Trabajos realizados este mes
            </h3>
          </div>
          <div className="p-0">
            {completedMonthTasks.length > 0 ? (
              <div className="divide-y max-h-80 overflow-y-auto">
                {completedMonthTasks.map((task) => (
                  <div key={task.id} className="p-4 hover:bg-accent/5">
                    <div className="flex justify-between items-start">
                      <div>
                        <h4 className="font-medium">{task.title}</h4>
                        <p className="text-sm text-content-subtle mt-1">
                          Completado el{" "}
                          {formatDate(
                            new Date(task.endDate || task.startDate),
                            "dd MMM - HH:mm"
                          )}
                          {task.client && ` - ${task.client.name}`}
                        </p>
                      </div>
                      <Badge className="bg-green-100 text-green-800">
                        Completado
                      </Badge>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
                <AlertTriangle className="h-12 w-12 text-amber-500 mb-4" />
                <h3 className="text-lg font-medium">
                  Sin trabajos completados
                </h3>
                <p className="text-content-subtle mt-2">
                  No has completado tareas este mes
                </p>
              </div>
            )}
          </div>
          <div className="p-4 border-t bg-accent/5">
            <Link href="/dashboard/agenda?filter=completed">
              <Button variant="outline" className="w-full">
                Ver todos los trabajos completados
              </Button>
            </Link>
          </div>
        </Card>
      </div>
    </div>
  );
}

// Componente Badge
function Badge({
  children,
  className,
}: {
  children: React.ReactNode;
  className?: string;
}) {
  return (
    <span
      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${className}`}
    >
      {children}
    </span>
  );
}

// Función para obtener la clase de estilo para el estado de mantenimiento
function getMaintenanceStatusClass(nextDate: string): string {
  const now = new Date();
  const nextMaintenanceDate = new Date(nextDate);
  const diffTime = nextMaintenanceDate.getTime() - now.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return "bg-red-100 text-red-800"; // Vencido
  if (diffDays <= 7) return "bg-amber-100 text-amber-800"; // Urgente (próximos 7 días)
  if (diffDays <= 30) return "bg-blue-100 text-blue-800"; // Próximo (próximos 30 días)
  return "bg-green-100 text-green-800"; // Programado (más de 30 días)
}

// Función para obtener la etiqueta para el estado de mantenimiento
function getMaintenanceStatusLabel(nextDate: string): string {
  const now = new Date();
  const nextMaintenanceDate = new Date(nextDate);
  const diffTime = nextMaintenanceDate.getTime() - now.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return "Vencido";
  if (diffDays <= 7) return "Urgente";
  if (diffDays <= 30) return "Próximo";
  return "Programado";
}

// Función para traducir los estados de cotización
function getStatusLabel(status: string): string {
  switch (status) {
    case "SENT":
      return "Enviada";
    case "APPROVED":
      return "Aprobada";
    case "REJECTED":
      return "Rechazada";
    default:
      return status;
  }
}


Ruta: app\(dashboard)\dashboard\products\page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Plus, Edit, Trash, Package, DollarSign, Tag } from "lucide-react";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import {
  getProducts,
  createProduct,
  updateProduct,
  deleteProduct,
  Product,
} from "@/services/products";
import { useNotification } from "@/contexts/NotificationContext";
import { formatCurrency, roundUp } from "@/utils/number-format";
import ProductForm from "@/components/products/ProductForm";

export default function ProductsPage() {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [currentProduct, setCurrentProduct] = useState<Product | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState<string>("newest");
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [productToDelete, setProductToDelete] = useState<Product | null>(null);
  const [isDeletingProduct, setIsDeletingProduct] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { addNotification } = useNotification();

  // Estado para guardar el archivo de imagen
  const [selectedImageFile, setSelectedImageFile] = useState<File | null>(null);

  const [formData, setFormData] = useState({
    name: "",
    description: "",
    unitPrice: "",
    markup: "35",
    imageUrl: "",
  });

  const sortOptions = [
    { value: "newest", label: "Más recientes" },
    { value: "oldest", label: "Más antiguos" },
    { value: "name_asc", label: "Nombre A-Z" },
    { value: "name_desc", label: "Nombre Z-A" },
    { value: "price_asc", label: "Precio menor a mayor" },
    { value: "price_desc", label: "Precio mayor a menor" },
  ];

  // Obtener productos del backend al montar el componente
  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const data = await getProducts();
        setProducts(data);
      } catch (err) {
        setError("Error al cargar los productos");
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchProducts();
  }, []);

  // Filtrar productos y ordenarlos según el valor de sortBy
  const filteredProducts = products
    .filter((product) =>
      (product.name || "").toLowerCase().includes(searchTerm.toLowerCase())
    )
    .sort((a, b) => {
      switch (sortBy) {
        case "newest":
          return (
            new Date(b.createdAt || "").getTime() -
            new Date(a.createdAt || "").getTime()
          );
        case "oldest":
          return (
            new Date(a.createdAt || "").getTime() -
            new Date(b.createdAt || "").getTime()
          );
        case "name_asc":
          return a.name.localeCompare(b.name);
        case "name_desc":
          return b.name.localeCompare(a.name);
        case "price_asc":
          return a.price - b.price;
        case "price_desc":
          return b.price - a.price;
        default:
          return 0;
      }
    });

  const handleAddProduct = () => {
    setIsEditing(true);
    setCurrentProduct(null);
    setFormData({
      name: "",
      description: "",
      unitPrice: "",
      markup: "35",
      imageUrl: "",
    });
    setSelectedImageFile(null);
  };

  const handleEditProduct = (product: Product) => {
    setIsEditing(true);
    setCurrentProduct(product);
    setFormData({
      name: product.name,
      description: product.description || "",
      unitPrice: roundUp(product.unitPrice).toString(),
      markup: product.markup.toString(),
      imageUrl: product.imageUrl || "",
    });
    setSelectedImageFile(null);
  };

  const openDeleteConfirm = (product: Product) => {
    setProductToDelete(product);
    setIsDeleteConfirmOpen(true);
  };

  const handleDeleteProduct = async () => {
    if (!productToDelete) return;

    try {
      setIsDeletingProduct(true);
      await deleteProduct(productToDelete.id?.toString() || "");
      setProducts(
        products.filter((product) => product.id !== productToDelete.id)
      );
      setError(null);
      addNotification("success", "Producto eliminado correctamente");
    } catch (err) {
      setError("Error al eliminar el producto");
      addNotification("error", "Error al eliminar el producto");
      console.error(err);
    } finally {
      setIsDeletingProduct(false);
      setProductToDelete(null);
      setIsDeleteConfirmOpen(false);
    }
  };

  const handleSaveProduct = async () => {
    // Validación básica
    if (!formData.name || !formData.unitPrice) {
      setError("El nombre y precio unitario son obligatorios");
      return;
    }

    try {
      // Convertir y validar valores numéricos
      const unitPrice = roundUp(parseFloat(formData.unitPrice));
      const markup = parseFloat(formData.markup);

      if (isNaN(unitPrice) || unitPrice <= 0) {
        setError("El precio unitario debe ser un número mayor que cero");
        return;
      }

      if (isNaN(markup) || markup < 0) {
        setError("El porcentaje de ganancia debe ser un número no negativo");
        return;
      }

      // Calcular el precio final con el markup
      const markupAmount = Math.ceil((unitPrice * markup) / 100);
      const finalPrice = unitPrice + markupAmount;

      // Crear un FormData para enviar los datos y la imagen
      const productFormData = new FormData();
      productFormData.append("name", formData.name);
      productFormData.append("description", formData.description || "");
      productFormData.append("unitPrice", unitPrice.toString());
      productFormData.append("markup", markup.toString());
      productFormData.append("price", finalPrice.toString());

      // Manejar la imagen
      if (selectedImageFile) {
        // Si hay un archivo seleccionado, añadirlo directamente
        productFormData.append("image", selectedImageFile);
      } else if (
        formData.imageUrl &&
        formData.imageUrl.startsWith("data:image")
      ) {
        // Si hay una imagen en formato Base64, convertirla a Blob y File
        const blob = await fetch(formData.imageUrl).then((r) => r.blob());
        const imageFile = new File([blob], "product-image.png", {
          type: "image/png",
        });
        productFormData.append("image", imageFile);
      } else if (formData.imageUrl && currentProduct) {
        // Si hay una URL de imagen existente y estamos editando, mantenerla
        productFormData.append("imageUrl", formData.imageUrl);
      }

      if (currentProduct) {
        // Actualizar producto existente
        const response = await updateProduct(
          currentProduct.id?.toString() || "",
          productFormData,
          undefined // Ya no pasamos el archivo por separado
        );

        const updatedProduct = response.product;
        setProducts(
          products.map((p) => (p.id === currentProduct.id ? updatedProduct : p))
        );
        addNotification("success", "Producto actualizado correctamente");
      } else {
        // Crear nuevo producto usando FormData
        const response = await createProduct(productFormData);
        const newProduct = response.product;
        setProducts([...products, newProduct]);
        addNotification("success", "Producto creado correctamente");
      }

      // Limpiar estados y cerrar el formulario
      setIsEditing(false);
      setCurrentProduct(null);
      setSelectedImageFile(null);
      setError(null);
    } catch (err) {
      setError("Error al guardar el producto");
      addNotification("error", "Error al guardar el producto");
      console.error(err);
    }
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];
    setSelectedImageFile(file);

    try {
      setIsUploading(true);

      // Mostrar vista previa de la imagen inmediatamente
      const reader = new FileReader();
      reader.onload = (event) => {
        if (event.target && event.target.result) {
          setFormData({
            ...formData,
            imageUrl: event.target.result.toString(),
          });
        }
      };
      reader.readAsDataURL(file);

      addNotification("success", "Imagen seleccionada correctamente");
    } catch (error) {
      console.error("Error al previsualizar la imagen:", error);
      addNotification("error", "Error al previsualizar la imagen");
    } finally {
      setIsUploading(false);
    }
  };

  // Columnas para el DataTable
  const columns: ColumnDef<Product>[] = [
    {
      id: "product",
      header: "Producto",
      cell: ({ row }) => (
        <div className="flex items-center gap-3">
          {row.original.imageUrl ? (
            <img
              src={row.original.imageUrl}
              alt={row.original.name}
              className="w-10 h-10 rounded object-cover"
            />
          ) : (
            <div className="w-10 h-10 rounded bg-primary/10 flex items-center justify-center">
              <Package className="h-5 w-5 text-primary" />
            </div>
          )}
          <div>
            <p className="font-medium">{row.original.name}</p>
            {row.original.description && (
              <p className="text-sm text-content-subtle">
                {row.original.description}
              </p>
            )}
          </div>
        </div>
      ),
    },
    {
      id: "unitPrice",
      header: "Precio Unitario",
      cell: ({ row }) => {
        const unitPrice = roundUp(row.original.unitPrice || 0);
        return (
          <div className="flex items-center gap-2">
            <Tag className="h-4 w-4 text-content-subtle" />
            <span className="font-medium">{formatCurrency(unitPrice)}</span>
          </div>
        );
      },
    },
    {
      id: "markup",
      header: "Ganancia",
      cell: ({ row }) => {
        const unitPrice = roundUp(row.original.unitPrice || 0);
        const markup = row.original.markup || 0;
        // Calcular el monto exacto de ganancia
        const markupAmount = Math.ceil((unitPrice * markup) / 100);

        return (
          <div className="flex items-center gap-2">
            <DollarSign className="h-4 w-4 text-content-subtle" />
            <span className="font-medium">{formatCurrency(markupAmount)}</span>
            <span className="text-xs text-content-subtle">({markup}%)</span>
          </div>
        );
      },
    },
    {
      id: "price",
      header: "Precio Final",
      cell: ({ row }) => {
        const price = roundUp(row.original.price || 0);
        return (
          <div className="flex items-center gap-2">
            <DollarSign className="h-4 w-4 text-content-subtle" />
            <span className="font-medium">{formatCurrency(price)}</span>
          </div>
        );
      },
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => handleEditProduct(row.original)}
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => openDeleteConfirm(row.original)}
          >
            <Trash className="h-4 w-4" />
          </Button>
        </div>
      ),
    },
  ];

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">Productos</h1>
        <p className="text-content-subtle mt-2">
          Gestiona tu catálogo de productos
        </p>
      </div>

      <Card className="p-6">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          <h2 className="text-xl font-semibold">Lista de Productos</h2>
          <div className="flex flex-col md:flex-row items-stretch md:items-center gap-4 w-full md:w-auto">
            <Input
              placeholder="Buscar por nombre..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full md:w-auto md:max-w-xs"
            />
            <Select value={sortBy} onValueChange={setSortBy}>
              <SelectTrigger className="w-full md:w-[180px]">
                <SelectValue placeholder="Ordenar por" />
              </SelectTrigger>
              <SelectContent className="max-h-[300px] overflow-y-auto">
                {sortOptions.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button onClick={handleAddProduct} className="w-full md:w-auto">
              <Plus className="mr-2 h-4 w-4" />
              Agregar Producto
            </Button>
          </div>
        </div>

        {isLoading ? (
          <div className="text-center h-96 flex items-center justify-center">
            <p>Cargando productos...</p>
          </div>
        ) : (
          <DataTable columns={columns} data={filteredProducts} />
        )}
      </Card>

      {error && <div className="text-center text-red-500">{error}</div>}

      {isEditing && (
        <ProductForm
          currentProduct={currentProduct}
          formData={formData}
          setFormData={setFormData}
          onSave={handleSaveProduct}
          onCancel={() => {
            setIsEditing(false);
            setSelectedImageFile(null);
          }}
          onUploadImage={handleImageUpload}
          fileInputRef={fileInputRef}
          isUploading={isUploading}
        />
      )}

      <ConfirmDialog
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Eliminar Producto"
        description={`¿Estás seguro que deseas eliminar el producto "${productToDelete?.name}"? Esta acción no se puede deshacer.`}
        onConfirm={handleDeleteProduct}
        confirmLabel="Eliminar"
        isLoading={isDeletingProduct}
      />

      {/* Input oculto para subir archivos */}
      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        accept="image/*"
        onChange={handleImageUpload}
      />
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\profile\page.tsx
"use client";
import { useState, useEffect, useRef } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel, FormDescription } from "@/components/ui/form";
import { FormTextarea } from "@/components/ui/form-textarea";
import { useNotification } from "@/contexts/NotificationContext";
import { useSession } from "next-auth/react";
import {
  User,
  Mail,
  Phone,
  MapPin,
  Building,
  Globe,
  Save,
  Upload,
  Lock,
  Loader2,
  FileText,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  getProfile,
  updateProfile,
  updatePassword,
  ProfileUpdateData,
  PasswordUpdateData,
} from "@/services/profile";

export default function ProfilePage() {
  const { data: session, update: updateSession } = useSession();
  const [isUpdating, setIsUpdating] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [passwordModalOpen, setPasswordModalOpen] = useState(false);
  const [passwordData, setPasswordData] = useState<PasswordUpdateData>({
    currentPassword: "",
    newPassword: "",
    confirmPassword: "",
  });
  const [passwordError, setPasswordError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { addNotification } = useNotification();

  const [profile, setProfile] = useState({
    name: "",
    email: "",
    phone: "",
    role: "",
  });

  useEffect(() => {
    const loadProfile = async () => {
      try {
        setIsLoading(true);
        const profileData = await getProfile();

        setProfile({
          name: profileData.name || "",
          email: profileData.email || "",
          phone: profileData.phone || "",
          role: profileData.role || "WORKER",
        });
      } catch (error) {
        console.error("Error al cargar el perfil:", error);
        addNotification("error", "No se pudo cargar la información del perfil");
      } finally {
        setIsLoading(false);
      }
    };

    loadProfile();
  }, [addNotification]);

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsUpdating(true);

    try {
      const updateData: ProfileUpdateData = {
        name: profile.name,
        phone: profile.phone,
      };

      const result = await updateProfile(updateData);

      // Actualizar la sesión con el nuevo nombre si cambió
      if (
        result.user &&
        session &&
        session.user &&
        result.user.name !== session.user.name
      ) {
        await updateSession({
          ...session,
          user: {
            ...session.user,
            name: result.user.name,
          },
        });
      }

      addNotification("success", "Perfil actualizado correctamente");
    } catch (error) {
      console.error("Error al actualizar el perfil:", error);
      addNotification("error", "Error al actualizar el perfil");
    } finally {
      setIsUpdating(false);
    }
  }

  async function handlePasswordChange() {
    setPasswordError(null);

    // Validación simple
    if (
      !passwordData.currentPassword ||
      !passwordData.newPassword ||
      !passwordData.confirmPassword
    ) {
      setPasswordError("Todos los campos son obligatorios");
      return;
    }

    if (passwordData.newPassword !== passwordData.confirmPassword) {
      setPasswordError("Las nuevas contraseñas no coinciden");
      return;
    }

    if (passwordData.newPassword.length < 8) {
      setPasswordError("La nueva contraseña debe tener al menos 8 caracteres");
      return;
    }

    try {
      await updatePassword(passwordData);
      setPasswordModalOpen(false);
      setPasswordData({
        currentPassword: "",
        newPassword: "",
        confirmPassword: "",
      });
      addNotification("success", "Contraseña actualizada correctamente");
    } catch (error: any) {
      console.error("Error al actualizar la contraseña:", error);
      setPasswordError(error.message || "Error al actualizar la contraseña");
    }
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">Mi Perfil</h1>
        <p className="text-content-subtle mt-2">
          Administra tu información personal y preferencias
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Información Personal */}
        <Card className="p-6">
          <h2 className="text-xl font-semibold mb-6">Información Personal</h2>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <FormField>
              <FormLabel>
                <div className="flex items-center gap-2">
                  <User className="h-4 w-4" />
                  Nombre completo
                </div>
              </FormLabel>
              <Input
                value={profile.name}
                onChange={(e) =>
                  setProfile({ ...profile, name: e.target.value })
                }
              />
            </FormField>

            <FormField>
              <FormLabel>
                <div className="flex items-center gap-2">
                  <Mail className="h-4 w-4" />
                  Correo electrónico
                </div>
              </FormLabel>
              <Input type="email" value={profile.email} disabled />
              <FormDescription>
                El correo electrónico no se puede cambiar
              </FormDescription>
            </FormField>

            <FormField>
              <FormLabel>
                <div className="flex items-center gap-2">
                  <Phone className="h-4 w-4" />
                  Teléfono
                </div>
              </FormLabel>
              <Input
                type="tel"
                value={profile.phone}
                onChange={(e) =>
                  setProfile({ ...profile, phone: e.target.value })
                }
              />
            </FormField>
          </div>
        </Card>

        {/* Información Profesional */}

        <div className="flex justify-between">
          <Button
            type="button"
            variant="outline"
            onClick={() => setPasswordModalOpen(true)}
            className="flex items-center gap-2"
          >
            <Lock className="h-4 w-4" />
            Cambiar contraseña
          </Button>

          <Button type="submit" disabled={isUpdating} size="lg">
            {isUpdating ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Guardando...
              </>
            ) : (
              <>
                <Save className="h-4 w-4 mr-2" />
                Guardar cambios
              </>
            )}
          </Button>
        </div>
      </form>

      {/* Modal de cambio de contraseña */}
      <Dialog open={passwordModalOpen} onOpenChange={setPasswordModalOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Cambiar contraseña</DialogTitle>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <FormField>
              <FormLabel>Contraseña actual</FormLabel>
              <Input
                type="password"
                value={passwordData.currentPassword}
                onChange={(e) =>
                  setPasswordData({
                    ...passwordData,
                    currentPassword: e.target.value,
                  })
                }
              />
            </FormField>
            <FormField>
              <FormLabel>Nueva contraseña</FormLabel>
              <Input
                type="password"
                value={passwordData.newPassword}
                onChange={(e) =>
                  setPasswordData({
                    ...passwordData,
                    newPassword: e.target.value,
                  })
                }
              />
            </FormField>
            <FormField>
              <FormLabel>Confirmar nueva contraseña</FormLabel>
              <Input
                type="password"
                value={passwordData.confirmPassword}
                onChange={(e) =>
                  setPasswordData({
                    ...passwordData,
                    confirmPassword: e.target.value,
                  })
                }
              />
            </FormField>
            {passwordError && (
              <div className="text-error text-sm">{passwordError}</div>
            )}
          </div>
          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={() => setPasswordModalOpen(false)}
            >
              Cancelar
            </Button>
            <Button type="button" onClick={handlePasswordChange}>
              Cambiar contraseña
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\quotes\page.tsx
// web\app\(dashboard)\dashboard\quotes\page.tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Plus,
  Search,
  Calendar,
  Clock,
  CheckCircle,
  XCircle,
  Loader2,
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  SelectGroup,
  SelectLabel,
} from "@/components/ui/select";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import {
  QuotationsParams,
  type Quotation,
  deleteQuotation,
  getQuotationsData,
  updateQuotationStatus,
} from "@/services/quotations";
import { debounce } from "lodash";
import QuotationsTable from "@/components/quotes/QuotationsTable";
import QuotationForm from "@/components/quotes/QuotationForm";

export default function QuotesPage() {
  const [quotations, setQuotations] = useState<Quotation[]>([]);
  const [pagination, setPagination] = useState<{
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  } | null>(null);

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [currentQuotation, setCurrentQuotation] = useState<Quotation | null>(
    null
  );
  const [searchTerm, setSearchTerm] = useState("");
  const [filters, setFilters] = useState<QuotationsParams>({
    page: 1,
    limit: 10,
    search: "",
    clientId: undefined,
    status: undefined,
  });
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [quotationToDelete, setQuotationToDelete] = useState<Quotation | null>(
    null
  );
  const [isDeletingQuotation, setIsDeletingQuotation] = useState(false);
  const [selectedClientFilter, setSelectedClientFilter] =
    useState<string>("all");
  const [selectedStatusFilter, setSelectedStatusFilter] =
    useState<string>("all");

  // Estados disponibles para las cotizaciones
  const QUOTATION_STATUSES = [
    {
      value: "SENT",
      label: "Enviada",
      icon: <Calendar className="h-4 w-4 mr-2" />,
    },
    {
      value: "APPROVED",
      label: "Aprobada",
      icon: <CheckCircle className="h-4 w-4 mr-2" />,
    },
    {
      value: "REJECTED",
      label: "Rechazada",
      icon: <XCircle className="h-4 w-4 mr-2" />,
    },
  ];

  // Extraer clientes únicos de las cotizaciones para el filtro
  const clientsForFilter = useMemo(() => {
    const uniqueClients = new Map();

    quotations.forEach((quotation) => {
      if (quotation.client && quotation.client.id) {
        uniqueClients.set(quotation.client.id, {
          id: quotation.client.id,
          name: quotation.client.name,
        });
      }
    });

    return Array.from(uniqueClients.values());
  }, [quotations]);

  // Cargar datos con los filtros aplicados
  const fetchQuotations = async (params: QuotationsParams = {}) => {
    try {
      setIsLoading(true);
      const data = await getQuotationsData(params);
      setQuotations(data.quotations);
      setPagination(data.pagination);
      setError(null);
    } catch (err) {
      console.error("Error fetching quotations:", err);
      setError(
        "Error al cargar las cotizaciones. Por favor, intenta de nuevo."
      );
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    setFilters({
      page: 1,
      limit: 10,
      search: "",
      clientId: undefined,
      status: undefined,
    });
  }, []);

  useEffect(() => {
    if (Object.keys(filters).length === 0) return;

    fetchQuotations(filters);
  }, [filters]);

  // Implementar búsqueda con debounce
  const debouncedSearch = debounce((value: string) => {
    setFilters((prev) => ({
      ...prev,
      search: value,
      page: 1, // Resetear página al buscar
    }));
  }, 500);

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
    debouncedSearch(e.target.value);
  };

  const handleClientFilterChange = (value: string) => {
    setSelectedClientFilter(value);
    setFilters((prev) => ({
      ...prev,
      clientId: value && value !== "all" ? parseInt(value) : undefined,
      page: 1, // Resetear página al cambiar filtro
    }));
  };

  const handleStatusFilterChange = (value: string) => {
    setSelectedStatusFilter(value);
    setFilters((prev) => ({
      ...prev,
      status: value && value !== "all" ? value : undefined,
      page: 1, // Resetear página al cambiar filtro
    }));
  };

  const handlePageChange = (page: number) => {
    setFilters((prev) => ({
      ...prev,
      page,
    }));
  };

  const handleAddQuotation = () => {
    setIsEditing(true);
    setCurrentQuotation(null);
  };

  const handleEditQuotation = (quotation: Quotation) => {
    setIsEditing(true);
    setCurrentQuotation(quotation);
  };

  const openDeleteConfirm = (quotation: Quotation) => {
    setQuotationToDelete(quotation);
    setIsDeleteConfirmOpen(true);
  };

  const handleDeleteQuotation = async () => {
    if (!quotationToDelete || !quotationToDelete.id) return;

    try {
      setIsDeletingQuotation(true);
      await deleteQuotation(quotationToDelete.id);

      // Recargar los datos para reflejar los cambios
      fetchQuotations(filters);

      setError(null);
    } catch (err) {
      setError("Error al eliminar la cotización");
      console.error(err);
    } finally {
      setIsDeletingQuotation(false);
      setIsDeleteConfirmOpen(false);
      setQuotationToDelete(null);
    }
  };

  const handleSaveQuotation = async () => {
    // Recargar para reflejar los cambios
    fetchQuotations(filters);
    setIsEditing(false);
    setCurrentQuotation(null);
  };

  const handleStatusChange = async (quotationId: string, newStatus: string) => {
    try {
      await updateQuotationStatus(quotationId, newStatus);
      // Recargar datos para reflejar el cambio
      fetchQuotations(filters);
    } catch (err) {
      setError("Error al actualizar el estado de la cotización");
      console.error(err);
    }
  };

  // Componente de carga (loading)
  if (isLoading) {
    return (
      <div className="space-y-8">
        <div>
          <h1 className="text-3xl font-bold text-content-emphasis">
            Cotizaciones
          </h1>
          <p className="text-content-subtle mt-2">
            Gestiona tus cotizaciones para clientes
          </p>
        </div>

        <div className="h-[500px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Cargando cotizaciones...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">
          Cotizaciones
        </h1>
        <p className="text-content-subtle mt-2">
          Gestiona tus cotizaciones para clientes
        </p>
      </div>

      <Card className="p-6">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          <h2 className="text-xl font-semibold">Lista de Cotizaciones</h2>

          <div className="flex flex-col md:flex-row items-stretch md:items-center gap-4 w-full md:w-auto">
            <div className="flex flex-col md:flex-row items-center gap-2 w-full md:w-auto">
              <div className="relative flex-1 w-full md:w-auto">
                <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                <Input
                  placeholder="Buscar por título o cliente..."
                  value={searchTerm}
                  onChange={handleSearchChange}
                  className="pl-8 w-full"
                />
              </div>

              {clientsForFilter.length > 0 && (
                <Select
                  value={selectedClientFilter}
                  onValueChange={handleClientFilterChange}
                >
                  <SelectTrigger className="w-full md:w-[180px]">
                    <SelectValue placeholder="Filtrar por cliente" />
                  </SelectTrigger>
                  <SelectContent className="max-h-[300px] overflow-y-auto">
                    <SelectItem value="all">Todos los clientes</SelectItem>

                    {/* Etiqueta con cantidad de clientes */}
                    <div className="px-2 py-1 text-xs text-gray-500 border-b border-gray-100">
                      Clientes ({clientsForFilter.length})
                    </div>

                    {/* Lista de clientes sin contenedores anidados adicionales */}
                    {clientsForFilter.map((client) => (
                      <SelectItem key={client.id} value={client.id.toString()}>
                        {client.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}

              <Select
                value={selectedStatusFilter}
                onValueChange={handleStatusFilterChange}
              >
                <SelectTrigger className="w-full md:w-[180px]">
                  <SelectValue placeholder="Filtrar por estado" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Todos los estados</SelectItem>
                  {QUOTATION_STATUSES.map((status) => (
                    <SelectItem key={status.value} value={status.value}>
                      <div className="flex items-center">
                        {status.icon}
                        {status.label}
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <Button onClick={handleAddQuotation} className="w-full md:w-auto">
              <Plus className="mr-2 h-4 w-4" />
              Nueva Cotización
            </Button>
          </div>
        </div>

        <QuotationsTable
          quotations={quotations}
          pagination={pagination}
          isLoading={isLoading}
          filters={filters}
          onEdit={handleEditQuotation}
          onDelete={openDeleteConfirm}
          onPageChange={handlePageChange}
          onStatusChange={handleStatusChange}
          searchTerm={searchTerm}
          statusOptions={QUOTATION_STATUSES}
        />
      </Card>

      {error && <div className="text-center text-red-500">{error}</div>}

      {isEditing && (
        <QuotationForm
          quotation={currentQuotation}
          onSave={handleSaveQuotation}
          onCancel={() => {
            setIsEditing(false);
            setCurrentQuotation(null);
          }}
          statusOptions={QUOTATION_STATUSES}
        />
      )}

      <ConfirmDialog
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Eliminar Cotización"
        description={`¿Estás seguro que deseas eliminar la cotización "${quotationToDelete?.title}"? Esta acción no se puede deshacer.`}
        onConfirm={handleDeleteQuotation}
        confirmLabel="Eliminar"
        isLoading={isDeletingQuotation}
      />
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\reports\page.tsx
"use client";

import { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  BarChart3,
  PieChart,
  FileSpreadsheet,
  Download,
  Calendar,
  Users,
  Filter,
  Search,
  RefreshCcw,
  FileText,
  Loader2,
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  downloadReportExcel,
  downloadReportPDF,
  generateCustomReport,
  ReportFilter,
} from "@/services/reports";
import { getClients } from "@/services/clients";
import { Client } from "@/services/clients";
import { useNotification } from "@/contexts/NotificationContext";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  BarChart,
  Bar,
  PieChart as RechartsPieChart,
  Pie,
  Cell,
} from "recharts";

interface ReportData {
  summary: {
    totalQuotations: number;
    totalApproved: number;
    totalRejected: number;
    totalPending: number;
    totalAmount: number;
    averageAmount: number;
  };
  quotationsByStatus: {
    status: string;
    count: number;
    amount: number;
  }[];
  quotationsByMonth: {
    month: string;
    count: number;
    amount: number;
  }[];
  quotationsByClient: {
    clientId: number;
    clientName: string;
    count: number;
    amount: number;
  }[];
  quotationItems: {
    productId: number;
    productName: string;
    count: number;
    amount: number;
  }[];
}

const COLORS = [
  "#0088FE",
  "#00C49F",
  "#FFBB28",
  "#FF8042",
  "#8884d8",
  "#82ca9d",
];

export default function ReportsPage() {
  const [startDate, setStartDate] = useState(
    new Date(new Date().setMonth(new Date().getMonth() - 6))
      .toISOString()
      .split("T")[0]
  );
  const [endDate, setEndDate] = useState(
    new Date().toISOString().split("T")[0]
  );
  const [clientId, setClientId] = useState<string>("");
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isExporting, setIsExporting] = useState<string | null>(null);
  const [reportData, setReportData] = useState<ReportData | null>(null);
  const [activeChart, setActiveChart] = useState<string>("monthly");
  const { addNotification } = useNotification();

  // Cargar clientes al iniciar
  useEffect(() => {
    const fetchClients = async () => {
      try {
        const clientsData = await getClients();
        setClients(clientsData);
      } catch (error) {
        console.error("Error loading clients:", error);
        addNotification("error", "Error al cargar los clientes");
      } finally {
        setIsLoading(false);
      }
    };

    fetchClients();
  }, []);

  // Cargar reporte inicial
  useEffect(() => {
    generateReport();
  }, []);

  const generateReport = async () => {
    if (!startDate || !endDate) {
      addNotification("error", "Debes seleccionar un rango de fechas válido");
      return;
    }

    if (new Date(startDate) > new Date(endDate)) {
      addNotification(
        "error",
        "La fecha de inicio debe ser anterior a la fecha final"
      );
      return;
    }

    const filter: ReportFilter = {
      startDate,
      endDate,
    };

    if (clientId) {
      filter.clientId = clientId;
    }

    try {
      setIsGenerating(true);
      const data = await generateCustomReport(filter);
      setReportData(data as unknown as ReportData);
      addNotification("success", "Reporte generado correctamente");
    } catch (error) {
      console.error("Error generating report:", error);
      addNotification("error", "Error al generar el reporte");
    } finally {
      setIsGenerating(false);
    }
  };

  const handleExportPDF = async () => {
    if (!startDate || !endDate) {
      addNotification("error", "Debes seleccionar un rango de fechas válido");
      return;
    }

    const filter: ReportFilter = {
      startDate,
      endDate,
    };

    if (clientId) {
      filter.clientId = clientId;
    }

    try {
      setIsExporting("pdf");
      const blob = await downloadReportPDF(filter);

      // Crear un enlace para descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `reporte-${startDate}-${endDate}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      addNotification("success", "Reporte descargado correctamente");
    } catch (error) {
      console.error("Error exporting PDF:", error);
      addNotification("error", "Error al exportar el reporte a PDF");
    } finally {
      setIsExporting(null);
    }
  };

  const handleExportExcel = async () => {
    if (!startDate || !endDate) {
      addNotification("error", "Debes seleccionar un rango de fechas válido");
      return;
    }

    const filter: ReportFilter = {
      startDate,
      endDate,
    };

    if (clientId) {
      filter.clientId = clientId;
    }

    try {
      setIsExporting("excel");
      const blob = await downloadReportExcel(filter);

      // Crear un enlace para descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `reporte-${startDate}-${endDate}.xlsx`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      addNotification("success", "Reporte descargado correctamente");
    } catch (error) {
      console.error("Error exporting Excel:", error);
      addNotification("error", "Error al exportar el reporte a Excel");
    } finally {
      setIsExporting(null);
    }
  };

  const renderMonthlyChart = () => {
    if (
      !reportData ||
      !reportData.quotationsByMonth ||
      reportData.quotationsByMonth.length === 0
    ) {
      return (
        <div className="flex items-center justify-center h-60">
          <p className="text-content-subtle">
            No hay datos disponibles para el período seleccionado
          </p>
        </div>
      );
    }

    return (
      <ResponsiveContainer width="100%" height={350}>
        <BarChart data={reportData.quotationsByMonth}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="month" />
          <YAxis yAxisId="left" orientation="left" stroke="#8884d8" />
          <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" />
          <Tooltip />
          <Legend />
          <Bar
            yAxisId="left"
            dataKey="count"
            name="Número de cotizaciones"
            fill="#8884d8"
          />
          <Bar
            yAxisId="right"
            dataKey="amount"
            name="Monto total ($)"
            fill="#82ca9d"
          />
        </BarChart>
      </ResponsiveContainer>
    );
  };

  const renderStatusChart = () => {
    if (
      !reportData ||
      !reportData.quotationsByStatus ||
      reportData.quotationsByStatus.length === 0
    ) {
      return (
        <div className="flex items-center justify-center h-60">
          <p className="text-content-subtle">
            No hay datos disponibles para el período seleccionado
          </p>
        </div>
      );
    }

    // Mapear nombres de estado para mostrar
    const data = reportData.quotationsByStatus.map((item) => ({
      ...item,
      statusName: getStatusName(item.status),
    }));

    return (
      <ResponsiveContainer width="100%" height={350}>
        <RechartsPieChart>
          <Pie
            data={data}
            dataKey="count"
            nameKey="statusName"
            cx="50%"
            cy="50%"
            outerRadius={100}
            fill="#8884d8"
            label={(entry) => `${entry.statusName}: ${entry.count}`}
          >
            {data.map((entry, index) => (
              <Cell
                key={`cell-${index}`}
                fill={COLORS[index % COLORS.length]}
              />
            ))}
          </Pie>
          <Tooltip formatter={(value, name) => [`${value}`, name]} />
          <Legend />
        </RechartsPieChart>
      </ResponsiveContainer>
    );
  };

  const renderClientChart = () => {
    if (
      !reportData ||
      !reportData.quotationsByClient ||
      reportData.quotationsByClient.length === 0
    ) {
      return (
        <div className="flex items-center justify-center h-60">
          <p className="text-content-subtle">
            No hay datos disponibles para el período seleccionado
          </p>
        </div>
      );
    }

    // Limitar a los top 5 clientes por monto
    const topClients = [...reportData.quotationsByClient]
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 5);

    return (
      <ResponsiveContainer width="100%" height={350}>
        <BarChart data={topClients} layout="vertical">
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis type="number" />
          <YAxis type="category" dataKey="clientName" width={150} />
          <Tooltip />
          <Legend />
          <Bar dataKey="amount" name="Monto total ($)" fill="#b42516" />
          <Bar dataKey="count" name="Número de cotizaciones" fill="#8884d8" />
        </BarChart>
      </ResponsiveContainer>
    );
  };

  const renderProductChart = () => {
    if (
      !reportData ||
      !reportData.quotationItems ||
      reportData.quotationItems.length === 0
    ) {
      return (
        <div className="flex items-center justify-center h-60">
          <p className="text-content-subtle">
            No hay datos disponibles para el período seleccionado
          </p>
        </div>
      );
    }

    // Limitar a los top 5 productos por monto
    const topProducts = [...reportData.quotationItems]
      .sort((a, b) => b.amount - a.amount)
      .slice(0, 5);

    return (
      <ResponsiveContainer width="100%" height={350}>
        <BarChart data={topProducts}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="productName" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Bar dataKey="amount" name="Monto total ($)" fill="#82ca9d" />
          <Bar dataKey="count" name="Cantidad vendida" fill="#8884d8" />
        </BarChart>
      </ResponsiveContainer>
    );
  };

  // Función auxiliar para mapear estados a nombres legibles
  const getStatusName = (status: string) => {
    switch (status) {
      case "SENT":
        return "Enviada";
      case "APPROVED":
        return "Aprobada";
      case "REJECTED":
        return "Rechazada";
      default:
        return status;
    }
  };

  // Mostrar pantalla de carga mientras se cargan los datos iniciales
  if (isLoading) {
    return (
      <div className="space-y-8">
        <div>
          <h1 className="text-3xl font-bold text-content-emphasis">Reportes</h1>
          <p className="text-content-subtle mt-2">
            Analiza el rendimiento de tus cotizaciones y ventas
          </p>
        </div>

        <div className="h-[500px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Cargando datos...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">Reportes</h1>
        <p className="text-content-subtle mt-2">
          Analiza el rendimiento de tus cotizaciones y ventas
        </p>
      </div>

      {/* Filtros */}
      <Card className="p-6">
        <div className="flex flex-col md:flex-row gap-4 items-end">
          <div className="space-y-2 w-full md:w-auto">
            <label className="text-sm font-medium">Fecha inicio</label>
            <Input
              type="date"
              value={startDate}
              onChange={(e) => setStartDate(e.target.value)}
            />
          </div>
          <div className="space-y-2 w-full md:w-auto">
            <label className="text-sm font-medium">Fecha fin</label>
            <Input
              type="date"
              value={endDate}
              onChange={(e) => setEndDate(e.target.value)}
            />
          </div>
          <div className="space-y-2 w-full md:w-auto">
            <label className="text-sm font-medium">Cliente</label>
            <Select value={clientId} onValueChange={setClientId}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Todos los clientes" />
              </SelectTrigger>
              <SelectContent className="max-h-[300px] overflow-y-auto">
                <SelectItem value="All">Todos los clientes</SelectItem>
                {clients.map((client) => (
                  <SelectItem
                    key={client.id}
                    value={client.id?.toString() || ""}
                  >
                    {client.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <Button
            onClick={generateReport}
            disabled={isGenerating}
            className="w-full md:w-auto"
          >
            {isGenerating ? (
              <div className="flex items-center">
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Generando...
              </div>
            ) : (
              <>
                <RefreshCcw className="mr-2 h-4 w-4" />
                Generar reporte
              </>
            )}
          </Button>
          <div className="flex gap-2 w-full md:w-auto">
            <Button
              variant="outline"
              onClick={handleExportPDF}
              disabled={isExporting !== null || !reportData || isGenerating}
              className="w-full md:w-auto"
            >
              {isExporting === "pdf" ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <FileText className="mr-2 h-4 w-4" />
              )}
              PDF
            </Button>
            <Button
              variant="outline"
              onClick={handleExportExcel}
              disabled={isExporting !== null || !reportData || isGenerating}
              className="w-full md:w-auto"
            >
              {isExporting === "excel" ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <FileSpreadsheet className="mr-2 h-4 w-4" />
              )}
              Excel
            </Button>
          </div>
        </div>
      </Card>

      {/* Mostrar spinner mientras se genera el reporte */}
      {isGenerating && (
        <div className="h-[400px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Generando reporte...</p>
        </div>
      )}

      {/* Resumen */}
      {!isGenerating && reportData && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <Card className="p-6 flex flex-col items-center justify-center">
            <div className="w-12 h-12 bg-accent rounded-full flex items-center justify-center mb-4">
              <FileText className="h-6 w-6 text-primary" />
            </div>
            <h3 className="text-lg font-bold">
              {reportData.summary.totalQuotations}
            </h3>
            <p className="text-content-subtle">Cotizaciones totales</p>
          </Card>
          <Card className="p-6 flex flex-col items-center justify-center">
            <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mb-4">
              <CheckCircleIcon className="h-6 w-6 text-green-600" />
            </div>
            <h3 className="text-lg font-bold">
              {reportData.summary.totalApproved}
            </h3>
            <p className="text-content-subtle">Cotizaciones aprobadas</p>
          </Card>
          <Card className="p-6 flex flex-col items-center justify-center">
            <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mb-4">
              <DollarSignIcon className="h-6 w-6 text-blue-600" />
            </div>
            <h3 className="text-lg font-bold">
              ${reportData.summary.totalAmount.toLocaleString("es-CL")}
            </h3>
            <p className="text-content-subtle">Monto total</p>
          </Card>
        </div>
      )}

      {/* Gráficos */}
      {!isGenerating && reportData && (
        <Card className="p-6">
          <div className="flex flex-col space-y-6">
            <div className="flex flex-wrap gap-2">
              <Button
                variant={activeChart === "monthly" ? "default" : "outline"}
                onClick={() => setActiveChart("monthly")}
                size="sm"
              >
                <BarChart3 className="mr-2 h-4 w-4" />
                Por mes
              </Button>
              <Button
                variant={activeChart === "status" ? "default" : "outline"}
                onClick={() => setActiveChart("status")}
                size="sm"
              >
                <PieChart className="mr-2 h-4 w-4" />
                Por estado
              </Button>
              <Button
                variant={activeChart === "client" ? "default" : "outline"}
                onClick={() => setActiveChart("client")}
                size="sm"
              >
                <Users className="mr-2 h-4 w-4" />
                Por cliente
              </Button>
              <Button
                variant={activeChart === "product" ? "default" : "outline"}
                onClick={() => setActiveChart("product")}
                size="sm"
              >
                <Package className="mr-2 h-4 w-4" />
                Por producto
              </Button>
            </div>

            <div className="h-[400px] w-full">
              {activeChart === "monthly" && renderMonthlyChart()}
              {activeChart === "status" && renderStatusChart()}
              {activeChart === "client" && renderClientChart()}
              {activeChart === "product" && renderProductChart()}
            </div>
          </div>
        </Card>
      )}
    </div>
  );
}

function CheckCircleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
  );
}

function DollarSignIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <line x1="12" x2="12" y1="2" y2="22" />
      <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" />
    </svg>
  );
}

function Package(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m7.5 4.27 9 5.15" />
      <path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" />
      <path d="m3.3 7 8.7 5 8.7-5" />
      <path d="M12 22V12" />
    </svg>
  );
}


Ruta: app\(dashboard)\dashboard\tasks\page.tsx
// app/(dashboard)/dashboard/tasks/page.tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import { Card } from "@/components/ui/card";
import { useSession } from "next-auth/react";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import { getClients, Client } from "@/services/clients"; // Import Client interface
import { getUsers, User } from "@/services/users";
import {
  // getAllTasks, // Reemplazado por getFilteredTasks
  getTasksByDate,
  createTask,
  updateTask,
  deleteTask,
  finalizeTask,
  startTask,
  type Task,
  type TasksByDateParams,
  type FinalizeTaskData,
  type TaskFilterParams, // Nueva interfaz de filtros
  getAllTasks as getFilteredTasks, // Renombrar para claridad
} from "@/services/tasks";
import {
  Loader2,
  Search,
  Filter as FilterIcon,
  Calendar as CalendarIconLucide,
  AlertTriangle,
  CheckCircle,
  Clock,
  Plus,
} from "lucide-react";
// TaskFilters ya no se usa, se integran los filtros directamente en esta página
// import TaskFilters from "@/components/tasks/TaskFilters";
import TaskList from "@/components/tasks/TaskList";
import TaskForm from "@/components/tasks/TaskForm";
import FinalizeTaskForm from "@/components/tasks/FinalizeTaskForm";
import TaskDetail from "@/components/tasks/TaskDetail";
import { useNotification } from "@/contexts/NotificationContext";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DateRangePicker } from "@/components/dashboard/date-range-picker";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

// Constantes para tipos y estados de tareas
const TASK_TYPES_OPTIONS = [
  "REVISION",
  "REPARACION",
  "MANTENCION",
  "INSTALACION",
].map((type) => ({
  value: type,
  label: type.charAt(0) + type.slice(1).toLowerCase(),
}));
const TASK_STATES_OPTIONS = [
  { value: "ALL", label: "Todos los estados" },
  { value: "PENDIENTE", label: "Pendiente" },
  { value: "EN_CURSO", label: "En Curso" },
  { value: "FINALIZADO", label: "Finalizado" },
];

export default function TasksPage() {
  const { data: session } = useSession();
  const { addNotification } = useNotification();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isSavingTask, setIsSavingTask] = useState(false);
  const [isFinalizing, setIsFinalizing] = useState(false);
  const [isFinalizingTask, setIsFinalizingTask] = useState(false);
  const [currentTask, setCurrentTask] = useState<Task | null>(null);
  const [viewingTask, setViewingTask] = useState<Task | null>(null);

  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [taskToDelete, setTaskToDelete] = useState<Task | null>(null);
  const [isDeletingTask, setIsDeletingTask] = useState(false);

  const [clients, setClients] = useState<Client[]>([]);
  const [workers, setWorkers] = useState<User[]>([]);
  const [isLoadingData, setIsLoadingData] = useState(true); // Para clientes y workers
  const [isLoadingClients, setIsLoadingClients] = useState(true);
  const [isLoadingWorkers, setIsLoadingWorkers] = useState(true);
  const [isStartingTask, setIsStartingTask] = useState(false);

  // Nuevos estados para filtros de búsqueda
  const [searchFilters, setSearchFilters] = useState<TaskFilterParams>({
    clientId: undefined,
    taskType: undefined,
    startDate: undefined,
    endDate: undefined,
    state: "ALL", // Mostrar todos por defecto
  });
  const [searchTerm, setSearchTerm] = useState(""); // Para búsqueda por texto general

  const isAdmin = () => session?.user?.role === "ADMIN";

  useEffect(() => {
    const loadInitialData = async () => {
      setIsLoadingData(true);
      setIsLoadingClients(true);
      setIsLoadingWorkers(true);
      try {
        const clientsData = await getClients();
        setClients(clientsData || []);
      } catch (err) {
        addNotification("error", "Error al cargar clientes");
        console.error("Error fetching clients:", err);
      } finally {
        setIsLoadingClients(false);
      }

      try {
        const workersData = await getUsers();
        const processedWorkers = (workersData || []).map((worker) => ({
          ...worker,
          name: worker.name || worker.email || `Técnico ${worker.id}`,
          role: worker.role || "WORKER",
          email: worker.email || "",
        }));
        setWorkers(processedWorkers);
      } catch (err) {
        addNotification("error", "Error al cargar técnicos");
        console.error("Error fetching workers:", err);
      } finally {
        setIsLoadingWorkers(false);
      }
      setIsLoadingData(false);
    };
    loadInitialData();
  }, [addNotification]);

  useEffect(() => {
    fetchTasks();
  }, [searchFilters]); // Quitar searchTerm de aquí, se filtrará en el frontend

  const fetchTasks = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const tasksData = await getFilteredTasks(searchFilters);
      setTasks(tasksData || []);
    } catch (err) {
      console.error("Error al cargar tareas:", err);
      setError("Error al cargar las tareas. Intente nuevamente.");
      setTasks([]);
      addNotification("error", "Error al cargar tareas");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSearchFilterChange = (
    filterName: keyof TaskFilterParams,
    value: string | undefined
  ) => {
    setSearchFilters((prev) => ({
      ...prev,
      [filterName]: value === "ALL" || value === "" ? undefined : value,
    }));
  };

  const handleDateRangeChange = (range: { start?: Date; end?: Date }) => {
    setSearchFilters((prev) => ({
      ...prev,
      startDate: range.start?.toISOString().split("T")[0],
      endDate: range.end?.toISOString().split("T")[0],
    }));
  };

  const filteredTasksBySearchTerm = useMemo(() => {
    if (!searchTerm) return tasks; // Si no hay término de búsqueda, devolver todas las tareas cargadas por los filtros
    return tasks.filter(
      (task) =>
        task.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (task.description &&
          task.description.toLowerCase().includes(searchTerm.toLowerCase())) ||
        (task.client &&
          task.client.name.toLowerCase().includes(searchTerm.toLowerCase()))
    );
  }, [tasks, searchTerm]);

  const handleAddTask = () => {
    setCurrentTask(null);
    setIsEditing(true);
  };

  const handleEditTask = (task: Task) => {
    setCurrentTask(task);
    setIsEditing(true);
  };

  const handleViewTask = (task: Task) => {
    setViewingTask(task);
  };

  const handleFinalizeTask = (task: Task) => {
    setCurrentTask(task);
    setIsFinalizing(true);
  };

  const handleStartTask = async (task: Task) => {
    setIsStartingTask(true);
    try {
      const result = await startTask(task.id!);
      if (result && result.task) {
        setTasks((prevTasks) =>
          prevTasks.map((t) => (t.id === task.id ? result.task : t))
        );
        addNotification("success", "Tarea iniciada correctamente");
      }
    } catch (error) {
      addNotification("error", "Error al iniciar la tarea");
    } finally {
      setIsStartingTask(false);
    }
  };

  const handleDeleteConfirm = (task: Task) => {
    setTaskToDelete(task);
    setIsDeleteConfirmOpen(true);
  };

  const handleSaveTask = async (taskData: Task) => {
    setIsSavingTask(true);
    try {
      if (currentTask && currentTask.id) {
        const updated = await updateTask(currentTask.id.toString(), taskData);
        setTasks(
          tasks.map((t) => (t.id === currentTask.id ? updated.task : t))
        );
        addNotification("success", "Tarea actualizada");
      } else {
        const created = await createTask(taskData);
        setTasks([...tasks, created.task]);
        addNotification("success", "Tarea creada");
      }
      setIsEditing(false);
      setCurrentTask(null);
    } catch (err) {
      addNotification("error", "Error al guardar tarea");
    } finally {
      setIsSavingTask(false);
    }
  };

  const handleFinalizeSubmit = async (data: FinalizeTaskData) => {
    setIsFinalizingTask(true);
    try {
      const result = await finalizeTask(data);
      setTasks(tasks.map((t) => (t.id === data.taskId ? result.task : t)));
      setIsFinalizing(false);
      setCurrentTask(null);
      addNotification("success", "Tarea finalizada");
    } catch (err) {
      addNotification("error", "Error al finalizar tarea");
    } finally {
      setIsFinalizingTask(false);
    }
  };

  const handleDeleteTask = async () => {
    if (!taskToDelete || !taskToDelete.id) return;
    setIsDeletingTask(true);
    try {
      await deleteTask(taskToDelete.id.toString());
      setTasks(tasks.filter((task) => task.id !== taskToDelete.id));
      addNotification("success", "Tarea eliminada");
    } catch (err) {
      addNotification("error", "Error al eliminar tarea");
    } finally {
      setIsDeletingTask(false);
      setIsDeleteConfirmOpen(false);
      setTaskToDelete(null);
    }
  };

  if (isLoadingData && !tasks.length) {
    // Mostrar loader principal solo si no hay tareas y se están cargando datos iniciales
    return (
      <div className="space-y-8">
        <div>
          <h1 className="text-3xl font-bold">Tareas</h1>
          <p className="text-content-subtle mt-1">
            Gestiona las tareas y trabajos del equipo técnico
          </p>
        </div>
        <div className="h-[500px] w-full flex flex-col items-center justify-center">
          <Loader2 className="h-8 w-8 text-primary animate-spin mb-4" />
          <p>Cargando datos necesarios...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Tareas</h1>
        <p className="text-content-subtle mt-1">
          Gestiona las tareas y trabajos del equipo técnico
        </p>
      </div>

      {viewingTask ? (
        <>
          <TaskDetail
            task={viewingTask}
            isAdmin={isAdmin()}
            onEdit={handleEditTask}
            onDelete={handleDeleteConfirm}
            onFinalize={handleFinalizeTask}
            onStart={handleStartTask}
          />
          <div className="flex justify-center mt-4">
            <Button
              variant="outline"
              onClick={() => setViewingTask(null)}
              className="w-full max-w-md"
            >
              Volver a la lista de tareas
            </Button>
          </div>
        </>
      ) : (
        <Card className="p-6">
          {/* Filtros de Búsqueda */}
          <div className="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
            <div className="space-y-1">
              <label htmlFor="clientFilter" className="text-sm font-medium">
                Cliente
              </label>
              <Select
                value={searchFilters.clientId || ""}
                onValueChange={(value) =>
                  handleSearchFilterChange(
                    "clientId",
                    value === "ALL" ? undefined : value
                  )
                }
                disabled={isLoadingClients || isLoading}
              >
                <SelectTrigger id="clientFilter">
                  {isLoadingClients ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <SelectValue placeholder="Todos los clientes" />
                  )}
                </SelectTrigger>
                <SelectContent className="max-h-[300px] overflow-y-auto">
                  <SelectItem value="ALL">Todos los clientes</SelectItem>
                  {clients.map((client) => (
                    <SelectItem key={client.id} value={client.id!.toString()}>
                      {client.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-1">
              <label htmlFor="taskTypeFilter" className="text-sm font-medium">
                Tipo de Tarea
              </label>
              <Select
                value={searchFilters.taskType || ""}
                onValueChange={(value) =>
                  handleSearchFilterChange(
                    "taskType",
                    value === "ALL" ? undefined : value
                  )
                }
                disabled={isLoading}
              >
                <SelectTrigger id="taskTypeFilter">
                  <SelectValue placeholder="Todos los tipos" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ALL">Todos los tipos</SelectItem>
                  {TASK_TYPES_OPTIONS.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-1 md:col-span-2 lg:col-span-1">
              <label className="text-sm font-medium">Rango de Fechas</label>
              <DateRangePicker
                value={{
                  start: searchFilters.startDate
                    ? new Date(searchFilters.startDate + "T00:00:00Z")
                    : undefined,
                  end: searchFilters.endDate
                    ? new Date(searchFilters.endDate + "T23:59:59Z")
                    : undefined,
                }}
                onChange={(range) =>
                  handleDateRangeChange({ start: range.from, end: range.to })
                }
                // className="w-full" // Asegúrate que el DateRangePicker pueda tomar el ancho completo
              />
            </div>

            <div className="space-y-1">
              <label htmlFor="stateFilter" className="text-sm font-medium">
                Estado
              </label>
              <Select
                value={searchFilters.state || "ALL"}
                onValueChange={(value) =>
                  handleSearchFilterChange("state", value)
                }
                disabled={isLoading}
              >
                <SelectTrigger id="stateFilter">
                  <SelectValue placeholder="Todos los estados" />
                </SelectTrigger>
                <SelectContent>
                  {TASK_STATES_OPTIONS.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="relative md:col-span-2 lg:col-span-4">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              <Input
                placeholder="Buscar por título, descripción o cliente..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10 w-full"
                disabled={isLoading}
              />
            </div>
          </div>

          <div className="flex justify-end mb-4">
            {isAdmin() && (
              <Button
                onClick={handleAddTask}
                disabled={isLoadingData || isLoading}
              >
                <Plus className="mr-2 h-4 w-4" /> Nueva Tarea
              </Button>
            )}
          </div>

          <TaskList
            tasks={filteredTasksBySearchTerm}
            isLoading={isLoading}
            isAdmin={isAdmin()}
            onEdit={handleEditTask}
            onView={handleViewTask}
            onDelete={handleDeleteConfirm}
            onFinalize={handleFinalizeTask}
          />
        </Card>
      )}

      {error && (
        <div className="text-center p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          {error}
          <button className="ml-2 underline" onClick={fetchTasks}>
            Reintentar
          </button>
        </div>
      )}

      <TaskForm
        isOpen={isEditing}
        task={currentTask}
        clients={clients}
        workers={workers}
        onSave={handleSaveTask}
        onClose={() => setIsEditing(false)}
        isLoading={isSavingTask}
        isLoadingClients={isLoadingClients}
        isLoadingWorkers={isLoadingWorkers}
      />

      <FinalizeTaskForm
        isOpen={isFinalizing}
        task={currentTask}
        onSave={handleFinalizeSubmit}
        onClose={() => setIsFinalizing(false)}
        isLoading={isFinalizingTask}
      />

      <ConfirmDialog
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Eliminar Tarea"
        description={`¿Estás seguro que deseas eliminar la tarea "${
          taskToDelete?.title || "seleccionada"
        }"? Esta acción no se puede deshacer.`}
        onConfirm={handleDeleteTask}
        confirmLabel="Eliminar"
        isLoading={isDeletingTask}
      />
    </div>
  );
}


Ruta: app\(dashboard)\dashboard\users\page.tsx
"use client";

import { useState, useEffect } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import { Plus, Edit, Trash, Shield, Calendar, KeyRound } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import { useNotification } from "@/contexts/NotificationContext";
import {
  getUsers,
  createUser,
  updateUser,
  deleteUser,
  adminSetUserPassword,
  User,
} from "@/services/users";
import UserForm from "@/components/users/UserForm";
import { useSession } from "next-auth/react";

export default function UsersPage() {
  const [users, setUsers] = useState<User[]>([]);
  const [filteredUsers, setFilteredUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [userToDelete, setUserToDelete] = useState<User | null>(null);
  const [isDeletingUser, setIsDeletingUser] = useState(false);
  const [isSubmittingForm, setIsSubmittingForm] = useState(false);
  const { addNotification } = useNotification();
  const { data: session } = useSession();

  const isAdminLoggedIn = session?.user?.role === "ADMIN";

  useEffect(() => {
    fetchUsers();
  }, []);

  useEffect(() => {
    const filtered = users.filter(
      (user) =>
        (user.name?.toLowerCase() || "").includes(searchTerm.toLowerCase()) ||
        (user.email?.toLowerCase() || "").includes(searchTerm.toLowerCase())
    );
    setFilteredUsers(filtered);
  }, [searchTerm, users]);

  const fetchUsers = async () => {
    setIsLoading(true);
    try {
      const data = await getUsers();
      setUsers(data);
      setFilteredUsers(data);
    } catch (err: any) {
      addNotification("error", err.message || "Error al cargar los usuarios");
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddUser = () => {
    setCurrentUser(null);
    setIsFormOpen(true);
  };

  const handleEditUser = (user: User) => {
    setCurrentUser(user);
    setIsFormOpen(true);
  };

  const handleDeleteConfirm = (user: User) => {
    setUserToDelete(user);
    setIsDeleteConfirmOpen(true);
  };

  const handleSaveUser = async (
    userData: User,
    newPasswordForUser?: string
  ) => {
    setIsSubmittingForm(true);
    try {
      if (currentUser && currentUser.id) {
        // Editando usuario existente
        const userToUpdate = { ...currentUser, ...userData }; // Combinar datos actuales con los del form
        const profileDataToUpdate: Partial<User> = {
          name: userToUpdate.name,
          email: userToUpdate.email, // Backend debería validar si el email ya existe (excepto para el usuario actual)
          role: userToUpdate.role,
          phone: userToUpdate.phone,
        };

        const response = await updateUser(
          currentUser.id.toString(),
          profileDataToUpdate
        );
        setUsers(
          users.map((u) => (u.id === currentUser.id ? response.user : u))
        );
        addNotification(
          "success",
          "Datos del usuario actualizados correctamente"
        );

        // Si es admin, está editando a OTRO usuario Y se proporcionó una nueva contraseña
        if (
          isAdminLoggedIn &&
          newPasswordForUser &&
          currentUser.id !== parseInt(session?.user?.id || "0")
        ) {
          await adminSetUserPassword(
            currentUser.id.toString(),
            newPasswordForUser
          );
          addNotification(
            "success",
            "Contraseña del usuario actualizada por el administrador."
          );
        }
      } else {
        // Creando nuevo usuario
        if (!userData.password && !newPasswordForUser) {
          // Esto no debería pasar si el form valida
          addNotification(
            "error",
            "La contraseña es requerida para crear un nuevo usuario."
          );
          setIsSubmittingForm(false);
          return;
        }
        const userToCreate: User = {
          ...userData,
          password: newPasswordForUser || userData.password, // newPasswordForUser tiene prioridad si se pasa
        };
        const response = await createUser(userToCreate);
        setUsers((prevUsers) => [...prevUsers, response.user]);
        addNotification("success", "Usuario creado correctamente");
      }
      setIsFormOpen(false);
      setCurrentUser(null);
      fetchUsers(); // Recargar la lista para reflejar cambios
    } catch (err: any) {
      addNotification("error", err.message || "Error al guardar el usuario");
      // No cerrar el formulario en caso de error para que el usuario pueda corregir
      // setIsFormOpen(false);
    } finally {
      setIsSubmittingForm(false);
    }
  };

  const handleDeleteUser = async () => {
    if (!userToDelete) return;
    setIsDeletingUser(true);
    try {
      await deleteUser(userToDelete.id.toString());
      setUsers(users.filter((user) => user.id !== userToDelete.id));
      addNotification("success", "Usuario eliminado correctamente");
    } catch (err: any) {
      addNotification("error", err.message || "Error al eliminar el usuario");
    } finally {
      setIsDeletingUser(false);
      setIsDeleteConfirmOpen(false);
      setUserToDelete(null);
    }
  };

  const columns: ColumnDef<User>[] = [
    {
      accessorKey: "name",
      header: "Nombre",
      cell: ({ row }) => (
        <div className="flex items-center gap-3">
          <div>
            <p className="font-medium">{row.original.name || "Sin nombre"}</p>
            <p className="text-sm text-content-subtle">
              {row.original.email || "Sin email"}
            </p>
          </div>
        </div>
      ),
    },
    {
      accessorKey: "role",
      header: "Rol",
      cell: ({ row }) => (
        <Badge variant={row.original.role === "ADMIN" ? "primary" : "outline"}>
          <div className="flex items-center gap-1">
            {row.original.role === "ADMIN" && <Shield className="h-3 w-3" />}
            {row.original.role === "ADMIN" ? "Administrador" : "Técnico"}
          </div>
        </Badge>
      ),
    },
    {
      accessorKey: "createdAt",
      header: "Fecha de registro",
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <Calendar className="h-4 w-4 text-content-subtle" />
          {row.original.createdAt
            ? new Date(row.original.createdAt).toLocaleDateString()
            : "N/A"}
        </div>
      ),
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-1">
          {isAdminLoggedIn && ( // Solo los admins pueden editar
            <Button
              variant="ghost"
              size="sm"
              onClick={() => handleEditUser(row.original)}
              title="Editar usuario"
            >
              <Edit className="h-4 w-4" />
            </Button>
          )}
          {isAdminLoggedIn &&
            row.original.id !== parseInt(session?.user?.id || "0") && ( // Admins pueden borrar a otros, no a sí mismos
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleDeleteConfirm(row.original)}
                title="Eliminar usuario"
              >
                <Trash className="h-4 w-4" />
              </Button>
            )}
        </div>
      ),
    },
  ];

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold text-content-emphasis">Usuarios</h1>
        <p className="text-content-subtle mt-2">
          Gestiona los usuarios y técnicos de la plataforma
        </p>
      </div>

      <Card className="p-6">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          <h2 className="text-xl font-semibold">Lista de Usuarios</h2>
          <div className="flex items-center gap-4 w-full md:w-auto">
            <Input
              placeholder="Buscar por nombre o email..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="max-w-xs"
            />
            {isAdminLoggedIn && (
              <Button onClick={handleAddUser}>
                <Plus className="mr-2 h-4 w-4" />
                Nuevo Usuario
              </Button>
            )}
          </div>
        </div>

        {isLoading ? (
          <div className="text-center h-96 flex items-center justify-center">
            <p>Cargando usuarios...</p>
          </div>
        ) : (
          <DataTable columns={columns} data={filteredUsers} />
        )}
      </Card>

      <UserForm
        isOpen={isFormOpen}
        user={currentUser}
        onSave={handleSaveUser}
        onClose={() => setIsFormOpen(false)}
        isLoading={isSubmittingForm}
        showRoleSelector={isAdminLoggedIn}
      />

      <ConfirmDialog
        open={isDeleteConfirmOpen}
        onOpenChange={setIsDeleteConfirmOpen}
        title="Eliminar Usuario"
        description={`¿Estás seguro que deseas eliminar al usuario "${
          userToDelete?.name || "seleccionado"
        }"? Esta acción no se puede deshacer y podría afectar registros asociados.`}
        onConfirm={handleDeleteUser}
        confirmLabel="Eliminar"
        isLoading={isDeletingUser}
      />
    </div>
  );
}


Ruta: app\(dashboard)\layout.tsx
"use client";

import { Sidebar } from "@/components/dashboard/sidebar";
import { MobileSidebar } from "@/components/dashboard/mobile-sidebar";
import { Header } from "@/components/dashboard/header";
import { useState, useEffect } from "react";
import { cn } from "@/lib/utils";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Loader2 } from "lucide-react";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const { status } = useSession();
  const router = useRouter();

  // Obtener valor de sidebar colapsado de localStorage (solo en cliente)
  useEffect(() => {
    if (typeof window !== "undefined") {
      const savedState = localStorage.getItem("sidebarCollapsed");
      if (savedState !== null) {
        setIsCollapsed(JSON.parse(savedState));
      }
    }
  }, []);

  const toggleCollapse = () => {
    const newState = !isCollapsed;
    setIsCollapsed(newState);
    // Guardar estado en localStorage
    if (typeof window !== "undefined") {
      localStorage.setItem("sidebarCollapsed", JSON.stringify(newState));
    }
  };

  // Redireccionar a login si no hay sesión
  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  // Mostrar pantalla de carga mientras se verifica la sesión
  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  // No mostrar nada si no está autenticado (mientras se redirecciona)
  if (status === "unauthenticated") {
    return null;
  }

  return (
    <div
      className={cn(
        "min-h-screen flex flex-col",
        isMobileMenuOpen && "h-screen overflow-hidden"
      )}
    >
      {/* Header Fixed */}
      <Header
        isMobileMenuOpen={isMobileMenuOpen}
        setIsMobileMenuOpen={setIsMobileMenuOpen}
        className="h-14"
      />

      <div className="flex-1 flex pt-14">
        {/* Sidebar Desktop - Fixed */}
        <aside
          className={cn(
            "fixed top-14 bottom-0 left-0 z-30",
            "hidden lg:block",
            isCollapsed ? "w-16" : "w-64",
            "border-r border-border bg-background transition-all duration-300"
          )}
        >
          <Sidebar isCollapsed={isCollapsed} toggleCollapse={toggleCollapse} />
        </aside>
        {/* Mobile Sidebar - Considerando el header */}
        <MobileSidebar
          isOpen={isMobileMenuOpen}
          onClose={() => setIsMobileMenuOpen(false)}
          headerHeight="h-14"
        />
        {/* Main Content - Con overflow-auto para permitir scroll */}
        <main
          className={cn(
            "flex-1",
            "lg:pl-64",
            isCollapsed && "lg:pl-16",
            "overflow-y-auto h-full container p-6" // Añadido para permitir scroll
          )}
        >
          {children}
        </main>
      </div>
    </div>
  );
}


Ruta: app\api\auth\refresh\route.ts
// app/api/auth/refresh/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

// Define una constante para el timeout de la llamada al backend.
// Ajústalo para que sea menor que el timeout de tu función Lambda de Vercel.
// Por ejemplo, si tu lambda tiene un timeout de 10s, ponlo a 9s. Si es 15s, ponlo a 13-14s.
const BACKEND_FETCH_TIMEOUT_MS = 9000; // 9 segundos por defecto

export async function POST(req: NextRequest) {
  const requestStartTime = Date.now();
  console.log(
    `[Refresh API /api/auth/refresh] Received request at ${new Date(
      requestStartTime
    ).toISOString()}.`
  );

  try {
    const token = await getToken({
      req,
      secret: process.env.NEXTAUTH_SECRET,
      // Asegúrate de que las cookies seguras se manejen correctamente en producción
      secureCookie: process.env.NODE_ENV === "production",
    });

    if (!token || !token.accessToken) {
      const msg =
        "[Refresh API] No valid current token found in session to refresh (missing token or accessToken).";
      console.warn(msg);
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        { error: "No hay token válido para renovar" },
        { status: 401 }
      );
    }
    console.log(
      `[Refresh API] Current session token ID: ${
        token.id
      }, backend accessToken (first 10 chars): ${String(
        token.accessToken
      ).substring(0, 10)}...`
    );

    const apiUrl = process.env.NEXT_PUBLIC_API_URL;
    if (!apiUrl) {
      const msg =
        "[Refresh API] FATAL: NEXT_PUBLIC_API_URL is not defined in environment variables.";
      console.error(msg);
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        { error: "Configuración de API del servidor incorrecta" },
        { status: 500 }
      );
    }

    const backendRefreshUrl = `${apiUrl}/auth/refresh-token`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      console.warn(
        `[Refresh API] Backend fetch to ${backendRefreshUrl} ABORTED due to internal timeout (${BACKEND_FETCH_TIMEOUT_MS}ms).`
      );
      controller.abort();
    }, BACKEND_FETCH_TIMEOUT_MS);

    const backendCallStartTime = Date.now();
    console.log(
      `[Refresh API] Calling backend refresh endpoint: ${backendRefreshUrl} at ${new Date(
        backendCallStartTime
      ).toISOString()} for user ID: ${token.id}`
    );

    let response: Response | undefined;
    try {
      response = await fetch(backendRefreshUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token.accessToken}`, // Enviar el token de acceso actual del backend
        },
        signal: controller.signal, // Importante para el AbortController
        // Si tu backend espera userId en el body (no recomendado si el token ya lo infiere):
        // body: JSON.stringify({ userId: token.id }),
      });
    } catch (fetchError: any) {
      // Este catch se activa si hay un error de red fundamental antes de obtener una respuesta,
      // o si el fetch es abortado y la promesa es rechazada.
      clearTimeout(timeoutId); // Siempre limpiar el timeout
      const backendCallDurationOnError = Date.now() - backendCallStartTime;
      if (controller.signal.aborted) {
        // Si fue abortado por nuestro timeout programado
        console.warn(
          `[Refresh API] Fetch to ${backendRefreshUrl} was aborted by internal timeout. Duration: ${backendCallDurationOnError}ms.`
        );
        // El log del timeoutId ya se habrá disparado.
      } else {
        console.error(
          `[Refresh API] Network or other unhandled error during fetch to ${backendRefreshUrl}. Duration: ${backendCallDurationOnError}ms. Error: ${fetchError.message}`,
          fetchError
        );
      }
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      // Devolver un error genérico de gateway o servicio no disponible
      return NextResponse.json(
        {
          error:
            "Error de comunicación al intentar renovar con el servidor backend",
        },
        { status: 502 }
      ); // Bad Gateway
    }

    clearTimeout(timeoutId); // Limpiar el timeout si el fetch completó (incluso si no fue OK)
    const backendCallDuration = Date.now() - backendCallStartTime;

    if (controller.signal.aborted && !response) {
      // Si fue abortado Y no tenemos respuesta (el catch anterior debería haberlo manejado, pero por si acaso)
      console.warn(
        `[Refresh API] Fetch to ${backendRefreshUrl} was aborted (signal check). Duration: ${backendCallDuration}ms.`
      );
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        {
          error:
            "Timeout (controlado) al contactar el servicio de renovación del backend",
        },
        { status: 504 }
      );
    }

    if (!response) {
      // Si response es undefined por alguna razón no capturada antes
      console.error(
        `[Refresh API] Response from backend is undefined after fetch. Duration: ${backendCallDuration}ms.`
      );
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        { error: "Respuesta inesperada del servidor backend al renovar token" },
        { status: 500 }
      );
    }

    console.log(
      `[Refresh API] Backend call to ${backendRefreshUrl} completed. Status: ${response.status}. Duration: ${backendCallDuration}ms.`
    );

    if (!response.ok) {
      let errorData = { message: `Error del backend: ${response.statusText}` };
      try {
        errorData = await response.json();
      } catch (e) {
        console.warn(
          `[Refresh API] Could not parse JSON error response from backend. Status: ${response.status}`
        );
      }
      console.error(
        `[Refresh API] Backend refresh call FAILED. Status: ${response.status}. Response:`,
        errorData
      );
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        {
          error:
            errorData.message ||
            `Error del backend al refrescar: ${response.statusText}`,
        },
        { status: response.status } // Propagar el código de estado del backend
      );
    }

    const data = await response.json();
    if (!data.token) {
      const msg =
        "[Refresh API] Backend refresh successful BUT new token is missing in response.";
      console.error(msg, data);
      const functionDuration = Date.now() - requestStartTime;
      console.log(
        `[Refresh API] Total execution time before error: ${functionDuration}ms.`
      );
      return NextResponse.json(
        {
          error: "Respuesta de refresco inválida del backend (sin token nuevo)",
        },
        { status: 500 }
      );
    }
    console.log(
      `[Refresh API] Backend refresh successful. New backend accessToken (first 10 chars): ${String(
        data.token
      ).substring(0, 10)}...`
    );

    // Calcular la nueva expiración para el token de NextAuth (ej: 24 horas desde ahora)
    const newNextAuthTokenExp = Math.floor(Date.now() / 1000) + 24 * 60 * 60; // en segundos
    console.log(
      `[Refresh API] New NextAuth token expiration set to: ${new Date(
        newNextAuthTokenExp * 1000
      ).toISOString()}`
    );

    const functionDuration = Date.now() - requestStartTime;
    console.log(`[Refresh API] Total execution time: ${functionDuration}ms.`);
    return NextResponse.json({
      accessToken: data.token, // El nuevo token del backend
      exp: newNextAuthTokenExp, // Nueva expiración para el JWT de NextAuth (en segundos)
    });
  } catch (error: any) {
    // Este catch es para errores inesperados en el flujo de la función POST en sí,
    // no necesariamente errores de fetch que ya deberían ser manejados.
    console.error(
      "[Refresh API] UNHANDLED EXCEPTION in POST /api/auth/refresh:",
      error.message,
      error.stack
    );
    const functionDuration = Date.now() - requestStartTime;
    console.log(
      `[Refresh API] Total execution time before error: ${functionDuration}ms.`
    );
    return NextResponse.json(
      {
        error:
          error.message ||
          "Error interno grave en el proceso de renovación de token",
      },
      { status: 500 }
    );
  }
}


Ruta: app\api\auth\[...nextauth]\route.ts
// app/api/auth/[...nextauth]/route.ts
import { handlers } from "@/auth";

export const { GET, POST } = handlers;


Ruta: app\error.tsx
// app/error.tsx
"use client";

import { useEffect } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { AlertCircle, Home, RefreshCw } from "lucide-react";
import { logError } from "@/lib/errorHandler";

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    logError({
      type: "global_error",
      message: error.message,
      details: { stack: error.stack, digest: error.digest },
      timestamp: Date.now(),
      handled: true,
    });
    console.error("Global Error Boundary Caught:", error);
  }, [error]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 bg-background">
      <div className="max-w-md w-full p-6 bg-white rounded-lg shadow-lg border border-error/20 text-center">
        <div className="flex items-center justify-center w-16 h-16 mx-auto mb-4 rounded-full bg-error/10">
          <AlertCircle className="w-8 h-8 text-error" />
        </div>

        <h1 className="text-2xl font-bold mb-4">Algo salió mal</h1>

        <p className="text-content-subtle mb-6">
          Ha ocurrido un error en la aplicación. Nuestro equipo ha sido
          notificado y estamos trabajando para solucionarlo lo antes posible.
        </p>

        {process.env.NODE_ENV !== "production" && (
          <div className="mb-6 p-4 bg-gray-100 rounded overflow-auto text-sm">
            <p className="font-mono font-bold text-error">{error.message}</p>
            {error.stack && (
              <pre className="mt-2 text-xs text-content-subtle text-left whitespace-pre-wrap">
                {error.stack}
              </pre>
            )}
            {error.digest && (
              <p className="mt-2 text-xs text-content-subtle">
                Error ID: {error.digest}
              </p>
            )}
          </div>
        )}

        <div className="flex flex-col sm:flex-row gap-3 justify-center">
          <Button
            onClick={() => reset()}
            className="flex items-center justify-center"
          >
            <RefreshCw className="mr-2 h-4 w-4" />
            Reintentar
          </Button>

          <Link href="/dashboard" passHref>
            <Button
              variant="outline"
              className="flex items-center justify-center"
            >
              <Home className="mr-2 h-4 w-4" />
              Ir al inicio
            </Button>
          </Link>
        </div>
      </div>
    </div>
  );
}


Ruta: app\globals.css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;

  /* Color principal */
  --primary: #b42516;
  --primary-foreground: #ffffff;
  --primary-hover: #9e2113;
  --primary-focus: #8a1d10;

  /* Color de acento (versión clara del primario) */
  --accent: #f8d7d4;
  --accent-hover: #f5c5c1;

  /* Color secundario */
  --secondary: #f3f4f6;
  --secondary-foreground: #374151;
  --secondary-hover: #e5e7eb;
  --secondary-focus: #d1d5db;

  /* Colores de texto */
  --content: #1f2937;
  --content-subtle: #6b7280;
  --content-emphasis: #111827;

  /* Colores de borde */
  --border: #e5e7eb;
  --border-focus: #b42516;

  /* Colores de estado */
  --error: #ef4444;
  --error-foreground: #ffffff;
  --success: #22c55e;
  --success-foreground: #ffffff;

  /* Varios */
  --radius: 0.5rem;
  --ring: #e5e7eb;
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    
    // Color principal (mantiene el mismo) 
    --primary: #b42516;
    --primary-foreground: #ffffff;
    --primary-hover: #9e2113;
    --primary-focus: #8a1d10;
    
    // Color de acento (versión oscura del primario) 
    --accent: #7f1a0f;
    --accent-hover: #6a160c;
    
    // Color secundario 
    --secondary: #374151;
    --secondary-foreground: #F9FAFB;
    --secondary-hover: #4B5563;
    --secondary-focus: #6B7280;
    
    // Colores de texto 
    --content: #E5E7EB;
    --content-subtle: #9CA3AF;
    --content-emphasis: #FFFFFF;
    
    // Colores de borde 
    --border: #374151;
    --border-focus: #b42516;
    
    // Colores de estado 
    --error: #F87171;
    --error-foreground: #FFFFFF;
    --success: #4ADE80;
    --success-foreground: #FFFFFF;
    
    // Varios 
    --ring: #374151;
  }
} */

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  /* Estilos para enlaces */
  a {
    @apply text-primary hover:text-primary-hover transition-colors;
  }

  /* Estilos para títulos */
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    @apply text-content-emphasis font-bold;
  }

  /* Estilos para botones */
  button {
    @apply font-bold;
  }
}

@layer components {
  /* Definir clases de utilidad personalizadas */
  .card-hover {
    @apply transition-all duration-200 hover:shadow-md;
  }

  .bg-pattern {
    background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23b42516' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
  }
}


Ruta: app\layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";

const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: {
    template: '%s | RG Electronica',
    default: 'RG Electronica - Sistema de Gestión de Servicios Técnicos',
  },
  description: "Sistema de gestión para servicios técnicos y mantenimiento",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="es">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

Ruta: app\not-found.tsx
// app/not-found.tsx (mejorado)
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Home, Search, ArrowLeft } from "lucide-react";
import { useEffect } from "react";
import { logError } from "@/lib/errorHandler";

export default function NotFoundPage() {
  useEffect(() => {
    // Registrar el error 404 para análisis
    logError({
      type: "api/not-found",
      message: `Página no encontrada: ${window.location.pathname}`,
      statusCode: 404,
      timestamp: Date.now(),
      handled: true,
    });
  }, []);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 bg-background">
      <div className="max-w-md w-full text-center">
        <div className="mb-8">
          <div className="text-9xl font-bold text-primary mb-2">404</div>
          <h1 className="text-2xl font-bold text-content-emphasis mb-3">
            Página no encontrada
          </h1>
          <p className="text-content-subtle">
            Lo sentimos, la página que estás buscando no existe o ha sido
            movida.
          </p>
        </div>

        <div className="flex flex-col md:flex-row gap-3 justify-center">
          <Link href="/dashboard" passHref>
            <Button className="flex items-center justify-center">
              <Home className="mr-2 h-4 w-4" />
              Ir al inicio
            </Button>
          </Link>

          <Button
            variant="outline"
            className="flex items-center justify-center"
            onClick={() => window.history.back()}
          >
            <ArrowLeft className="mr-2 h-4 w-4" />
            Volver atrás
          </Button>
        </div>

        <div className="mt-8">
          <p className="text-content-subtle text-sm">
            Si crees que esto es un error, por favor contacta a soporte.
          </p>
        </div>
      </div>
    </div>
  );
}


Ruta: app\page.tsx
import { Metadata } from "next";
import { redirect } from "next/navigation";

export const metadata: Metadata = {
  title: "Inicio",
};

export default function Home() {
  redirect("/login");
}


Ruta: app\providers.tsx
"use client";

import { NotificationProvider } from "@/contexts/NotificationContext";
import { SessionProvider } from "@/components/session-provider";
import { ErrorProvider } from "@/components/error-provider";
import { ErrorBoundary } from "@/components/error-boundary";
import { ReactNode } from "react";

/**
 * Componente que proporciona todos los contextos y proveedores necesarios para la aplicación
 */
export function Providers({ children }: { children: ReactNode }) {
  return (
    <ErrorBoundary>
      <SessionProvider>
        <NotificationProvider>
          <ErrorProvider>
              {children}
          </ErrorProvider>
        </NotificationProvider>
      </SessionProvider>
    </ErrorBoundary>
  );
}

Ruta: auth.ts
// web/auth.ts
import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";

const NEXTAUTH_SECRET = process.env.NEXTAUTH_SECRET as string;
const NEXT_PUBLIC_API_URL = process.env.NEXT_PUBLIC_API_URL as string;

if (!NEXTAUTH_SECRET) {
  console.error(
    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  );
  console.error("FATAL: Missing NEXTAUTH_SECRET environment variable.");
  console.error("Authentication will not work and may lead to security risks.");
  console.error(
    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  );
  // En un entorno de producción real, podrías querer lanzar un error para detener el build/deploy
  // if (process.env.NODE_ENV === 'production') {
  //   throw new Error("Missing NEXTAUTH_SECRET environment variable");
  // }
}
if (!NEXT_PUBLIC_API_URL && process.env.NODE_ENV !== "test") {
  console.warn(
    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  );
  console.warn("WARNING: Missing NEXT_PUBLIC_API_URL environment variable.");
  console.warn(
    "Login attempts will fail as the frontend cannot contact the backend API."
  );
  console.warn(
    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  );
  // if (process.env.NODE_ENV === 'production') {
  //   throw new Error("Missing NEXT_PUBLIC_API_URL environment variable");
  // }
}

export const { handlers, signIn, signOut, auth } = NextAuth({
  secret: NEXTAUTH_SECRET,
  session: {
    strategy: "jwt",
    maxAge: 24 * 60 * 60, // 24 horas para la validez del JWT de NextAuth
  },
  providers: [
    Credentials({
      id: "credentials",
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email", placeholder: "tu@email.com" },
        password: { label: "Contraseña", type: "password" },
      },
      async authorize(credentials, req) {
        // Loguear el inicio del intento de autorización
        console.log(
          "[Authorize Callback] Attempting authorization for email:",
          credentials?.email
        );

        if (!NEXT_PUBLIC_API_URL) {
          console.error(
            "[Authorize Callback] CRITICAL: NEXT_PUBLIC_API_URL is not defined. Cannot proceed."
          );
          return null;
        }
        if (!credentials?.email || !credentials?.password) {
          console.warn(
            "[Authorize Callback] Email or password missing in provided credentials. Denying authorization."
          );
          return null;
        }

        try {
          const loginApiUrl = `${NEXT_PUBLIC_API_URL}/auth/login`;
          console.log(
            `[Authorize Callback] Sending login request to backend: POST ${loginApiUrl}`
          );

          const response = await fetch(loginApiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              email: credentials.email,
              password: credentials.password,
            }),
          });

          console.log(
            `[Authorize Callback] Backend response status: ${response.status}`
          );

          if (!response.ok) {
            let errorData = { message: `Backend returned ${response.status}` };
            try {
              // Intentar parsear el cuerpo del error, ya que puede contener información útil
              const errorBody = await response.text(); // Leer como texto primero
              if (errorBody) {
                errorData = JSON.parse(errorBody); // Luego intentar parsear como JSON
              }
            } catch (e) {
              console.warn(
                `[Authorize Callback] Could not parse JSON error response from backend. Status: ${response.status}. Response body might not be JSON.`
              );
            }
            console.warn(
              `[Authorize Callback] Backend login failed. Status: ${response.status}. Error details:`,
              errorData.message || response.statusText
            );
            return null; // Devuelve null si el backend no valida las credenciales
          }

          const data = await response.json();
          console.log(
            "[Authorize Callback] Backend login successful. Data received (structure check):",
            {
              userId: data.user?.id,
              email: data.user?.email,
              tokenPresent: !!data.token,
            }
          );

          if (data.token && data.user && data.user.id) {
            console.log(
              `[Authorize Callback] User data and token present for user ID: ${data.user.id}. Returning user object to NextAuth.`
            );
            // Este objeto es el que se pasa como 'user' al callback 'jwt'
            return {
              id: data.user.id.toString(), // NextAuth espera 'id' como string
              email: data.user.email as string,
              name: data.user.name as string,
              role: data.user.role as string,
              token: data.token, // Este es el accessToken de tu backend
            };
          } else {
            console.warn(
              "[Authorize Callback] Backend response was OK, but 'token' or 'user.id' missing from data. Denying authorization.",
              data
            );
            return null;
          }
        } catch (error) {
          console.error(
            "[Authorize Callback] Exception during fetch to backend /auth/login:",
            error
          );
          return null;
        }
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user, trigger, account, profile }) {
      const now = Date.now();
      const logTokenExp = token.exp
        ? new Date((token.exp as number) * 1000).toISOString()
        : "N/A";
      console.log(
        `[JWT Callback] Trigger: "${trigger}", User ID from arg: ${user?.id}, Input token ID: ${token?.id}, Input token exp: ${logTokenExp}, Account provider: ${account?.provider}`
      );

      // 1. Cuando el usuario inicia sesión (trigger "signIn" o "signUp" y hay objeto 'user' del provider)
      if (
        user &&
        (trigger === "signIn" || trigger === "signUp") &&
        account?.provider === "credentials"
      ) {
        console.log(
          `[JWT Callback] Sign-in for user ID: ${user.id}. Populating new JWT token.`
        );
        token.id = user.id as string;
        token.email = user.email as string;
        token.name = user.name as string;
        token.role = (user as any).role as string;
        token.accessToken = (user as any).token as string;

        token.exp = Math.floor(now / 1000) + 24 * 60 * 60; // 24 horas
        token.error = undefined;

        const populatedTokenExpLog = token.exp
          ? new Date((token.exp as number) * 1000).toISOString()
          : "N/A";
        console.log(
          `[JWT Callback] Token populated on sign-in. New NextAuth exp: ${populatedTokenExpLog}, User ID: ${token.id}`
        );
      }

      // 2. VERIFICACIÓN CRÍTICA para sesiones existentes (leídas de la cookie)
      if (!user && !token.id) {
        console.warn(
          "[JWT Callback] CRITICAL: Token is missing 'id' (and not initial signIn). Session likely corrupted or incomplete. Invalidating session."
        );
        return {
          exp: 0,
          error: "InvalidSessionState_MissingId",
        };
      }

      // 3. Verificar expiración del token de NextAuth
      if (token.exp && now >= (token.exp as number) * 1000) {
        const expiredMsg = `[JWT Callback] NextAuth session JWT has EXPIRED. Original exp: ${new Date(
          (token.exp as number) * 1000
        ).toISOString()}, Now: ${new Date(now).toISOString()}.`;
        console.warn(expiredMsg);
        delete token.accessToken;
        delete (token as any).backendTokenExpiresAt;
        return {
          ...token,
          exp: 0,
          error: "NextAuthSessionExpired",
        };
      }

      // 4. Lógica de Refresco del Token del Backend (ACTUALMENTE DESACTIVADA)
      // console.log("[JWT Callback] Backend token refresh logic is currently SKIPPED.");

      const finalTokenExpLog = token.exp
        ? new Date((token.exp as number) * 1000).toISOString()
        : "N/A";
      console.log(
        `[JWT Callback] EXIT. Returning token with ID: ${token?.id}, NextAuth Exp: ${finalTokenExpLog}, Error: ${token.error}`
      );
      return token;
    },
    async session({ session, token }) {
      console.log(
        `[Session Callback] Populating client session from JWT token. Token ID: ${token?.id}, Token error: ${token?.error}, Token exp: ${token?.exp}`
      );

      if (token.id) {
        session.user.id = token.id as string;
        session.user.name = token.name as string;
        session.user.email = token.email as string;
        session.user.role = token.role as string;
        session.accessToken = token.accessToken as string;
      } else {
        console.warn(
          "[Session Callback] Token from JWT callback is missing 'id'. Client session.user will be incomplete or undefined."
        );
        // @ts-ignore
        delete session.user;
        // @ts-ignore
        delete session.accessToken;
      }

      if (token.error) {
        (session as any).error = token.error;
        console.warn(
          `[Session Callback] Propagating error to client session object: ${token.error}`
        );
      }

      if (token.exp === 0 && !(session as any).error) {
        (session as any).error = "SessionForceInvalidatedByServer";
        console.warn(
          `[Session Callback] Token exp is 0, marking session with error: "SessionForceInvalidatedByServer"`
        );
      }

      console.log(
        `[Session Callback] EXIT. Client session object: UserID: ${
          session.user?.id
        }, SessionError: ${(session as any).error}, SessionExpires: ${
          session.expires
        }`
      );
      return session;
    },
  },
  pages: {
    signIn: "/login",
    error: "/login",
  },
  debug: process.env.NODE_ENV === "development",
});


Ruta: components\auth\auth-form.tsx
// components/auth/auth-form.tsx
import { CSRFProtectedForm } from "@/components/ui/csrf-protected-form";
import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { FormEvent, ReactNode } from "react";

interface AuthFormProps {
  onSubmit: (e: FormEvent<HTMLFormElement>) => Promise<void>;
  children: ReactNode;
  error?: string | null;
  submitText: string;
  isLoading?: boolean;
  className?: string;
}

export function AuthForm({
  onSubmit,
  children,
  error,
  submitText,
  isLoading = false,
  className,
}: AuthFormProps) {
  return (
    <Card className={cn("p-6 shadow-lg", className)}>
      <CSRFProtectedForm
        onSubmit={onSubmit}
        error={error}
        submitText={submitText}
        isLoading={isLoading}
      >
        {children}
      </CSRFProtectedForm>
    </Card>
  );
}

Ruta: components\auth\auth-layout.tsx
import { AlertCircleIcon, CheckIcon, XIcon } from "lucide-react";
import { ReactNode } from "react";

interface AuthLayoutProps {
  children: ReactNode;
  title: string;
  subtitle?: string;
}

export function AuthLayout({ children, title, subtitle }: AuthLayoutProps) {
  return (
    <div className="min-h-screen w-full flex flex-col lg:flex-row">
      {/* Lado izquierdo - Área de decoración */}
      <div className="hidden lg:flex lg:w-1/2 relative bg-primary p-12 items-center justify-center">
        <div className="relative z-10 text-white max-w-lg">
          <h1 className="text-4xl font-bold mb-6">Bienvenido a RG Electronica</h1>
          <p className="text-lg opacity-90 mb-8">
            Una plataforma para la gestion de tu negocio.
          </p>
        </div>
        {/* Patrón de fondo */}
        <div className="absolute inset-0 z-0">
          <div className="absolute inset-0 bg-gradient-to-br from-primary/90 to-primary" />
          <div className="absolute inset-0 bg-[url('/grid.svg')] opacity-20" />
        </div>
      </div>

      {/* Lado derecho - Formulario */}
      <div className="flex-1 flex flex-col min-h-screen">
        <div className="flex-1 flex items-center justify-center p-6">
          <div className="w-full max-w-md space-y-8">
            <div className="text-center">
              <h2 className="text-3xl font-bold tracking-tight text-gray-900">
                {title}
              </h2>
              {subtitle && (
                <p className="mt-2 text-sm text-gray-600">{subtitle}</p>
              )}
            </div>
            {children}
          </div>
        </div>
        <footer className="py-4 text-center text-sm text-gray-500">
          © 2024 RG Electronica.
        </footer>
      </div>
    </div>
  );
}


Ruta: components\clients\ClientForm.tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel } from "@/components/ui/form";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { FormTextarea } from "@/components/ui/form-textarea";
import { Client } from "@/services/clients";
import { Loader2 } from "lucide-react";

interface ClientFormProps {
  isOpen: boolean;
  customer: Client | null;
  onSave: (client: Client) => Promise<void>;
  onCancel: () => void;
  isLoading?: boolean;
}

export default function ClientForm({
  isOpen,
  customer,
  onSave,
  onCancel,
  isLoading = false,
}: ClientFormProps) {
  const [clientForm, setClientForm] = useState<Client>({
    name: "",
    email: "",
    phone: "",
    address: "",
    notes: "",
  });

  useEffect(() => {
    if (customer) {
      setClientForm({
        ...customer,
      });
    } else {
      // Reset form for new client
      setClientForm({
        name: "",
        email: "",
        phone: "",
        address: "",
        notes: "",
      });
    }
  }, [customer, isOpen]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onSave(clientForm);
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onCancel()}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>
            {customer ? "Editar Cliente" : "Nuevo Cliente"}
          </DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <FormField>
            <FormLabel>Nombre</FormLabel>
            <Input
              value={clientForm.name}
              onChange={(e) =>
                setClientForm({ ...clientForm, name: e.target.value })
              }
              required
              disabled={isLoading}
              className="relative"
            />
          </FormField>

          <FormField>
            <FormLabel>Email</FormLabel>
            <Input
              type="email"
              value={clientForm.email || ""}
              onChange={(e) =>
                setClientForm({ ...clientForm, email: e.target.value })
              }
              disabled={isLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Teléfono</FormLabel>
            <Input
              value={clientForm.phone || ""}
              onChange={(e) =>
                setClientForm({ ...clientForm, phone: e.target.value })
              }
              disabled={isLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Dirección</FormLabel>
            <Input
              value={clientForm.address || ""}
              onChange={(e) =>
                setClientForm({ ...clientForm, address: e.target.value })
              }
              disabled={isLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Notas</FormLabel>
            <FormTextarea
              value={clientForm.notes || ""}
              onChange={(e) =>
                setClientForm({ ...clientForm, notes: e.target.value })
              }
              disabled={isLoading}
            />
          </FormField>

          <DialogFooter className="pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={onCancel}
              disabled={isLoading}
            >
              Cancelar
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? (
                <div className="flex items-center">
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  {customer ? "Guardando..." : "Creando..."}
                </div>
              ) : customer ? (
                "Guardar cambios"
              ) : (
                "Crear cliente"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\clients\ClientSelect.tsx
// web\components\clients\ClientSelect.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus, Loader2 } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  SelectGroup,
  SelectLabel,
} from "@/components/ui/select";
import { Client, createClient } from "@/services/clients";
import { useNotification } from "@/contexts/NotificationContext";
import ClientForm from "@/components/clients/ClientForm";

interface ClientSelectProps {
  clients: Client[];
  value: string;
  onValueChange: (value: string, client?: Client) => void;
  onClientCreated?: (client: Client) => void;
  placeholder?: string;
  isLoading?: boolean;
}

export default function ClientSelect({
  clients,
  value,
  onValueChange,
  onClientCreated,
  placeholder = "Seleccionar cliente",
  isLoading = false,
}: ClientSelectProps) {
  const [isAddingClient, setIsAddingClient] = useState(false);
  const [isCreatingClient, setIsCreatingClient] = useState(false);
  const { addNotification } = useNotification();

  const handleAddClient = async (clientData: Client) => {
    try {
      setIsCreatingClient(true);
      const newClient = await createClient(clientData);

      // Notificar al componente padre sobre el nuevo cliente
      if (onClientCreated) {
        onClientCreated(newClient);
      }

      // Seleccionar el cliente recién creado
      onValueChange(newClient.id.toString(), newClient);

      addNotification("success", "Cliente creado correctamente");
      setIsAddingClient(false);
    } catch (error) {
      console.error("Error al crear cliente:", error);
      addNotification("error", "Error al crear el cliente");
    } finally {
      setIsCreatingClient(false);
    }
  };

  return (
    <>
      <div className="flex gap-2 items-center">
        <Select
          value={value}
          onValueChange={(val) => {
            if (val === "new") {
              setIsAddingClient(true);
              return;
            }

            // Encontrar el cliente seleccionado
            const selectedClient = clients.find(
              (client) => client.id.toString() === val
            );

            onValueChange(val, selectedClient);
          }}
          className="flex-1"
          disabled={isLoading || isCreatingClient}
        >
          <SelectTrigger>
            {isLoading ? (
              <div className="flex items-center">
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                <span>Cargando clientes...</span>
              </div>
            ) : (
              <SelectValue placeholder={placeholder} />
            )}
          </SelectTrigger>
          <SelectContent className="max-h-[300px] overflow-y-auto">
            <SelectItem value="-">Sin cliente</SelectItem>
            <SelectItem value="new">
              <div className="flex items-center">
                <Plus className="h-4 w-4 mr-2" />
                Crear nuevo cliente
              </div>
            </SelectItem>
            {clients.length > 0 ? (
              <SelectGroup>
                <SelectLabel className="px-2 py-1 text-xs text-content-subtle">
                  Clientes ({clients.length})
                </SelectLabel>
                <div className="max-h-[200px] overflow-y-auto">
                  {clients.map((client) => (
                    <SelectItem key={client.id} value={client.id.toString()}>
                      {client.name}
                    </SelectItem>
                  ))}
                </div>
              </SelectGroup>
            ) : (
              <SelectItem value="empty" disabled>
                No hay clientes disponibles
              </SelectItem>
            )}
          </SelectContent>
        </Select>
      </div>

      {/* Formulario para crear nuevo cliente */}
      <ClientForm
        isOpen={isAddingClient}
        customer={null}
        onSave={handleAddClient}
        onCancel={() => setIsAddingClient(false)}
        isLoading={isCreatingClient}
      />
    </>
  );
}

Ruta: components\clients\CustomerForm.tsx
import { useState } from "react";
import { FormField, FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { EntityForm } from "@/components/ui/entity-form";
import { FormTextarea } from "@/components/ui/form-textarea";
import { Alert } from "@/components/ui/alert";
import { Info } from "lucide-react";

interface Customer {
  id: string;
  name: string;
  email: string;
  emailSecondary?: string;
  emailTertiary?: string;
  phone?: string;
  rut?: string;
  address?: string;
  commune?: string;
  administrator?: string;
  butler?: string;
  notes?: string;
}

interface CustomerFormProps {
  customer: Customer | null;
  onSave: (customer: Customer) => void;
  onCancel: () => void;
  isSubmitting?: boolean;
  error?: string | null;
}

export function CustomerForm({
  customer,
  onSave,
  onCancel,
  isSubmitting = false,
  error = null,
}: CustomerFormProps) {
  const [name, setName] = useState(customer?.name || "");
  const [email, setEmail] = useState(customer?.email || "");
  const [emailSecondary, setEmailSecondary] = useState(
    customer?.emailSecondary || ""
  );
  const [emailTertiary, setEmailTertiary] = useState(
    customer?.emailTertiary || ""
  );
  const [phone, setPhone] = useState(customer?.phone || "");
  const [address, setAddress] = useState(customer?.address || "");
  const [commune, setCommune] = useState(customer?.commune || "");
  const [rut, setRut] = useState(customer?.rut || "");
  const [administrator, setAdministrator] = useState(
    customer?.administrator || ""
  );
  const [butler, setButler] = useState(customer?.butler || "");
  const [notes, setNotes] = useState(customer?.notes || "");

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    onSave({
      id: customer?.id || "",
      name,
      email,
      emailSecondary,
      emailTertiary,
      phone,
      rut,
      address,
      commune,
      administrator,
      butler,
      notes,
    });
  };

  return (
    <EntityForm
      isOpen={true}
      onClose={onCancel}
      onSubmit={handleSubmit}
      title={customer ? "Editar Cliente" : "Agregar Cliente"}
      isLoading={isSubmitting}
      error={error}
      maxWidth="max-w-2xl"
    >
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField>
          <FormLabel>Nombre</FormLabel>
          <Input
            value={name}
            onChange={(e) => setName(e.target.value)}
            required
          />
        </FormField>

        {/* Emails section - takes full width */}
        <div className="md:col-span-2 space-y-3">
          <FormField>
            <FormLabel>Email Principal</FormLabel>
            <Input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              placeholder="Email principal (obligatorio)"
            />
          </FormField>

          <FormField>
            <FormLabel>Email Secundario</FormLabel>
            <Input
              type="email"
              value={emailSecondary}
              onChange={(e) => setEmailSecondary(e.target.value)}
              placeholder="Email secundario (opcional)"
            />
          </FormField>

          <FormField>
            <FormLabel>Email Terciario</FormLabel>
            <Input
              type="email"
              value={emailTertiary}
              onChange={(e) => setEmailTertiary(e.target.value)}
              placeholder="Email terciario (opcional)"
            />
          </FormField>
        </div>

        <FormField>
          <FormLabel>Teléfono</FormLabel>
          <Input
            type="tel"
            value={phone}
            onChange={(e) => setPhone(e.target.value)}
          />
        </FormField>
        <FormField>
          <FormLabel>RUT</FormLabel>
          <Input value={rut} onChange={(e) => setRut(e.target.value)} />
        </FormField>
        <FormField>
          <FormLabel>Dirección</FormLabel>
          <Input value={address} onChange={(e) => setAddress(e.target.value)} />
        </FormField>
        <FormField>
          <FormLabel>Comuna</FormLabel>
          <Input value={commune} onChange={(e) => setCommune(e.target.value)} />
        </FormField>
        <FormField>
          <FormLabel>Administrador</FormLabel>
          <Input
            value={administrator}
            onChange={(e) => setAdministrator(e.target.value)}
          />
        </FormField>
        <FormField>
          <FormLabel>Conserje</FormLabel>
          <Input value={butler} onChange={(e) => setButler(e.target.value)} />
        </FormField>
      </div>

      <FormField>
        <FormLabel>Notas</FormLabel>
        <FormTextarea
          value={notes}
          onChange={(e) => setNotes(e.target.value)}
        />
      </FormField>
    </EntityForm>
  );
}


Ruta: components\clients\EmailBadge.tsx
import React from 'react';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Mail } from 'lucide-react';

interface EmailBadgeProps {
  emails: string[];
}

/**
 * Componente para mostrar un indicador de múltiples correos electrónicos
 * con un tooltip que muestra todos los correos disponibles
 */
export const EmailBadge: React.FC<EmailBadgeProps> = ({ emails }) => {
  // Filtrar emails válidos (no vacíos)
  const validEmails = emails.filter(email => email && email.trim() !== '');
  
  if (validEmails.length <= 1) {
    return null; // No mostrar el badge si solo hay un email o ninguno
  }
  
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div className="inline-flex items-center ml-2 px-1.5 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs font-medium">
            <Mail className="h-3 w-3 mr-1" />
            {validEmails.length}
          </div>
        </TooltipTrigger>
        <TooltipContent className="p-2 max-w-xs">
          <p className="font-semibold mb-1">Correos electrónicos:</p>
          <ul className="text-xs space-y-1">
            {validEmails.map((email, index) => (
              <li key={index} className="flex items-center">
                <span className="inline-block w-3 h-3 rounded-full bg-blue-500 mr-2"></span>
                {email}
              </li>
            ))}
          </ul>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};

export default EmailBadge;

Ruta: components\dashboard\date-range-picker.tsx
// components/dashboard/date-range-picker.tsx
"use client";

import * as React from "react";
import { addDays, format, isValid } from "date-fns";
import { es } from "date-fns/locale";
import { CalendarIcon, CalendarDays, HelpCircle } from "lucide-react";
import { DateRange } from "react-day-picker";

import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface DateRangePickerProps {
  value: { start?: Date; end?: Date };
  onChange: (range: { start?: Date; end?: Date }) => void;
  className?: string;
}

export function DateRangePicker({
  value,
  onChange,
  className,
}: DateRangePickerProps) {
  const [date, setDate] = React.useState<DateRange | undefined>(() => {
    const validStart =
      value.start instanceof Date && isValid(value.start)
        ? new Date(value.start)
        : undefined;
    const validEnd =
      value.end instanceof Date && isValid(value.end)
        ? new Date(value.end)
        : undefined;
    if (validStart || validEnd) {
      return { from: validStart, to: validEnd };
    }
    return undefined;
  });

  const [selectionMode, setSelectionMode] = React.useState<
    "start" | "end" | "complete"
  >(
    value.start && value.end && isValid(value.start) && isValid(value.end)
      ? "complete"
      : "start"
  );
  const [open, setOpen] = React.useState(false);

  React.useEffect(() => {
    // console.log("DateRangePicker props 'value' changed:", {
    //   start: value.start && isValid(value.start) ? value.start.toISOString() : undefined,
    //   end: value.end && isValid(value.end) ? value.end.toISOString() : undefined,
    // });

    const propStart = value.start;
    const propEnd = value.end;

    const validPropStart =
      propStart instanceof Date && isValid(propStart)
        ? new Date(propStart)
        : undefined;
    const validPropEnd =
      propEnd instanceof Date && isValid(propEnd)
        ? new Date(propEnd)
        : undefined;

    let newSelectionMode: "start" | "end" | "complete" = "start";
    if (validPropStart && !validPropEnd) {
      newSelectionMode = "end";
    } else if (validPropStart && validPropEnd) {
      newSelectionMode = "complete";
    }

    // Comparar con el estado interno 'date'
    const internalStart = date?.from;
    const internalEnd = date?.to;

    // Verificar si hubo un cambio real en las props que deba reflejarse en el estado
    const propsActuallyChanged =
      validPropStart?.getTime() !== internalStart?.getTime() ||
      validPropEnd?.getTime() !== internalEnd?.getTime() ||
      // Caso donde una fecha se vuelve undefined
      (validPropStart === undefined && internalStart !== undefined) ||
      (validPropEnd === undefined && internalEnd !== undefined);

    if (propsActuallyChanged) {
      // console.log("Updating internal 'date' state due to prop change:", { from: validPropStart, to: validPropEnd });
      setDate({ from: validPropStart, to: validPropEnd });
      setSelectionMode(newSelectionMode);
    } else if (!validPropStart && !validPropEnd && date !== undefined) {
      // Si las props se vuelven completamente undefined y el estado interno no lo es, resetear.
      // console.log("Resetting internal 'date' state because props are undefined.");
      setDate(undefined);
      setSelectionMode("start");
    }
  }, [value.start, value.end]); // Depender solo de value.start y value.end

  const presets = [
    {
      label: "Últimos 7 días",
      value: {
        from: addDays(new Date(), -6),
        to: new Date(),
      },
    },
    {
      label: "Últimos 30 días",
      value: {
        from: addDays(new Date(), -29),
        to: new Date(),
      },
    },
    {
      label: "Este mes",
      value: {
        from: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
        to: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0),
      },
    },
    {
      label: "Último trimestre",
      value: {
        from: addDays(new Date(), -89),
        to: new Date(),
      },
    },
  ];

  const handlePresetChange = (presetValue?: DateRange) => {
    if (
      presetValue?.from &&
      presetValue?.to &&
      isValid(presetValue.from) &&
      isValid(presetValue.to)
    ) {
      const newFrom = new Date(presetValue.from);
      const newTo = new Date(presetValue.to);
      setDate({ from: newFrom, to: newTo });
      setSelectionMode("complete");
      onChange({ start: newFrom, end: newTo });
      setOpen(false);
    }
  };

  const applyRange = () => {
    if (date?.from && isValid(date.from) && date?.to && isValid(date.to)) {
      onChange({ start: new Date(date.from), end: new Date(date.to) });
      setOpen(false);
    } else if (date?.from && isValid(date.from) && !date?.to) {
      onChange({ start: new Date(date.from), end: new Date(date.from) });
      setOpen(false);
    }
  };

  const resetSelection = () => {
    setDate(undefined);
    setSelectionMode("start");
    onChange({ start: undefined, end: undefined });
  };

  return (
    <div className={cn("grid gap-2", className)}>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            id="date"
            variant="outline"
            className={cn(
              "w-full justify-start text-left font-normal",
              !date?.from && "text-muted-foreground"
            )}
          >
            <CalendarIcon className="mr-2 h-4 w-4" />
            {date?.from && isValid(date.from) ? (
              date.to && isValid(date.to) ? (
                <>
                  {format(date.from, "dd MMM yy", { locale: es })} -{" "}
                  {format(date.to, "dd MMM yy", { locale: es })}
                </>
              ) : (
                format(date.from, "dd MMM yy", { locale: es })
              )
            ) : (
              <span>Seleccionar periodo</span>
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent
          className="w-auto p-0"
          align="center"
          style={{
            backgroundColor: "white",
            border: "1px solid rgba(0,0,0,0.1)",
          }}
        >
          <div className="p-3 flex justify-between items-center border-b">
            <div className="text-sm font-medium flex items-center">
              <CalendarDays className="mr-2 h-4 w-4" />
              {selectionMode === "start"
                ? "Selecciona fecha de inicio"
                : selectionMode === "end"
                ? "Selecciona fecha de fin"
                : "Rango seleccionado"}
            </div>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button variant="ghost" size="icon" className="h-6 w-6">
                    <HelpCircle className="h-4 w-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Primero selecciona la fecha de inicio, luego la de fin.</p>
                  <p>
                    Las fechas se aplicarán al hacer clic en "Aplicar rango".
                  </p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>

          <div className="flex flex-wrap gap-1 p-3 border-b justify-between">
            {presets.map((preset) => (
              <Button
                key={preset.label}
                variant="outline"
                size="sm"
                className="text-xs flex-1 min-w-[110px]"
                onClick={() => handlePresetChange(preset.value)}
              >
                {preset.label}
              </Button>
            ))}
          </div>

          <div className="p-3">
            <div className="mb-1 text-xs text-muted-foreground">
              {selectionMode === "start"
                ? "Haz clic en una fecha para establecer el inicio"
                : selectionMode === "end"
                ? "Ahora selecciona la fecha de fin"
                : "Rango completo seleccionado"}
            </div>

            <style jsx global>{`
              .rdp-day_range_middle {
                background-color: rgba(220, 38, 38, 0.1) !important;
                position: relative;
                z-index: 1;
              }
              .rdp-day_range_middle::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(220, 38, 38, 0.1);
                z-index: -1;
              }
              .rdp-day_range_start {
                background-color: rgb(220, 38, 38) !important;
                color: white !important;
                font-weight: bold !important;
                border-radius: 50% !important;
                position: relative;
                z-index: 2;
              }
              .rdp-day_range_end {
                background-color: rgb(220, 38, 38) !important;
                color: white !important;
                font-weight: bold !important;
                border-radius: 50% !important;
                position: relative;
                z-index: 2;
              }
              .rdp-day_selected {
                background-color: rgb(220, 38, 38) !important;
                color: white !important;
              }
              .rdp-day_range_middle::after {
                content: "";
                position: absolute;
                height: 24px;
                top: 50%;
                transform: translateY(-50%);
                left: 0;
                right: 0;
                background-color: rgba(220, 38, 38, 0.1);
                z-index: -1;
              }
              .rdp-day:hover:not(.rdp-day_range_start):not(
                  .rdp-day_range_end
                ):not(.rdp-day_selected) {
                background-color: rgba(220, 38, 38, 0.05) !important;
                border-radius: 0 !important;
              }
            `}</style>

            <Calendar
              mode="range"
              defaultMonth={
                date?.from && isValid(date.from) ? date.from : new Date()
              }
              selected={date}
              onSelect={(newDateRange) => {
                if (newDateRange) {
                  setDate(newDateRange);
                  if (newDateRange.from && !newDateRange.to) {
                    setSelectionMode("end");
                  } else if (newDateRange.from && newDateRange.to) {
                    setSelectionMode("complete");
                  } else {
                    setSelectionMode("start");
                  }
                } else {
                  setDate(undefined);
                  setSelectionMode("start");
                }
              }}
              numberOfMonths={2}
              locale={es}
              className="bg-white"
              footer={
                <div className="pt-2 text-center border-t mt-2">
                  <div className="flex justify-between px-2 text-xs">
                    {date?.from && isValid(date.from) && (
                      <div className="flex flex-col items-start">
                        <span className="text-gray-500">Inicio:</span>
                        <span className="text-red-600 font-medium">
                          {format(date.from, "dd MMM yy", { locale: es })}
                        </span>
                      </div>
                    )}
                    {date?.to && isValid(date.to) && (
                      <div className="flex flex-col items-end">
                        <span className="text-gray-500">Fin:</span>
                        <span className="text-red-600 font-medium">
                          {format(date.to, "dd MMM yy", { locale: es })}
                        </span>
                      </div>
                    )}
                  </div>
                </div>
              }
            />
          </div>

          <div className="p-3 border-t bg-gray-50 flex gap-2 justify-between">
            <Button
              variant="outline"
              size="sm"
              className="w-1/2"
              onClick={resetSelection}
            >
              Reiniciar
            </Button>
            <Button
              size="sm"
              className="w-1/2 bg-red-600 hover:bg-red-700"
              onClick={applyRange}
              disabled={
                !date?.from ||
                !date?.to ||
                !isValid(date.from) ||
                !isValid(date.to)
              }
            >
              Aplicar rango
            </Button>
          </div>
        </PopoverContent>
      </Popover>
    </div>
  );
}


Ruta: components\dashboard\header.tsx
// components/dashboard/header.tsx
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Search, X, Menu } from "lucide-react";
import { cn } from "@/lib/utils";

interface HeaderProps {
  isMobileMenuOpen: boolean;
  setIsMobileMenuOpen: (open: boolean) => void;
  className?: string;
}

export function Header({
  isMobileMenuOpen,
  setIsMobileMenuOpen,
  className,
}: HeaderProps) {
  const [showMobileSearch, setShowMobileSearch] = useState(false);
  const [mounted, setMounted] = useState(false);

  // Evitar hidratación
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) return null;

  return (
    <header
      className={cn(
        "sticky top-0 z-50 w-full border-b border-border bg-primary text-primary-foreground backdrop-blur supports-[backdrop-filter]:bg-primary/95",
        className
      )}
    >
      <div className="px-6 flex h-14 w-full items-center">
        {/* Botón de menú móvil */}
        <Button
          variant="ghost"
          size="icon"
          className="lg:hidden hover:text-white hover:bg-primary-hover"
          onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
        >
          {isMobileMenuOpen ? (
            <X className="h-6 w-6" />
          ) : (
            <Menu className="h-6 w-6" />
          )}
          <span className="sr-only">Toggle menu</span>
        </Button>

        {/* Logo */}
        <Link
          href="/dashboard"
          className={cn(
            "flex items-between space-x-2 text-primary-foreground hover:text-white",
            showMobileSearch && "hidden md:flex"
          )}
        >
          <span className="font-bold">RG Electronica</span>
        </Link>
      </div>
    </header>
  );
}


Ruta: components\dashboard\integrations-list.tsx
import { Card } from "@/components/ui/card";

const integrations = [
  {
    name: "Stripe",
    type: "Finance",
    rate: 40,
    profit: "$650.00",
    icon: "💳",
  },
  {
    name: "Zapier",
    type: "CRM",
    rate: 80,
    profit: "$720.50",
    icon: "⚡",
  },
  {
    name: "Shopify",
    type: "Marketplace",
    rate: 20,
    profit: "$432.25",
    icon: "🛍️",
  },
];

export function IntegrationsList() {
  return (
    <Card className="p-6">
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-semibold">Lista de integraciones</h3>
        <button className="text-primary text-sm">Ver todo</button>
      </div>
      <div className="space-y-4">
        {integrations.map((integration) => (
          <div
            key={integration.name}
            className="flex items-center justify-between"
          >
            <div className="flex items-center space-x-3">
              <span className="text-2xl">{integration.icon}</span>
              <div>
                <h4 className="font-medium">{integration.name}</h4>
                <p className="text-sm text-gray-500">{integration.type}</p>
              </div>
            </div>
            <div className="text-right">
              <div className="font-medium">{integration.profit}</div>
              <div className="text-sm text-gray-500">{integration.rate}%</div>
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
}


Ruta: components\dashboard\mobile-menu.tsx
// components/dashboard/mobile-menu.tsx
"use client";

import { useState, useEffect } from "react";
import { Menu } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { Sidebar } from "./sidebar";

export function MobileMenu() {
  const [open, setOpen] = useState(false);

  // Cerrar el menú cuando la pantalla se hace más grande
  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth >= 1024) {
        setOpen(false);
      }
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <Button variant="ghost" size="icon" className="lg:hidden">
          <Menu className="h-6 w-6" />
          <span className="sr-only">Abrir menú</span>
        </Button>
      </SheetTrigger>
      <SheetContent
        side="left"
        className="w-[280px] p-0 max-w-[85vw] overflow-y-auto"
      >
        <SheetHeader>
          <SheetTitle className="px-6 py-4 text-lg font-semibold">
            Menú
          </SheetTitle>
        </SheetHeader>
        <Sidebar className="w-full" onItemClick={() => setOpen(false)} />
      </SheetContent>
    </Sheet>
  );
}


Ruta: components\dashboard\mobile-sidebar.tsx
"use client";

import { cn } from "@/lib/utils";
import { navigation } from "@/config/navigation";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useScrollLock } from "@/hooks/useScrollLock";
import { useSession, signOut } from "next-auth/react";
import { LogOut } from "lucide-react";
import { Button } from "@/components/ui/button";

interface MobileSidebarProps {
  isOpen: boolean;
  onClose: () => void;
  headerHeight?: string;
}

export function MobileSidebar({
  isOpen,
  onClose,
  headerHeight = "h-14",
}: MobileSidebarProps) {
  const pathname = usePathname();
  const { data: session } = useSession();

  // Usar nuestro hook personalizado
  useScrollLock(isOpen);

  const userRole = session?.user?.role || "WORKER";

  // Filtrar elementos según el rol del usuario
  const filteredNavigation = navigation
    .map((group) => {
      const items = group.items.filter((item) => {
        if (!item.requiredRole || item.requiredRole === "ALL") return true;
        if (Array.isArray(item.requiredRole)) {
          return item.requiredRole.includes(userRole);
        }
        return item.requiredRole === userRole;
      });
      return { ...group, items };
    })
    .filter((group) => group.items.length > 0);

  const handleSignOut = async () => {
    await signOut({ callbackUrl: "/login" });
    onClose();
  };

  return (
    <>
      {/* Overlay - solo se renderiza si isOpen es true */}
      {isOpen && (
        <div
          className={`fixed inset-0 z-40 bg-black/50 lg:hidden ${headerHeight}`}
          onClick={onClose}
        />
      )}

      {/* Sidebar Mobile Container - siempre se renderiza pero con diferente transformación */}
      <div
        className={cn(
          "fixed left-0 z-40 w-64 bg-background transform transition-transform duration-300 ease-in-out lg:hidden border-r border-border",
          "top-14 bottom-0", // Posicionamiento considerando el header
          isOpen ? "translate-x-0" : "-translate-x-full"
        )}
      >
        {/* Contenedor con scroll interno */}
        <div className="h-full flex flex-col">
          {/* Área de navegación scrolleable */}
          <div className="flex-1 overflow-y-auto">
            <nav className="px-3 py-4">
              {filteredNavigation.map((group) => (
                <div key={group.title} className="mb-6">
                  <h3 className="px-4 text-sm font-semibold text-content-subtle mb-2">
                    {group.title}
                  </h3>
                  <div className="space-y-1">
                    {group.items.map((item) => (
                      <Link
                        key={item.href}
                        href={item.href}
                        onClick={onClose}
                        className={cn(
                          "flex items-center gap-x-3 px-4 py-2 text-sm font-medium rounded-md",
                          "transition-colors duration-200",
                          pathname === item.href
                            ? "bg-accent text-primary"
                            : "text-content-subtle hover:bg-accent/50 hover:text-primary"
                        )}
                      >
                        <item.icon
                          className={cn(
                            "h-5 w-5 shrink-0",
                            pathname === item.href
                              ? "text-primary"
                              : "text-content-subtle"
                          )}
                        />
                        <span>{item.name}</span>
                        {item.badge && (
                          <span className="ml-auto flex h-5 w-5 items-center justify-center rounded-full bg-primary text-xs text-primary-foreground font-bold">
                            {item.badge}
                          </span>
                        )}
                      </Link>
                    ))}
                  </div>
                </div>
              ))}
            </nav>
          </div>

          {/* Botón de cerrar sesión */}
          <div className="mt-auto p-4 border-t border-border">
            <Button
              variant="ghost"
              className="w-full flex items-center justify-start text-content-subtle hover:bg-accent hover:text-error"
              onClick={handleSignOut}
            >
              <LogOut className="h-4 w-4 mr-2" />
              <span>Cerrar sesión</span>
            </Button>
          </div>
        </div>
      </div>
    </>
  );
}


Ruta: components\dashboard\recent-activity.tsx
interface Activity {
  id: string;
  type: string;
  description: string;
  date: string;
}

interface RecentActivityProps {
  activities: Activity[];
}

export function RecentActivity({ activities }: RecentActivityProps) {
  return (
    <div className="bg-background rounded-xl border border-border p-6">
      <h3 className="text-lg font-semibold text-content-emphasis mb-4">
        Actividad Reciente
      </h3>
      <div className="space-y-4">
        {activities.map((activity) => (
          <div key={activity.id} className="flex items-start space-x-3 text-sm">
            <div className="w-2 h-2 mt-1.5 rounded-full bg-primary" />
            <div>
              <p className="text-content">{activity.description}</p>
              <p className="text-content-subtle">{activity.date}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}


Ruta: components\dashboard\sales-distribution.tsx
import { Card } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

const salesData = [
  {
    source: "Website",
    amount: "$374.82",
    percentage: 45,
    color: "bg-primary",
  },
  {
    source: "Mobile App",
    amount: "$241.60",
    percentage: 30,
    color: "bg-secondary",
  },
  {
    source: "Other",
    amount: "$213.42",
    percentage: 25,
    color: "bg-accent",
  },
];

export function SalesDistribution() {
  return (
    <Card className="p-6">
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-semibold">Distribución de ventas</h3>
        <Select defaultValue="monthly">
          <SelectTrigger className="w-[140px]">
            <SelectValue placeholder="Seleccionar período" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="daily">Diario</SelectItem>
            <SelectItem value="weekly">Semanal</SelectItem>
            <SelectItem value="monthly">Mensual</SelectItem>
            <SelectItem value="yearly">Anual</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-6">
        {/* Gráfico circular */}
        <div className="relative aspect-square">
          <div className="absolute inset-0">
            <svg className="w-full h-full" viewBox="0 0 100 100">
              {salesData.map((item, index) => {
                const startAngle = salesData
                  .slice(0, index)
                  .reduce((acc, curr) => acc + curr.percentage, 0);
                const endAngle = startAngle + item.percentage;

                const x1 = 50 + 40 * Math.cos((startAngle / 100) * 2 * Math.PI);
                const y1 = 50 + 40 * Math.sin((startAngle / 100) * 2 * Math.PI);
                const x2 = 50 + 40 * Math.cos((endAngle / 100) * 2 * Math.PI);
                const y2 = 50 + 40 * Math.sin((endAngle / 100) * 2 * Math.PI);

                const largeArcFlag = item.percentage > 50 ? 1 : 0;

                return (
                  <path
                    key={item.source}
                    d={`M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArcFlag} 1 ${x2} ${y2} Z`}
                    className={item.color}
                    opacity={0.8}
                  />
                );
              })}
            </svg>
          </div>
        </div>

        {/* Leyenda y detalles */}
        <div className="space-y-4">
          {salesData.map((item) => (
            <div
              key={item.source}
              className="flex items-center justify-between"
            >
              <div className="flex items-center space-x-3">
                <div className={`w-3 h-3 rounded-full ${item.color}`}></div>
                <div>
                  <p className="font-medium">{item.source}</p>
                  <p className="text-sm text-gray-500">{item.percentage}%</p>
                </div>
              </div>
              <p className="font-medium">{item.amount}</p>
            </div>
          ))}
        </div>

        {/* Barra de progreso total */}
        <div className="pt-4 border-t">
          <div className="flex justify-between text-sm mb-2">
            <span className="text-gray-500">Progreso total</span>
            <span className="font-medium">78%</span>
          </div>
          <div className="h-2 bg-gray-100 rounded-full overflow-hidden">
            <div className="h-full bg-primary" style={{ width: "78%" }}></div>
          </div>
        </div>
      </div>
    </Card>
  );
}


Ruta: components\dashboard\sidebar.tsx
// components/dashboard/sidebar.tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { ChevronLeft, ChevronRight, LogOut } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useSession, signOut } from "next-auth/react";
import { navigation } from "@/config/navigation";

interface SidebarProps {
  className?: string;
  onItemClick?: () => void;
  isCollapsed?: boolean;
  toggleCollapse?: () => void;
}

export function Sidebar({
  className,
  onItemClick,
  isCollapsed,
  toggleCollapse,
}: SidebarProps) {
  const pathname = usePathname();
  const { data: session } = useSession();
  const userRole = session?.user?.role || "WORKER";

  // Filtrar elementos según propiedad requiredRole (si no se define se muestra a todos)
  const filteredNavigation = navigation
    .map((group) => {
      const items = group.items.filter((item) => {
        if (!item.requiredRole || item.requiredRole === "ALL") return true;
        if (Array.isArray(item.requiredRole)) {
          return item.requiredRole.includes(userRole);
        }
        return item.requiredRole === userRole;
      });
      return { ...group, items };
    })
    .filter((group) => group.items.length > 0);

  const handleSignOut = async () => {
    await signOut({ callbackUrl: "/login" });
  };

  return (
    <div
      className={cn(
        "h-full flex flex-col bg-background border-r border-border",
        className
      )}
    >
      <div className="hidden lg:flex justify-end p-2">
        <Button
          variant="ghost"
          size="icon"
          onClick={toggleCollapse}
          className="shrink-0 text-content-subtle hover:text-primary"
        >
          {isCollapsed ? (
            <ChevronRight className="h-4 w-4" />
          ) : (
            <ChevronLeft className="h-4 w-4" />
          )}
        </Button>
      </div>
      <nav className="flex-1 space-y-4 overflow-y-auto">
        {filteredNavigation.map((group) => (
          <div key={group.title} className="px-3">
            {!isCollapsed && (
              <h3 className="mb-2 px-4 text-sm font-semibold tracking-tight text-content-subtle">
                {group.title}
              </h3>
            )}
            <div className="space-y-1">
              {group.items.map((item) => (
                <Link
                  key={item.href}
                  href={item.href}
                  onClick={onItemClick}
                  className={cn(
                    "group flex items-center justify-between rounded-md px-3 py-2 text-sm font-medium transition-colors",
                    "hover:bg-accent hover:text-primary",
                    pathname === item.href
                      ? "bg-accent text-primary"
                      : "text-content-subtle",
                    "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
                    isCollapsed && "justify-center"
                  )}
                >
                  <div className="flex items-center gap-x-3">
                    <item.icon
                      className={cn(
                        "h-4 w-4 shrink-0",
                        pathname === item.href
                          ? "text-primary"
                          : "text-content-subtle group-hover:text-primary"
                      )}
                    />
                    {!isCollapsed && <span>{item.name}</span>}
                  </div>
                  {!isCollapsed && item.badge && (
                    <span className="ml-auto flex h-5 w-5 items-center justify-center rounded-full bg-primary text-xs text-primary-foreground font-bold">
                      {item.badge}
                    </span>
                  )}
                </Link>
              ))}
            </div>
          </div>
        ))}
      </nav>

      {/* Botón de cerrar sesión */}
      <div className="mt-auto p-3 border-t border-border">
        <Button
          variant="ghost"
          className={cn(
            "w-full flex items-center justify-start text-content-subtle hover:bg-accent hover:text-error",
            isCollapsed && "justify-center"
          )}
          onClick={handleSignOut}
        >
          <LogOut className="h-4 w-4 shrink-0 mr-2" />
          {!isCollapsed && <span>Cerrar sesión</span>}
        </Button>
      </div>
    </div>
  );
}


Ruta: components\dashboard\stats-card.tsx
// components/dashboard/stats-card.tsx
import { Card } from "@/components/ui/card";
import { ArrowUpIcon, ArrowDownIcon } from "lucide-react";
import { LucideIcon } from "lucide-react";

interface StatsCardProps {
  title: string;
  value: string;
  change: string;
  trend: "up" | "down";
  icon: LucideIcon;
}

export function StatsCard({
  title,
  value,
  change,
  trend,
  icon: Icon,
}: StatsCardProps) {
  return (
    <Card className="p-6 hover:shadow-md transition-shadow duration-200">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <div className="p-2 bg-primary/10 rounded-lg">
            <Icon className="h-5 w-5 text-primary" />
          </div>
          <h3 className="text-sm font-medium text-content-subtle">{title}</h3>
        </div>
      </div>
      <div className="mt-4">
        <div className="text-2xl font-semibold">{value}</div>
        <div className="flex items-center mt-1">
          {trend === "up" ? (
            <ArrowUpIcon className="h-4 w-4 text-green-500" />
          ) : (
            <ArrowDownIcon className="h-4 w-4 text-error" />
          )}
          <span className={trend === "up" ? "text-green-500" : "text-error"}>
            {change}
          </span>
        </div>
      </div>
    </Card>
  );
}


Ruta: components\error-boundary.tsx
"use client";

import React, { Component, ReactNode, ErrorInfo } from "react";
import { Button } from "@/components/ui/button";
import { AlertCircle, RefreshCw, Home } from "lucide-react";
import { logError } from "@/lib/errorHandler";
import Link from "next/link";

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

/**
 * Componente de límite de error que captura errores en la interfaz de usuario
 * y muestra un mensaje de error amigable en lugar de romper la aplicación
 */
export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    // Actualizar el estado para mostrar la UI de error
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Registrar el error para análisis
    logError({ type: 'component_error', message: error.message, details: errorInfo, timestamp: Date.now(), handled: false });
    
    // Guardar el error e información para mostrar en la interfaz
    this.setState({ errorInfo });
  }

  handleReload = (): void => {
    // Recargar la página actual
    window.location.reload();
  };

  render(): ReactNode {
    if (this.state.hasError) {
      // Si se ha proporcionado un fallback personalizado, usarlo
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // UI de error predeterminada
      return (
        <div className="min-h-screen flex flex-col items-center justify-center p-4 bg-background text-content">
          <div className="max-w-md w-full p-6 bg-white rounded-lg shadow-lg border border-error/20">
            <div className="flex items-center justify-center w-16 h-16 mx-auto mb-4 rounded-full bg-error/10">
              <AlertCircle className="w-8 h-8 text-error" />
            </div>
            
            <h2 className="text-2xl font-bold text-center mb-4">Algo salió mal</h2>
            
            <p className="text-content-subtle text-center mb-6">
              Ha ocurrido un error inesperado. Nuestro equipo ha sido notificado y 
              estamos trabajando para solucionarlo lo antes posible.
            </p>
            
            {process.env.NODE_ENV !== 'production' && this.state.error && (
              <div className="mb-6 p-4 bg-gray-100 rounded overflow-auto text-sm">
                <p className="font-mono font-bold text-error">{this.state.error.toString()}</p>
                {this.state.errorInfo && (
                  <pre className="mt-2 text-xs text-content-subtle whitespace-pre-wrap">
                    {this.state.errorInfo.componentStack}
                  </pre>
                )}
              </div>
            )}
            
            <div className="flex flex-col sm:flex-row gap-2 justify-center">
              <Button 
                onClick={this.handleReload}
                className="flex items-center justify-center"
              >
                <RefreshCw className="w-4 h-4 mr-2" />
                Reintentar
              </Button>
              
              <Link href="/dashboard" passHref>
                <Button 
                  variant="outline"
                  className="flex items-center justify-center"
                >
                  <Home className="w-4 h-4 mr-2" />
                  Ir al inicio
                </Button>
              </Link>
            </div>
          </div>
        </div>
      );
    }

    // Si no hay error, renderizar los hijos normalmente
    return this.props.children;
  }
}

/**
 * Componente de error para páginas específicas
 */
export function PageErrorComponent({ 
  error, 
  reset 
}: { 
  error: Error; 
  reset: () => void;
}) {
  // Registrar el error
  React.useEffect(() => {
    logError({ type: 'page_error', message: error.message, details: error.stack, timestamp: Date.now(), handled: false });
  }, [error]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center p-4 bg-background text-content">
      <div className="max-w-md w-full p-6 bg-white rounded-lg shadow-lg border border-error/20">
        <div className="flex items-center justify-center w-16 h-16 mx-auto mb-4 rounded-full bg-error/10">
          <AlertCircle className="w-8 h-8 text-error" />
        </div>
        
        <h2 className="text-2xl font-bold text-center mb-4">Error al cargar la página</h2>
        
        <p className="text-content-subtle text-center mb-6">
          No pudimos cargar esta página. Por favor, intenta nuevamente o vuelve al inicio.
        </p>
        
        {process.env.NODE_ENV !== 'production' && (
          <div className="mb-6 p-4 bg-gray-100 rounded overflow-auto text-sm">
            <p className="font-mono font-bold text-error">{error.message}</p>
            <pre className="mt-2 text-xs text-content-subtle whitespace-pre-wrap">
              {error.stack}
            </pre>
          </div>
        )}
        
        <div className="flex flex-col sm:flex-row gap-2 justify-center">
          <Button 
            onClick={reset}
            className="flex items-center justify-center"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Reintentar
          </Button>
          
          <Link href="/dashboard" passHref>
            <Button 
              variant="outline"
              className="flex items-center justify-center"
            >
              <Home className="w-4 h-4 mr-2" />
              Ir al inicio
            </Button>
          </Link>
        </div>
      </div>
    </div>
  );
}

Ruta: components\error-provider.tsx
"use client";

import React, {
  createContext,
  useContext,
  ReactNode,
  useState,
  useCallback,
} from "react";
import { useNotification } from "@/contexts/NotificationContext";
import {
  logError,
  ErrorType,
  createAppError,
  AppError,
} from "@/lib/errorHandler";

// Definir la estructura del contexto de manejo de errores
interface ErrorContextType {
  // Registrar y mostrar un error genérico
  reportError: (
    error: Error | string | unknown,
    showNotification?: boolean
  ) => void;

  // Registrar y mostrar un error de API
  reportApiError: (error: any, customMessage?: string) => void;

  // Registrar y mostrar un error de validación
  reportValidationError: (message: string) => void;

  // Registrar y mostrar un error de autenticación
  reportAuthError: (message?: string) => void;

  // Obtener información del último error
  lastError: AppError | null;

  // Limpiar el último error
  clearLastError: () => void;
}

// Crear el contexto
const ErrorContext = createContext<ErrorContextType | undefined>(undefined);

/**
 * Proveedor para gestión centralizada de errores
 */
export function ErrorProvider({ children }: { children: ReactNode }) {
  const { addNotification } = useNotification();
  const [lastError, setLastError] = useState<AppError | null>(null);

  /**
   * Registra y muestra un error genérico
   */
  const reportError = useCallback(
    (error: Error | string | unknown, showNotification = true) => {
      const appError = createAppError(error);
      logError(appError);
      setLastError(appError);

      if (showNotification) {
        addNotification("error", appError.message);
      }

      return appError;
    },
    [addNotification]
  );

  /**
   * Registra y muestra un error de API
   */
  const reportApiError = useCallback(
    (error: any, customMessage?: string) => {
      let statusCode: number | undefined;
      let errorMessage = customMessage;

      // Extraer código de estado y mensaje si proviene de una respuesta fetch
      if (error.status || error.statusCode) {
        statusCode = error.status || error.statusCode;
      }

      if (!errorMessage) {
        if (error.message) {
          errorMessage = error.message;
        } else if (error.data && error.data.message) {
          errorMessage = error.data.message;
        }
      }

      const appError = createAppError(error, errorMessage, statusCode);
      logError(appError);
      setLastError(appError);
      addNotification("error", appError.message);

      return appError;
    },
    [addNotification]
  );

  /**
   * Registra y muestra un error de validación
   */
  const reportValidationError = useCallback(
    (message: string) => {
      const appError = createAppError(
        ErrorType.VALIDATION_INVALID_FORMAT,
        message
      );
      logError(appError);
      setLastError(appError);
      addNotification("error", message);

      return appError;
    },
    [addNotification]
  );

  /**
   * Registra y muestra un error de autenticación
   */
  const reportAuthError = useCallback(
    (message?: string) => {
      const appError = createAppError(
        ErrorType.AUTH_SESSION_EXPIRED,
        message || "Tu sesión ha expirado. Por favor, inicia sesión nuevamente."
      );
      logError(appError);
      setLastError(appError);
      addNotification("error", appError.message);

      return appError;
    },
    [addNotification]
  );

  /**
   * Limpia el último error
   */
  const clearLastError = useCallback(() => {
    setLastError(null);
  }, []);

  // Valor del contexto
  const contextValue: ErrorContextType = {
    reportError,
    reportApiError,
    reportValidationError,
    reportAuthError,
    lastError,
    clearLastError,
  };

  return (
    <ErrorContext.Provider value={contextValue}>
      {children}
    </ErrorContext.Provider>
  );
}

/**
 * Hook para usar el contexto de errores
 */
export function useError() {
  const context = useContext(ErrorContext);

  if (context === undefined) {
    throw new Error("useError debe ser usado dentro de un ErrorProvider");
  }

  return context;
}


Ruta: components\products\ProductForm.tsx
import { FormField, FormLabel, FormDescription } from "@/components/ui/form";
import { Product } from "@/services/products";
import { EntityForm } from "@/components/ui/entity-form";
import { Edit, Upload } from "lucide-react";
import { Input } from "@/components/ui/input";
import { formatCurrency } from "@/utils/number-format";
import { Button } from "@/components/ui/button";

interface ProductFormProps {
  currentProduct: Product | null;
  formData: {
    name: string;
    description: string;
    unitPrice: string;
    markup: string;
    imageUrl: string;
  };
  setFormData: React.Dispatch<
    React.SetStateAction<{
      name: string;
      description: string;
      unitPrice: string;
      markup: string;
      imageUrl: string;
    }>
  >;
  onSave: () => boolean | Promise<boolean>;
  onCancel: () => void;
  onUploadImage: (e: React.ChangeEvent<HTMLInputElement>) => Promise<void>;
  fileInputRef: React.RefObject<HTMLInputElement>;
  isUploading: boolean;
  isSubmitting?: boolean;
  error?: string | null;
}

export default function ProductForm({
  currentProduct,
  formData,
  setFormData,
  onSave,
  onCancel,
  onUploadImage,
  fileInputRef,
  isUploading,
  isSubmitting = false,
  error = null,
}: ProductFormProps) {
  // Calcular el precio final en tiempo real
  const unitPrice = parseFloat(formData.unitPrice) || 0;
  const markup = parseFloat(formData.markup) || 0;
  const markupAmount = Math.ceil((unitPrice * markup) / 100);
  const finalPrice = unitPrice + markupAmount;

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    e.stopPropagation(); // Muy importante para evitar la propagación
    onSave();
    return false; // Prevenir comportamiento por defecto
  };

  // Input oculto para cargar imágenes
  const fileInput = (
    <input
      type="file"
      ref={fileInputRef}
      onChange={onUploadImage}
      accept="image/*"
      style={{ display: "none" }}
    />
  );

  return (
    <EntityForm
      isOpen={true}
      onClose={(e) => {
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        onCancel();
      }}
      onSubmit={handleSubmit}
      title={currentProduct ? "Editar Producto" : "Agregar Producto"}
      isLoading={isSubmitting}
      error={error}
      maxWidth="max-w-md"
      preventClose={true} // Esto previene el cierre accidental
    >
      {fileInput}

      <FormField>
        <FormLabel>Nombre</FormLabel>
        <Input
          value={formData.name}
          onChange={(e) => setFormData({ ...formData, name: e.target.value })}
          required
        />
      </FormField>

      <FormField>
        <FormLabel>Descripción</FormLabel>
        <Input
          value={formData.description}
          onChange={(e) =>
            setFormData({ ...formData, description: e.target.value })
          }
        />
      </FormField>

      <div className="grid grid-cols-2 gap-4">
        <FormField>
          <FormLabel>Precio unitario</FormLabel>
          <Input
            type="number"
            step="1"
            min="0"
            value={formData.unitPrice}
            onChange={(e) =>
              setFormData({ ...formData, unitPrice: e.target.value })
            }
            required
          />
          <FormDescription>Precio base/proveedor</FormDescription>
        </FormField>

        <FormField>
          <FormLabel>Ganancia (%)</FormLabel>
          <Input
            type="number"
            step="0.1"
            min="0"
            value={formData.markup}
            onChange={(e) =>
              setFormData({ ...formData, markup: e.target.value })
            }
            required
          />
          <FormDescription>Porcentaje sobre el precio unitario</FormDescription>
        </FormField>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <FormField>
          <FormLabel>Ganancia ($)</FormLabel>
          <Input type="text" value={formatCurrency(markupAmount)} disabled />
          <FormDescription>Monto de ganancia</FormDescription>
        </FormField>

        <FormField>
          <FormLabel>Precio final</FormLabel>
          <Input type="text" value={formatCurrency(finalPrice)} disabled />
          <FormDescription>Precio de venta</FormDescription>
        </FormField>
      </div>

      <FormField>
        <FormLabel>Imagen</FormLabel>
        <div className="flex flex-col gap-4">
          {formData.imageUrl && (
            <div className="relative w-full h-32 bg-gray-100 rounded-md overflow-hidden">
              <img
                src={formData.imageUrl}
                alt="Vista previa del producto"
                className="w-full h-full object-contain"
              />
            </div>
          )}
          <Button
            type="button"
            variant="outline"
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              fileInputRef.current?.click();
            }}
            disabled={isUploading}
            className="w-full"
          >
            {isUploading ? (
              "Subiendo..."
            ) : formData.imageUrl ? (
              <>
                <Edit className="mr-2 h-4 w-4" />
                Cambiar imagen
              </>
            ) : (
              <>
                <Upload className="mr-2 h-4 w-4" />
                Subir imagen
              </>
            )}
          </Button>
        </div>
      </FormField>
    </EntityForm>
  );
}


Ruta: components\quotes\CategoryForm.tsx
// web\components\quotes\CategoryForm.tsx
import { useState, useEffect, useRef } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel } from "@/components/ui/form";
import { Trash, Plus, ChevronDown, ChevronUp } from "lucide-react";
import { QuotationCategory, QuotationItem } from "@/services/quotations";
import { Product, createProduct } from "@/services/products";
import { formatCurrency, roundUp } from "@/utils/number-format";
import ProductForm from "@/components/products/ProductForm";
import { useNotification } from "@/contexts/NotificationContext";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface CategoryFormProps {
  category: QuotationCategory;
  categoryIndex: number;
  products: Product[];
  onUpdateCategoryName: (index: number, name: string) => void;
  onRemoveCategory: (index: number) => void;
  onAddItem: (categoryIndex: number) => void;
  onRemoveItem: (categoryIndex: number, itemIndex: number) => void;
  onUpdateItem: (
    categoryIndex: number,
    itemIndex: number,
    field: keyof QuotationItem,
    value: any
  ) => void;
  onAddNewProduct: (product: Product) => void;
  disabled?: boolean;
}

export default function CategoryForm({
  category,
  categoryIndex,
  products,
  onUpdateCategoryName,
  onRemoveCategory,
  onAddItem,
  onRemoveItem,
  onUpdateItem,
  onAddNewProduct,
  disabled = false,
}: CategoryFormProps) {
  // Estado para controlar la expansión/colapso de la categoría en móvil
  const [isExpanded, setIsExpanded] = useState(true);
  const { addNotification } = useNotification();
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Estados para el formulario de crear producto
  const [isNewProductDialogOpen, setIsNewProductDialogOpen] = useState(false);
  const [isCreatingProduct, setIsCreatingProduct] = useState(false);
  const [productFormError, setProductFormError] = useState<string | null>(null);
  const [itemIndexForNewProduct, setItemIndexForNewProduct] = useState<
    number | null
  >(null);

  // Estado local para seguimiento de productos
  const [localProducts, setLocalProducts] = useState<Product[]>([...products]);

  // Formulario de producto
  const [formData, setFormData] = useState({
    name: "",
    description: "",
    unitPrice: "",
    markup: "35",
    imageUrl: "",
  });

  // Actualizamos los productos locales cuando cambia la prop products
  useEffect(() => {
    setLocalProducts([...products]);
  }, [products]);

  // Calcular el total de la categoría
  const calculateCategoryTotal = (): number => {
    return roundUp(
      category.items.reduce((total, item) => {
        // Verificar si el producto existe
        if (!item.product) return total;

        const unitPrice = item.product.unitPrice || 0;
        const markup = item.product.markup || 35;

        // Calcular el precio final correctamente
        const markupAmount = Math.ceil((unitPrice * markup) / 100);
        const finalPrice = unitPrice + markupAmount;

        return total + finalPrice * (item.quantity || 1);
      }, 0)
    );
  };
  // Verificar si hay elementos en la categoría
  const hasItems = category.items.length > 0;

  // Función para manejar la creación de un nuevo producto
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];

    try {
      // Mostrar vista previa de la imagen inmediatamente
      const reader = new FileReader();
      reader.onload = (event) => {
        if (event.target && event.target.result) {
          setFormData({
            ...formData,
            imageUrl: event.target.result.toString(),
          });
        }
      };
      reader.readAsDataURL(file);
    } catch (error) {
      console.error("Error al previsualizar la imagen:", error);
    }
  };

  const handleSaveProduct = async () => {
    if (!formData.name || !formData.unitPrice) {
      setProductFormError("Nombre y precio son obligatorios");
      return false;
    }

    if (itemIndexForNewProduct === null) {
      setProductFormError("Error interno: No se ha especificado un ítem");
      return false;
    }

    try {
      setIsCreatingProduct(true);

      // Asegurarse de que el precio sea un número entero
      const unitPrice = Math.floor(parseFloat(formData.unitPrice));
      const markup = parseFloat(formData.markup);

      // Calcular el precio final con el markup
      const markupAmount = Math.ceil((unitPrice * markup) / 100);
      const finalPrice = unitPrice + markupAmount;

      // Crear un FormData para poder enviar la imagen como archivo
      const productFormData = new FormData();
      productFormData.append("name", formData.name);
      productFormData.append("description", formData.description || "");
      productFormData.append("unitPrice", unitPrice.toString());
      productFormData.append("markup", markup.toString());
      productFormData.append("price", finalPrice.toString());

      // Si hay una imagen en formato base64, convertirla a blob y adjuntarla
      if (formData.imageUrl && formData.imageUrl.startsWith("data:image")) {
        // Convertir base64 a Blob
        const blob = await fetch(formData.imageUrl).then((r) => r.blob());

        // Crear un archivo a partir del blob
        const imageFile = new File([blob], "product-image.png", {
          type: "image/png",
        });

        // Añadir el archivo al FormData
        productFormData.append("image", imageFile);
      }

      // Usar el servicio createProduct con FormData
      const result = await createProduct(productFormData);

      // Agregar el nuevo producto a la lista global de productos
      const newProduct = result.product;

      // Primero actualizamos nuestra lista local de productos para la UI inmediata
      const updatedProducts = [...localProducts, newProduct];
      setLocalProducts(updatedProducts);

      // Muy importante: Llamar a onAddNewProduct para actualizar el estado del padre
      onAddNewProduct(newProduct);

      // Actualizar el ítem seleccionado con el nuevo producto
      onUpdateItem(
        categoryIndex,
        itemIndexForNewProduct,
        "productId",
        newProduct.id
      );
      onUpdateItem(
        categoryIndex,
        itemIndexForNewProduct,
        "price",
        newProduct.price
      );
      onUpdateItem(
        categoryIndex,
        itemIndexForNewProduct,
        "product",
        newProduct
      );

      // Mostrar notificación de éxito
      addNotification("success", "Producto creado correctamente");

      // Cerrar el diálogo y resetear el formulario
      setIsNewProductDialogOpen(false);
      setFormData({
        name: "",
        description: "",
        unitPrice: "",
        markup: "35",
        imageUrl: "",
      });
      setProductFormError(null);
      setItemIndexForNewProduct(null);

      return true;
    } catch (err) {
      console.error("Error al crear producto:", err);
      setProductFormError("Error al crear el producto");
      addNotification("error", "Error al crear el producto");
      return false;
    } finally {
      setIsCreatingProduct(false);
    }
  };

  // Método para cerrar el diálogo de producto
  const handleCloseProductDialog = () => {
    setIsNewProductDialogOpen(false);
    setItemIndexForNewProduct(null);
    setProductFormError(null);
  };

  return (
    <Card className="p-3">
      {/* Cabecera de la categoría con nombre y controles */}
      <div className="flex flex-col sm:flex-row sm:items-center gap-2 mb-3">
        <div className="flex items-center flex-1">
          {/* Botón para expandir/colapsar en móvil */}
          <Button
            type="button"
            variant="ghost"
            size="sm"
            className="p-1 mr-2 sm:hidden"
            onClick={() => setIsExpanded(!isExpanded)}
            disabled={disabled}
          >
            {isExpanded ? (
              <ChevronUp className="h-5 w-5" />
            ) : (
              <ChevronDown className="h-5 w-5" />
            )}
          </Button>

          <FormField className="flex-grow">
            <FormLabel className="hidden sm:block">
              Nombre de Categoría
            </FormLabel>
            <Input
              value={category.name}
              onChange={(e) =>
                onUpdateCategoryName(categoryIndex, e.target.value)
              }
              placeholder="Ej: Servicios, Productos, etc."
              className="text-sm"
              required
              disabled={disabled}
            />
          </FormField>
        </div>

        <div className="flex items-center justify-between sm:justify-end gap-2">
          {/* Total de la categoría siempre visible */}
          {/* <div className="bg-primary/10 px-3 py-1 rounded text-sm">
            <span className="hidden sm:inline">Total de la categoría: </span>
            <span className="font-medium">
              {formatCurrency(calculateCategoryTotal())}
            </span>
          </div> */}

          {/* Botón para eliminar categoría */}
          <Button
            type="button"
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0 mt-0 sm:mt-6"
            onClick={() => onRemoveCategory(categoryIndex)}
            disabled={disabled}
          >
            <Trash className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Contenido de la categoría (productos) - colapsable en móvil */}
      <div className={`space-y-3 ${isExpanded ? "block" : "hidden sm:block"}`}>
        {/* Lista de productos */}
        {category.items.map((item, itemIndex) => {
          console.log("item", item);
          return (
            <div
              key={`item-${categoryIndex}-${itemIndex}`}
              className={
                !item.productId || item.productId === 0
                  ? "border border-red-300 rounded-md p-2 bg-red-50"
                  : ""
              }
            >
              {(!item.productId || item.productId === 0) && (
                <p className="text-red-500 text-xs mb-2">
                  ⚠️ Seleccione un producto o elimine esta fila
                </p>
              )}
              <div className="border rounded-md p-3 mb-3 bg-white shadow-sm">
                {/* Cabecera de la fila del producto con botón de eliminar */}
                <div className="flex justify-between items-center mb-2">
                  <h4 className="text-sm font-medium">
                    Producto {itemIndex + 1}
                  </h4>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    className="h-8 w-8 p-0"
                    onClick={() => onRemoveItem(categoryIndex, itemIndex)}
                    disabled={disabled}
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </div>

                {/* Selector de producto */}
                <div className="mb-3">
                  <FormLabel className="text-xs">
                    Producto{" "}
                    {(!item.productId || item.productId === 0) && (
                      <span className="text-red-500 text-xs ml-1">
                        *Requerido
                      </span>
                    )}
                  </FormLabel>
                  <Select
                    value={item.productId ? item.productId.toString() : "0"}
                    onValueChange={(value) => {
                      if (value === "new") {
                        // Abrir diálogo para crear producto
                        setItemIndexForNewProduct(itemIndex);
                        setIsNewProductDialogOpen(true);
                      } else {
                        const productId = parseInt(value);
                        // Importante: Usar localProducts para buscar el producto
                        const selectedProduct = localProducts.find(
                          (p) => p.id === productId
                        );
                        onUpdateItem(
                          categoryIndex,
                          itemIndex,
                          "productId",
                          productId
                        );

                        if (selectedProduct) {
                          // Asegurar que el precio no tenga decimales
                          const priceWithoutDecimals = Math.floor(
                            selectedProduct.price || 0
                          );
                          onUpdateItem(
                            categoryIndex,
                            itemIndex,
                            "price",
                            priceWithoutDecimals
                          );
                          onUpdateItem(
                            categoryIndex,
                            itemIndex,
                            "product",
                            selectedProduct
                          );
                        }
                      }
                    }}
                    className={
                      !item.productId || item.productId === 0
                        ? "border-red-300"
                        : ""
                    }
                    disabled={disabled}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="Seleccionar producto" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="new">
                        <div className="flex items-center">
                          <Plus className="h-4 w-4 mr-2" />
                          Crear nuevo producto
                        </div>
                      </SelectItem>
                      {/* Usamos la lista local para que se actualice inmediatamente */}
                      {localProducts.map((product) => (
                        <SelectItem
                          key={product.id}
                          value={product.id?.toString() || ""}
                        >
                          {product.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {(!item.productId || item.productId === 0) && (
                    <p className="text-red-500 text-xs mt-1">
                      Por favor, seleccione un producto
                    </p>
                  )}
                </div>

                {/* Campos para cantidad y precio */}
                <div className="grid grid-cols-2 md:grid-cols-6 gap-2 mb-2">
                  {/* Cantidad */}
                  <div>
                    <FormLabel className="text-xs">Cantidad</FormLabel>
                    <Input
                      type="number"
                      min="1"
                      value={item.quantity || 1}
                      onChange={(e) => {
                        const value = parseInt(e.target.value) || 1;
                        onUpdateItem(
                          categoryIndex,
                          itemIndex,
                          "quantity",
                          value
                        );
                      }}
                      className="h-9"
                      required
                      disabled={disabled}
                    />
                  </div>

                  {/* Precio proveedor */}
                  <div>
                    <FormLabel className="text-xs">Proveedor</FormLabel>
                    <Input
                      type="number"
                      min="0"
                      value={item.product ? item.product.unitPrice || 0 : 0}
                      onChange={(e) => {
                        const value = parseInt(e.target.value) || 0;
                        onUpdateItem(categoryIndex, itemIndex, "price", value);
                      }}
                      className="h-9"
                      placeholder="Solo números enteros"
                      required
                      disabled={disabled}
                    />
                  </div>

                  {/* % Ganancia */}
                  <div className="col-span-1 md:col-span-1">
                    <FormLabel className="text-xs">% Ganancia</FormLabel>
                    <Input
                      value={`${
                        item.product ? item.product.markup || 35 : 35
                      }%`}
                      className="h-9 bg-gray-50"
                      readOnly
                      disabled
                    />
                  </div>

                  {/* Ganancia */}
                  <div className="col-span-1 md:col-span-1">
                    <FormLabel className="text-xs">Ganancia</FormLabel>
                    <Input
                      value={formatCurrency(
                        Math.ceil(
                          ((item.product ? item.product.unitPrice || 0 : 0) *
                            (item.product ? item.product.markup || 35 : 35)) /
                            100
                        )
                      )}
                      className="h-9 bg-gray-50"
                      readOnly
                      disabled
                    />
                  </div>

                  {/* Precio */}
                  <div className="col-span-1 md:col-span-1">
                    <FormLabel className="text-xs">Precio</FormLabel>
                    <Input
                      value={formatCurrency(
                        (item.product ? item.product.unitPrice || 0 : 0) +
                          Math.ceil(
                            ((item.product ? item.product.unitPrice || 0 : 0) *
                              (item.product ? item.product.markup || 35 : 35)) /
                              100
                          )
                      )}
                      className="h-9 bg-gray-50"
                      readOnly
                      disabled
                    />
                  </div>

                  {/* Total */}
                  <div className="col-span-1 md:col-span-1">
                    <FormLabel className="text-xs">Total</FormLabel>
                    <Input
                      value={formatCurrency(
                        ((item.product ? item.product.unitPrice || 0 : 0) +
                          Math.ceil(
                            ((item.product ? item.product.unitPrice || 0 : 0) *
                              (item.product ? item.product.markup || 35 : 35)) /
                              100
                          )) *
                          (item.quantity || 1)
                      )}
                      className="h-9 bg-gray-50 font-medium"
                      readOnly
                      disabled
                    />
                  </div>
                </div>
              </div>
            </div>
          );
        })}

        {/* Mensaje cuando no hay productos */}
        {!hasItems && (
          <div className="text-sm text-muted-foreground text-center py-3">
            No hay productos en esta categoría
          </div>
        )}

        {/* Botón para agregar productos */}
        <Button
          type="button"
          variant="outline"
          size="sm"
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            onAddItem(categoryIndex);
          }}
          className="w-full sm:w-auto mt-2"
          disabled={disabled}
        >
          <Plus className="h-4 w-4 mr-2" />
          Agregar Producto
        </Button>
      </div>

      {/* Modal para crear nuevo producto utilizando ProductForm */}
      {isNewProductDialogOpen && (
        <div onClick={(e) => e.stopPropagation()}>
          <ProductForm
            currentProduct={null}
            formData={formData}
            setFormData={setFormData}
            onSave={handleSaveProduct}
            onCancel={handleCloseProductDialog}
            onUploadImage={handleImageUpload}
            fileInputRef={fileInputRef}
            isUploading={false}
            isSubmitting={isCreatingProduct}
            error={productFormError}
          />
        </div>
      )}

      {/* Input oculto para subir archivos */}
      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        accept="image/*"
        onChange={handleImageUpload}
      />
    </Card>
  );
}


Ruta: components\quotes\ClientForm.tsx
// web\components\quotes\ClientForm.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel } from "@/components/ui/form";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Client, createClient } from "@/services/clients";

interface ClientFormProps {
  isOpen: boolean;
  onClose: () => void;
  onClientCreated: (client: Client) => void;
}

export default function ClientForm({
  isOpen,
  onClose,
  onClientCreated,
}: ClientFormProps) {
  const [newClient, setNewClient] = useState<Client>({
    name: "",
    email: "",
    phone: "",
    address: "",
    notes: "",
  });
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreateClient = async () => {
    if (!newClient.name || !newClient.email) {
      setError("El nombre y email son obligatorios");
      return;
    }

    try {
      setIsCreating(true);
      const createdClient = await createClient(newClient);

      console.log("Cliente creado en el backend:", createdClient);

      // Verificar que el cliente tenga un ID válido
      if (!createdClient || !createdClient.id) {
        throw new Error("El servidor no devolvió un ID válido para el cliente");
      }

      // Asegurarse de que el cliente tenga el tipo correcto
      const clientWithCorrectId = {
        ...createdClient,
        id: createdClient.id.toString(),
      };

      onClientCreated(clientWithCorrectId);
      resetForm();
    } catch (err) {
      console.error("Error al crear cliente:", err);
      setError("Error al crear el cliente. Por favor, intenta de nuevo.");
    } finally {
      setIsCreating(false);
    }
  };

  const resetForm = () => {
    setNewClient({
      name: "",
      email: "",
      phone: "",
      address: "",
      notes: "",
    });
    setError(null);
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        if (!open) {
          resetForm();
          onClose();
        }
      }}
    >
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Crear Nuevo Cliente</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <FormField>
            <FormLabel>Nombre *</FormLabel>
            <Input
              value={newClient.name}
              onChange={(e) =>
                setNewClient({ ...newClient, name: e.target.value })
              }
              placeholder="Nombre del cliente"
              required
            />
          </FormField>

          <FormField>
            <FormLabel>Email *</FormLabel>
            <Input
              type="email"
              value={newClient.email}
              onChange={(e) =>
                setNewClient({ ...newClient, email: e.target.value })
              }
              placeholder="Email del cliente"
              required
            />
          </FormField>

          <FormField>
            <FormLabel>Teléfono</FormLabel>
            <Input
              value={newClient.phone || ""}
              onChange={(e) =>
                setNewClient({ ...newClient, phone: e.target.value })
              }
              placeholder="Teléfono"
            />
          </FormField>

          <FormField>
            <FormLabel>Dirección</FormLabel>
            <Input
              value={newClient.address || ""}
              onChange={(e) =>
                setNewClient({ ...newClient, address: e.target.value })
              }
              placeholder="Dirección"
            />
          </FormField>

          <FormField>
            <FormLabel>Notas</FormLabel>
            <Input
              value={newClient.notes || ""}
              onChange={(e) =>
                setNewClient({ ...newClient, notes: e.target.value })
              }
              placeholder="Notas adicionales"
            />
          </FormField>

          {error && <div className="text-red-500 text-sm">{error}</div>}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isCreating}>
            Cancelar
          </Button>
          <Button onClick={handleCreateClient} disabled={isCreating}>
            {isCreating ? "Creando..." : "Crear Cliente"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\quotes\QuotationForm.tsx
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel } from "@/components/ui/form";
import { Plus, Loader2, Save } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  type QuotationCategory,
  type QuotationItem,
  type Quotation,
  createQuotation,
  updateQuotation,
} from "@/services/quotations";
import { getClients, Client } from "@/services/clients";
import { getProducts, Product } from "@/services/products";
import CategoryForm from "./CategoryForm";
import ClientForm from "./ClientForm";
import { formatCurrency, roundUp } from "@/utils/number-format";
import { Skeleton } from "@/components/ui/skeleton";
import { AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface QuotationFormProps {
  quotation: Quotation | null;
  onSave: () => void;
  onCancel: () => void;
  statusOptions: Array<{ value: string; label: string; icon: React.ReactNode }>;
}

// Constante para el IVA (19%)
const IVA_RATE = 0.19;

export default function QuotationForm({
  quotation,
  onSave,
  onCancel,
  statusOptions,
}: QuotationFormProps) {
  const [title, setTitle] = useState(quotation?.title || "");
  const [description, setDescription] = useState(quotation?.description || "");
  const [clientId, setClientId] = useState<string>(
    quotation?.clientId?.toString() || ""
  );
  const [status, setStatus] = useState(quotation?.status || "SENT");
  // Estado para el porcentaje de abono, con valor predeterminado de 50% si no está definido
  const [advancePercentage, setAdvancePercentage] = useState<number>(
    quotation?.advancePercentage !== undefined
      ? quotation.advancePercentage
      : 50
  );
  const [validUntil, setValidUntil] = useState(
    quotation?.validUntil
      ? new Date(quotation.validUntil).toISOString().split("T")[0]
      : ""
  );
  const [categories, setCategories] = useState<QuotationCategory[]>(
    quotation?.categories || [{ name: "General", items: [] }]
  );
  const [clients, setClients] = useState<Client[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [isNewClientDialogOpen, setIsNewClientDialogOpen] = useState(false);
  const [loadingClients, setLoadingClients] = useState(false);
  const [loadingProducts, setLoadingProducts] = useState(false);
  const [savingProgress, setSavingProgress] = useState(0);

  // Al montar el componente, cargar los datos necesarios para el formulario
  useEffect(() => {
    const fetchFormData = async () => {
      try {
        setIsLoading(true);
        setLoadingClients(true);
        setLoadingProducts(true);

        // Cargar clientes y productos en paralelo
        const clientsPromise = getClients()
          .then((data) => {
            setClients(data);
            setLoadingClients(false);
            return data;
          })
          .catch((error) => {
            console.error("Error al cargar clientes:", error);
            setError("Error al cargar los clientes");
            setLoadingClients(false);
            return [];
          });

        const productsPromise = getProducts()
          .then((data) => {
            setProducts(data);
            setLoadingProducts(false);
            return data;
          })
          .catch((error) => {
            console.error("Error al cargar productos:", error);
            setError("Error al cargar los productos");
            setLoadingProducts(false);
            return [];
          });

        await Promise.all([clientsPromise, productsPromise]);
        setError(null);
      } catch (err) {
        console.error("Error loading form data:", err);
        setError("Error al cargar los datos del formulario");
      } finally {
        setIsLoading(false);
      }
    };

    fetchFormData();
  }, []);

  const addCategory = () => {
    setCategories([...categories, { name: "", items: [] }]);
  };

  const removeCategory = (index: number) => {
    setCategories(categories.filter((_, i) => i !== index));
  };

  const updateCategoryName = (index: number, name: string) => {
    const newCategories = [...categories];
    newCategories[index].name = name;
    setCategories(newCategories);
  };

  const addItem = (categoryIndex: number) => {
    const newCategories = [...categories];
    newCategories[categoryIndex].items.push({
      productId: 0,
      quantity: 1,
      price: 0,
      product: null,
    });
    setCategories(newCategories);
  };

  const removeItem = (categoryIndex: number, itemIndex: number) => {
    const newCategories = [...categories];
    newCategories[categoryIndex].items.splice(itemIndex, 1);
    setCategories(newCategories);
  };

  const updateItem = (
    categoryIndex: number,
    itemIndex: number,
    field: keyof QuotationItem,
    value: any
  ) => {
    const newCategories = [...categories];

    // Verificar que las categorías y sus items existen
    if (
      !newCategories[categoryIndex] ||
      !newCategories[categoryIndex].items ||
      !newCategories[categoryIndex].items[itemIndex]
    ) {
      console.error("Índices inválidos:", {
        categoryIndex,
        itemIndex,
        categories: newCategories,
      });
      return;
    }

    // Actualizar el campo específico del item
    // @ts-ignore: Field assignment is dynamic
    newCategories[categoryIndex].items[itemIndex][field] = value;

    // Si se actualiza el productId, también actualizamos el precio y el objeto product
    if (field === "productId" && value) {
      const product = products.find((p) => p.id === value);
      if (product) {
        newCategories[categoryIndex].items[itemIndex].price = product.price;
        newCategories[categoryIndex].items[itemIndex].product = product;
      }
    }

    setCategories(newCategories);
  };

  const handleAddNewProduct = (product: Product) => {
    // Verificar que no exista ya un producto con el mismo ID
    if (!products.some((p) => p.id === product.id)) {
      // Usar una función de actualización para garantizar el estado más reciente
      setProducts((prevProducts) => [...prevProducts, product]);
      console.log(`Producto agregado a la lista: ${product.name}`);
    } else {
      console.log(`Producto ya existe en la lista: ${product.name}`);
    }
  };

  const handleAddNewClient = (client: Client) => {
    // Asegurarse de que el cliente tenga un ID
    if (!client.id) {
      console.error("Cliente creado sin ID:", client);
      setError("Error al crear el cliente: no se recibió un ID válido");
      return;
    }

    // Agregar el cliente a la lista local solo si no existe ya
    if (!clients.some((c) => c.id === client.id)) {
      setClients((prevClients) => [...prevClients, client]);
    }

    // Seleccionar el cliente recién creado
    setClientId(client.id.toString());

    // Cerrar el diálogo
    setIsNewClientDialogOpen(false);
  };

  // Manejar el cambio en el campo de porcentaje de abono
  const handleAdvancePercentageChange = (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    // Obtener el valor como número
    const value = parseInt(e.target.value);

    // Validar que el valor esté entre 0 y 100
    if (!isNaN(value) && value >= 0 && value <= 100) {
      setAdvancePercentage(value);
    }
  };

  const calculateQuotationTotal = (): number => {
    return categories.reduce((total, category) => {
      return (
        total +
        category.items.reduce((categoryTotal, item) => {
          // Verificamos que exista un producto asociado
          if (!item.product && !item.productId) return categoryTotal;

          // Obtenemos el precio unitario (del proveedor)
          const unitPrice = item.product ? item.product.unitPrice || 0 : 0;

          // Obtenemos el porcentaje de markup
          const markup = item.product ? item.product.markup || 35 : 35;

          // Calculamos el monto del markup (la ganancia) por unidad
          const markupAmount = Math.ceil((unitPrice * markup) / 100);

          // Calculamos el precio final por unidad
          const finalPrice = unitPrice + markupAmount;

          // Multiplicamos por la cantidad y sumamos al total de la categoría
          return categoryTotal + finalPrice * item.quantity;
        }, 0)
      );
    }, 0);
  };

  const calculateQuotationTotalRevenue = (): number => {
    return categories.reduce((total, category) => {
      return (
        total +
        category.items.reduce((categoryTotal, item) => {
          // Verificamos que exista un producto asociado
          if (!item.product) {
            return categoryTotal;
          }

          // Obtenemos el unitPrice y el markup del producto
          const unitPrice = item.product.unitPrice || 0;
          const markupPercentage = item.product.markup || 0;

          // Calculamos el monto del markup (la ganancia) por unidad
          const markupAmount = Math.round((unitPrice * markupPercentage) / 100);

          // Multiplicamos por la cantidad y sumamos al total de la categoría
          return categoryTotal + markupAmount * item.quantity;
        }, 0)
      );
    }, 0);
  };
  // Calcular el IVA (19%)
  const calculateIVA = (): number => {
    const subtotal = calculateQuotationTotal();
    return Math.round(subtotal * IVA_RATE);
  };

  // Calcular el total con IVA
  const calculateTotalWithIVA = (): number => {
    const subtotal = calculateQuotationTotal();
    const iva = calculateIVA();
    return subtotal + iva;
  };

  // Calcular el monto de abono según el porcentaje de abono y el total con IVA
  const calculateAdvanceAmount = (): number => {
    return Math.round((calculateTotalWithIVA() * advancePercentage) / 100);
  };

  // Calcular el saldo pendiente (total con IVA menos abono)
  const calculateRemainingAmount = (): number => {
    return calculateTotalWithIVA() - calculateAdvanceAmount();
  };

  // Simulación del progreso de guardado
  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (isSaving && savingProgress < 95) {
      interval = setInterval(() => {
        setSavingProgress((prev) => {
          const increment = (95 - prev) * 0.2;
          return Math.min(prev + increment, 95);
        });
      }, 300);
    }

    return () => clearInterval(interval);
  }, [isSaving, savingProgress]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!clientId || clientId === "new") {
      setError("Debe seleccionar un cliente");
      return;
    }

    // Filtrar las categorías que no tienen productos válidos seleccionados
    const validCategories = categories.map((category) => ({
      ...category,
      items: category.items.filter(
        (item) => item.productId && item.productId !== 0
      ),
    }));

    if (
      validCategories.length === 0 ||
      validCategories.some((cat) => cat.items.length === 0)
    ) {
      setError("Debe agregar al menos un producto válido a la cotización");
      return;
    }

    const client = clients.find((c) => c.id?.toString() === clientId);

    if (!client) {
      setError("Cliente no encontrado");
      console.error("Cliente no encontrado con ID:", clientId);
      console.log("Clientes disponibles:", clients);
      return;
    }

    try {
      setIsSaving(true);
      setSavingProgress(10);

      // Asegurarnos de que clientId sea un número válido
      const clientIdNum = parseInt(clientId);
      if (isNaN(clientIdNum)) {
        setError(`ID de cliente inválido: ${clientId}`);
        setIsSaving(false);
        setSavingProgress(0);
        return;
      }

      // Asegurarse de que todos los items tengan sus productos correctamente asociados
      // y filtrar los items con productId = 0 (no seleccionados)
      const processedCategories = categories.map((category) => ({
        ...category,
        items: category.items
          .filter((item) => item.productId && item.productId !== 0) // Filtrar items sin producto seleccionado
          .map((item) => {
            // Si tiene productId pero no tiene el objeto product, intentar buscarlo
            if (
              item.productId &&
              (!item.product || item.product.id !== item.productId)
            ) {
              const product = products.find((p) => p.id === item.productId);
              if (product) {
                return {
                  ...item,
                  product,
                  price: item.price || product.price,
                };
              }
            }
            return item;
          }),
      }));

      setSavingProgress(30);

      const quotationData: Quotation = {
        id: quotation?.id,
        clientId: clientIdNum,
        title,
        description,
        status,
        validUntil: validUntil || undefined,
        advancePercentage: advancePercentage, // Incluir el porcentaje de abono
        categories: processedCategories,
        client: {
          id: clientId,
          name: client.name,
          email: client.email || "",
        },
      };

      setSavingProgress(50);

      if (quotation?.id) {
        // Actualizar cotización existente
        await updateQuotation(quotation.id, quotationData);
      } else {
        // Crear nueva cotización
        await createQuotation(quotationData);
      }

      setSavingProgress(100);
      setTimeout(() => {
        onSave();
      }, 500); // Pequeña pausa para mostrar el 100% del progreso
    } catch (err) {
      console.error("Error al guardar la cotización:", err);
      setError("Error al guardar la cotización");
      setSavingProgress(0);
    } finally {
      if (!error) {
        // Solo resetear si no hay error
        setIsSaving(false);
      }
    }
  };

  // Renderizar un loader de carga inicial
  if (isLoading && loadingClients && loadingProducts) {
    return (
      <Dialog open onOpenChange={() => onCancel()}>
        <DialogContent>
          <div className="space-y-4 py-6">
            <div className="flex justify-center">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
            <p className="text-center text-muted-foreground">
              Cargando datos del formulario...
            </p>
          </div>
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <Dialog
      open
      onOpenChange={(open) => {
        if (!open && !isSaving) onCancel();
      }}
    >
      <DialogContent className="max-w-7xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {quotation ? "Editar Cotización" : "Nueva Cotización"}
          </DialogTitle>
        </DialogHeader>

        {/* Barra de progreso de guardado */}
        {isSaving && (
          <div className="h-1 w-full bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-primary transition-all duration-300 ease-in-out"
              style={{ width: `${savingProgress}%` }}
            />
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Sección de información básica */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField>
              <FormLabel>Título</FormLabel>
              <Input
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
                disabled={isSaving}
              />
            </FormField>

            <FormField>
              <FormLabel>Cliente</FormLabel>
              <div className="flex space-x-2">
                {loadingClients ? (
                  <Skeleton className="h-10 w-full" />
                ) : (
                  <Select
                    value={clientId}
                    onValueChange={(value) => {
                      setClientId(value);
                      if (value === "new") {
                        setIsNewClientDialogOpen(true);
                      }
                    }}
                    disabled={isSaving}
                  >
                    <SelectTrigger className="flex-grow">
                      <SelectValue placeholder="Seleccionar cliente" />
                    </SelectTrigger>
                    <SelectContent
                      className="max-h-[300px] overflow-y-auto"
                      style={{ maxHeight: "300px", overflowY: "auto" }}
                    >
                      <SelectItem value="new">
                        <div className="flex items-center">
                          <Plus className="h-4 w-4 mr-2" />
                          Crear nuevo cliente
                        </div>
                      </SelectItem>
                      {clients.length > 0 ? (
                        <>
                          <div className="px-2 py-1 text-xs text-gray-500 border-b border-gray-100">
                            Clientes ({clients.length})
                          </div>
                          {clients.map((client) => (
                            <SelectItem
                              key={client.id}
                              value={client.id?.toString() || ""}
                            >
                              {client.name}
                            </SelectItem>
                          ))}
                        </>
                      ) : (
                        <SelectItem value="empty" disabled>
                          No hay clientes disponibles
                        </SelectItem>
                      )}
                    </SelectContent>
                  </Select>
                )}
              </div>
            </FormField>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <FormField>
              <FormLabel>Descripción</FormLabel>
              <Input
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                disabled={isSaving}
              />
            </FormField>

            <FormField>
              <FormLabel>Válido hasta</FormLabel>
              <Input
                type="date"
                value={validUntil}
                onChange={(e) => setValidUntil(e.target.value)}
                disabled={isSaving}
              />
            </FormField>

            {/* Nuevo campo para el porcentaje de abono */}
            <FormField>
              <FormLabel>Porcentaje de Abono (%)</FormLabel>
              <Input
                type="number"
                min="0"
                max="100"
                value={advancePercentage}
                onChange={handleAdvancePercentageChange}
                disabled={isSaving}
                className="w-full"
              />
            </FormField>
          </div>

          {quotation && (
            <FormField>
              <FormLabel>Estado</FormLabel>
              <Select
                value={status}
                onValueChange={setStatus}
                disabled={isSaving}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Seleccionar estado" />
                </SelectTrigger>
                <SelectContent>
                  {statusOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      <div className="flex items-center">
                        {option.icon}
                        {option.label}
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </FormField>
          )}

          {/* Sección de Categorías */}
          <div className="space-y-4">
            {loadingProducts ? (
              <div className="space-y-4">
                <Skeleton className="h-20 w-full" />
                <Skeleton className="h-20 w-full" />
              </div>
            ) : (
              categories.map((category, categoryIndex) => (
                <CategoryForm
                  key={`category-${categoryIndex}`}
                  category={category}
                  categoryIndex={categoryIndex}
                  products={products}
                  onUpdateCategoryName={updateCategoryName}
                  onRemoveCategory={removeCategory}
                  onAddItem={addItem}
                  onRemoveItem={removeItem}
                  onUpdateItem={updateItem}
                  onAddNewProduct={handleAddNewProduct}
                  disabled={isSaving}
                />
              ))
            )}

            {/* Encabezado de productos y servicios con botón para agregar categoría */}
            <div className="flex justify-between items-center mt-6">
              <h3 className="text-lg font-medium">Productos y Servicios</h3>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={addCategory}
                className="flex items-center"
                disabled={isSaving || loadingProducts}
              >
                <Plus className="h-4 w-4 mr-2" />
                <span className="hidden sm:inline">Agregar Categoría</span>
                <span className="sm:hidden">Categoría</span>
              </Button>
            </div>

            {/* Resumen financiero - Responsive para móvil */}
            <div className="mt-6 grid grid-cols-1 md:grid-cols-3 gap-2">
              <div className="bg-green-600/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">Total ganancia:</span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(
                      calculateQuotationTotalRevenue().toFixed(2)
                    )}
                  </span>
                </div>
              </div>

              <div className="bg-blue-600/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">Subtotal:</span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(calculateQuotationTotal().toFixed(2))}
                  </span>
                </div>
              </div>

              <div className="bg-amber-600/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">IVA (19%):</span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(calculateIVA().toFixed(2))}
                  </span>
                </div>
              </div>

              <div className="bg-primary/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">Total con IVA:</span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(calculateTotalWithIVA().toFixed(2))}
                  </span>
                </div>
              </div>

              {/* Nuevo - Monto de abono */}
              <div className="bg-purple-600/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">
                    Abono ({advancePercentage}%):
                  </span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(calculateAdvanceAmount().toFixed(2))}
                  </span>
                </div>
              </div>

              {/* Nuevo - Saldo pendiente */}
              <div className="bg-pink-600/10 p-3 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm md:text-base">Saldo pendiente:</span>
                  <span className="text-base md:text-lg font-bold">
                    {formatCurrency(calculateRemainingAmount().toFixed(2))}
                  </span>
                </div>
              </div>
            </div>
          </div>

          {error && (
            <Alert variant="destructive" className="mt-4 animate-fadeIn">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {/* Botones de acción - Stack en móvil, inline en desktop */}
          <DialogFooter className="flex flex-col sm:flex-row gap-2 sm:justify-end">
            <Button
              variant="outline"
              type="button"
              onClick={onCancel}
              className="w-full sm:w-auto"
              disabled={isSaving}
            >
              Cancelar
            </Button>
            <Button
              type="submit"
              disabled={isSaving || loadingClients || loadingProducts}
              className="w-full sm:w-auto"
            >
              {isSaving ? (
                <span className="flex items-center">
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  {savingProgress < 50 ? "Procesando..." : "Guardando..."}
                </span>
              ) : (
                <span className="flex items-center">
                  <Save className="mr-2 h-4 w-4" />
                  {quotation ? "Guardar Cambios" : "Crear Cotización"}
                </span>
              )}
            </Button>
          </DialogFooter>
        </form>

        {/* Diálogo para crear nuevo cliente */}
        <ClientForm
          isOpen={isNewClientDialogOpen || clientId === "new"}
          onClose={() => {
            setIsNewClientDialogOpen(false);
            if (clientId === "new") {
              setClientId("");
            }
          }}
          onClientCreated={handleAddNewClient}
        />
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\quotes\QuotationInfo.tsx
import { useState, useEffect } from "react";
import { Quotation, getQuotationById } from "@/services/quotations";
import { Button } from "@/components/ui/button";
import { ExternalLink, ChevronDown, ChevronUp } from "lucide-react";
import { formatNumber } from "@/utils/number-format";
import { useNotification } from "@/contexts/NotificationContext";

interface QuotationInfoProps {
  quotationId: number;
}

export default function QuotationInfo({ quotationId }: QuotationInfoProps) {
  const [quotation, setQuotation] = useState<Quotation | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isExpanded, setIsExpanded] = useState(false);
  const { addNotification } = useNotification();

  useEffect(() => {
    const fetchQuotation = async () => {
      setIsLoading(true);
      try {
        const data = await getQuotationById(quotationId.toString());
        setQuotation(data);
      } catch (error) {
        console.error("Error al cargar los detalles de la cotización:", error);
        addNotification("error", "Error al cargar detalles de la cotización");
      } finally {
        setIsLoading(false);
      }
    };

    if (quotationId) {
      fetchQuotation();
    }
  }, [quotationId, addNotification]);

  // Si está cargando o no hay cotización, mostrar un placeholder
  if (isLoading) {
    return (
      <div className="border border-border rounded-md p-4 mb-4 animate-pulse">
        <div className="h-5 w-2/3 bg-muted rounded mb-3"></div>
        <div className="h-4 w-1/2 bg-muted rounded mb-2"></div>
        <div className="h-4 w-1/3 bg-muted rounded"></div>
      </div>
    );
  }

  if (!quotation) {
    return null;
  }

  return (
    <div className="border border-border rounded-md p-4 mb-4 bg-muted/30">
      <div className="flex justify-between items-center mb-2">
        <h3 className="font-medium text-lg">Información de la Cotización</h3>
        <div className="flex gap-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setIsExpanded(!isExpanded)}
          >
            {isExpanded ? (
              <ChevronUp className="h-4 w-4" />
            ) : (
              <ChevronDown className="h-4 w-4" />
            )}
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() =>
              window.open(`/dashboard/quotations/${quotationId}`, "_blank")
            }
          >
            <ExternalLink className="h-4 w-4" />
          </Button>
        </div>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between">
          <span className="text-sm font-medium">Título:</span>
          <span className="text-sm">{quotation.title}</span>
        </div>

        {quotation.description && (
          <div className="flex justify-between">
            <span className="text-sm font-medium">Descripción:</span>
            <span className="text-sm">{quotation.description}</span>
          </div>
        )}

        <div className="flex justify-between">
          <span className="text-sm font-medium">Monto Total:</span>
          <span className="text-sm">${formatNumber(quotation.amount)}</span>
        </div>

        {quotation.validUntil && (
          <div className="flex justify-between">
            <span className="text-sm font-medium">Válida hasta:</span>
            <span className="text-sm">
              {new Date(quotation.validUntil).toLocaleDateString()}
            </span>
          </div>
        )}

        <div className="flex justify-between">
          <span className="text-sm font-medium">Cliente:</span>
          <span className="text-sm">{quotation.client?.name}</span>
        </div>
      </div>

      {isExpanded &&
        quotation.categories &&
        quotation.categories.length > 0 && (
          <div className="mt-4 border-t border-border pt-3">
            <h4 className="font-medium mb-2">Categorías y Productos</h4>
            <div className="space-y-3">
              {quotation.categories.map((category) => (
                <div key={category.id} className="bg-background/70 p-2 rounded">
                  <h5 className="font-medium text-sm">{category.name}</h5>
                  {category.items && category.items.length > 0 ? (
                    <table className="w-full text-sm mt-1">
                      <thead className="text-xs text-muted-foreground">
                        <tr>
                          <th className="text-left p-1">Producto</th>
                          <th className="text-right p-1">Cant.</th>
                          <th className="text-right p-1">Precio</th>
                          <th className="text-right p-1">Total</th>
                        </tr>
                      </thead>
                      <tbody>
                        {category.items.map((item) => (
                          <tr key={item.id}>
                            <td className="p-1">{item.product.name}</td>
                            <td className="text-right p-1">{item.quantity}</td>
                            <td className="text-right p-1">
                              ${formatNumber(item.price)}
                            </td>
                            <td className="text-right p-1">
                              ${formatNumber(item.total)}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  ) : (
                    <p className="text-xs text-muted-foreground mt-1">
                      Sin productos
                    </p>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
    </div>
  );
}


Ruta: components\quotes\QuotationsTable.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import {
  Edit,
  Trash,
  FileText,
  Download,
  User,
  Calendar,
  ChevronLeft,
  ChevronRight,
  Mail,
  Loader2,
  Percent,
} from "lucide-react";
import {
  downloadQuotationPDF,
  sendQuotationEmail,
  type Quotation,
  type QuotationsParams,
} from "@/services/quotations";
import { useNotification } from "@/contexts/NotificationContext";
import { Badge } from "../ui/badge";
import { formatCurrency, roundUp } from "@/utils/number-format";
import { ConfirmDialog } from "@/components/ui/confirm-dialog";
import { Skeleton } from "@/components/ui/skeleton";

interface QuotationsTableProps {
  quotations: Quotation[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  } | null;
  isLoading: boolean;
  filters: QuotationsParams;
  searchTerm: string;
  statusOptions: Array<{ value: string; label: string; icon: React.ReactNode }>;
  onEdit: (quotation: Quotation) => void;
  onDelete: (quotation: Quotation) => void;
  onPageChange: (page: number) => void;
  onStatusChange: (quotationId: string, newStatus: string) => void;
}

export default function QuotationsTable({
  quotations,
  pagination,
  isLoading,
  searchTerm,
  statusOptions,
  onEdit,
  onDelete,
  onPageChange,
  onStatusChange,
}: QuotationsTableProps) {
  const [isDownloading, setIsDownloading] = useState<string | null>(null);
  const [isSendingEmail, setIsSendingEmail] = useState<string | null>(null);
  const [emailDialogOpen, setEmailDialogOpen] = useState(false);
  const [selectedQuotationId, setSelectedQuotationId] = useState<string | null>(
    null
  );
  const [selectedQuotation, setSelectedQuotation] = useState<Quotation | null>(
    null
  );
  const { addNotification } = useNotification();

  // Calcular el total de una cotización
  const calculateTotal = (quotation: Quotation): number => {
    return roundUp(
      quotation.categories.reduce((categoryTotal, category) => {
        return (
          categoryTotal +
          category.items.reduce((itemTotal, item) => {
            const price = item.price || (item.product ? item.product.price : 0);
            const finalPrice = Math.ceil(price + price * 0.35); // Añadir ganancia del 35%
            return itemTotal + finalPrice * item.quantity;
          }, 0)
        );
      }, 0)
    );
  };

  const handleDownloadPDF = async (id: string) => {
    try {
      setIsDownloading(id);
      const blob = await downloadQuotationPDF(id);

      // Crear un enlace para descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `cotizacion-${id}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      addNotification("success", "PDF descargado correctamente");
    } catch (err) {
      console.error("Error al descargar el PDF:", err);
      addNotification("error", "Error al descargar el PDF");
    } finally {
      setTimeout(() => {
        setIsDownloading(null);
      }, 500); // Pequeña pausa para mostrar el estado de éxito
    }
  };

  const handleEmailButtonClick = (quotation: Quotation) => {
    if (quotation.id) {
      setSelectedQuotationId(quotation.id);
      setSelectedQuotation(quotation);
      setEmailDialogOpen(true);
    }
  };

  const handleSendEmail = async () => {
    if (!selectedQuotationId) return;

    try {
      setIsSendingEmail(selectedQuotationId);
      await sendQuotationEmail(selectedQuotationId);
      addNotification("success", "Correo enviado correctamente");
    } catch (err) {
      console.error("Error al enviar el correo:", err);
      addNotification("error", "Error al enviar el correo");
      throw err; // Re-lanzar el error para que el diálogo siga abierto
    } finally {
      setTimeout(() => {
        setIsSendingEmail(null);
        setSelectedQuotationId(null);
        setSelectedQuotation(null);
      }, 500); // Pequeña pausa para mostrar el estado de éxito
    }
  };

  const getStatusBadge = (status?: string) => {
    switch (status) {
      case "SENT":
        return <Badge variant="primary">Enviada</Badge>;
      case "APPROVED":
        return <Badge variant="success">Aprobada</Badge>;
      case "REJECTED":
        return <Badge variant="destructive">Rechazada</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  // Columnas para el DataTable
  const columns: ColumnDef<Quotation>[] = [
    {
      id: "title",
      header: "Título",
      cell: ({ row }) => (
        <div className="flex items-center">
          <div>
            <p className="font-medium">{row.original.title}</p>
            {row.original.description && (
              <p className="text-sm text-content-subtle">
                {row.original.description.length > 50
                  ? `${row.original.description.substring(0, 50)}...`
                  : row.original.description}
              </p>
            )}
          </div>
        </div>
      ),
    },
    {
      id: "client",
      header: "Cliente",
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <User className="h-4 w-4 text-content-subtle" />
          <span>{row.original.client.name}</span>
        </div>
      ),
    },
    {
      id: "status",
      header: "Estado",
      cell: ({ row }) => getStatusBadge(row.original.status),
    },
    {
      id: "advancePercentage",
      header: "% Abono",
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <Percent className="h-4 w-4 text-content-subtle" />
          <span>
            {row.original.advancePercentage !== undefined
              ? `${row.original.advancePercentage}%`
              : "50%"}
          </span>
        </div>
      ),
    },
    {
      id: "validUntil",
      header: "Válido hasta",
      cell: ({ row }) => {
        if (!row.original.validUntil) return <span>-</span>;
        return (
          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-content-subtle" />
            <span>
              {new Date(row.original.validUntil).toLocaleDateString()}
            </span>
          </div>
        );
      },
    },
    {
      id: "total",
      header: "Total",
      cell: ({ row }) => {
        const total = calculateTotal(row.original);
        return <span className="font-medium">{formatCurrency(total)}</span>;
      },
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onEdit(row.original)}
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() =>
              row.original.id && handleDownloadPDF(row.original.id)
            }
            disabled={!!isDownloading}
            className="relative"
          >
            {isDownloading === row.original.id ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Download className="h-4 w-4" />
            )}
            {isDownloading === row.original.id && (
              <span className="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 rounded-md">
                <Loader2 className="h-4 w-4 animate-spin text-primary" />
              </span>
            )}
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => handleEmailButtonClick(row.original)}
            disabled={!!isSendingEmail}
            className="relative"
          >
            {isSendingEmail === row.original.id ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Mail className="h-4 w-4" />
            )}
            {isSendingEmail === row.original.id && (
              <span className="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 rounded-md">
                <Loader2 className="h-4 w-4 animate-spin text-primary" />
              </span>
            )}
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onDelete(row.original)}
          >
            <Trash className="h-4 w-4" />
          </Button>
        </div>
      ),
    },
  ];

  if (isLoading) {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <Skeleton className="h-8 w-40" />
          <Skeleton className="h-10 w-32" />
        </div>
        <div className="space-y-2">
          {[1, 2, 3, 4, 5].map((i) => (
            <Skeleton key={i} className="h-16 w-full" />
          ))}
        </div>
      </div>
    );
  }

  if (quotations.length === 0) {
    return (
      <div className="text-center h-60 flex flex-col items-center justify-center">
        <FileText className="h-12 w-12 text-gray-300 mb-4" />
        <p className="text-lg font-medium text-gray-600">No hay cotizaciones</p>
        <p className="text-sm text-gray-500 mt-1">
          {searchTerm
            ? "No se encontraron resultados para tu búsqueda"
            : "Crea tu primera cotización haciendo clic en 'Nueva Cotización'"}
        </p>
      </div>
    );
  }

  return (
    <>
      <DataTable columns={columns} data={quotations} />

      {pagination && (
        <div className="flex items-center justify-between mt-4 pt-2 border-t">
          <div className="text-sm text-gray-500">
            Mostrando {(pagination.page - 1) * pagination.limit + 1} -{" "}
            {Math.min(pagination.page * pagination.limit, pagination.total)} de{" "}
            {pagination.total} cotizaciones
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page - 1)}
              disabled={!pagination.hasPrevPage}
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <span className="text-sm">
              Página {pagination.page} de {pagination.totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page + 1)}
              disabled={!pagination.hasNextPage}
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}

      {/* Diálogo de confirmación para enviar email */}
      {selectedQuotation && (
        <ConfirmDialog
          open={emailDialogOpen}
          onOpenChange={setEmailDialogOpen}
          title="Enviar cotización por correo"
          description={`¿Estás seguro de enviar la cotización "${selectedQuotation.title}" por correo electrónico a ${selectedQuotation.client.name}? Se adjuntará un PDF con los detalles de la cotización.`}
          onConfirm={handleSendEmail}
          confirmLabel="Enviar correo"
          cancelLabel="Cancelar"
          isLoading={isSendingEmail === selectedQuotationId}
        />
      )}
    </>
  );
}


Ruta: components\session-provider.tsx
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}


Ruta: components\tasks\DownloadTaskReportButton.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { FileText, Download, Loader2 } from "lucide-react";
import { downloadTaskReport } from "@/services/tasks";
import { useNotification } from "@/contexts/NotificationContext";

interface DownloadTaskReportButtonProps {
  taskId: number | string;
  variant?: "default" | "outline" | "ghost" | "link";
  size?: "default" | "sm" | "lg" | "icon";
  className?: string;
  showIcon?: boolean;
  label?: string;
}

export default function DownloadTaskReportButton({
  taskId,
  variant = "outline",
  size = "sm",
  className,
  showIcon = true,
  label = "Descargar Informe",
}: DownloadTaskReportButtonProps) {
  const [isDownloading, setIsDownloading] = useState(false);
  const { addNotification } = useNotification();

  const handleDownload = async () => {
    try {
      setIsDownloading(true);
      const blob = await downloadTaskReport(taskId.toString());

      // Crear un enlace para descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `InformeTecnico-${taskId}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      addNotification("success", "Informe descargado correctamente");
    } catch (error) {
      console.error("Error al descargar el informe:", error);
      addNotification("error", "Error al descargar el informe técnico");
    } finally {
      setIsDownloading(false);
    }
  };

  return (
    <Button
      variant={variant}
      size={size}
      onClick={handleDownload}
      disabled={isDownloading}
      className={className}
    >
      {isDownloading ? (
        <>
          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
          Descargando...
        </>
      ) : (
        <>
          {showIcon && <FileText className="h-4 w-4 mr-2" />}
          {label}
        </>
      )}
    </Button>
  );
}


Ruta: components\tasks\FinalizeTaskForm.tsx
import { useState, useEffect, useRef } from "react";
import { FormField, FormLabel, FormDescription } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { FormTextarea } from "@/components/ui/form-textarea";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Task, FinalizeTaskData } from "@/services/tasks";
import { uploadTaskImage, compressImage, blobToFile } from "@/services/uploads";
import { formatNumber } from "@/utils/number-format";
import { getTodayISOString } from "@/utils/date-format";
import {
  Loader2,
  CheckCircle2,
  Upload,
  Edit,
  Plus,
  X,
  Image,
  Camera,
  Users,
} from "lucide-react";

interface FinalizeTaskFormProps {
  isOpen: boolean;
  task: Task | null;
  onSave: (data: FinalizeTaskData) => Promise<void>;
  onClose: () => void;
  isLoading?: boolean;
}

export default function FinalizeTaskForm({
  isOpen,
  task,
  onSave,
  onClose,
  isLoading = false,
}: FinalizeTaskFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [validationError, setValidationError] = useState<string | null>(null);
  const [finalizeForm, setFinalizeForm] = useState<FinalizeTaskData>({
    taskId: 0,
    technicalReport: "",
    observations: "",
    hoursWorked: 1,
    mediaUrls: [],
    nameWhoReceives: "",
    positionWhoReceives: "",
    imageUrlWhoReceives: "",
    endDate: getTodayISOString(),
    technicians: [],
  });
  const [progress, setProgress] = useState(0);
  const [isUploadingWhoReceives, setIsUploadingWhoReceives] = useState(false);
  const [isUploadingWork, setIsUploadingWork] = useState(false);
  const fileInputWhoReceivesRef = useRef<HTMLInputElement>(null);
  const fileInputWorkRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (task?.id) {
      // Extraer nombres de técnicos de los asignados a la tarea
      const technicians = task.assignedWorkers
        ? task.assignedWorkers.map((assignment) => assignment.worker.name)
        : [];

      setFinalizeForm({
        taskId: task.id,
        technicalReport: task.technicalReport || "",
        observations: task.observations || "",
        hoursWorked: task.hoursWorked || 1,
        mediaUrls: task.mediaUrls || [],
        nameWhoReceives: "",
        positionWhoReceives: "",
        imageUrlWhoReceives: "",
        endDate: getTodayISOString(),
        technicians: technicians, // Agregar lista de técnicos asignados
      });
    }
    setValidationError(null);
  }, [task, isOpen]);

  // Simulación de progreso durante el guardado
  useEffect(() => {
    if (isSubmitting) {
      const interval = setInterval(() => {
        setProgress((prev) => {
          if (prev >= 90) return prev;
          return prev + 10;
        });
      }, 300);

      return () => clearInterval(interval);
    } else {
      setProgress(0);
    }
  }, [isSubmitting]);

  // Función para subir imagen quien recibe
  const handleUploadWhoReceivesImage = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    try {
      setIsUploadingWhoReceives(true);
      setValidationError(null);

      // Comprimir la imagen antes de subirla
      const compressedBlob = await compressImage(files[0], 800, 0.8);
      const compressedFile = blobToFile(
        compressedBlob,
        `who-receives-${Date.now()}.${files[0].name.split(".").pop()}`,
        { type: files[0].type }
      );

      // Subir la imagen comprimida
      const imageUrl = await uploadTaskImage(compressedFile, "who-receives");

      setFinalizeForm({
        ...finalizeForm,
        imageUrlWhoReceives: imageUrl,
      });
    } catch (error) {
      console.error("Error al subir imagen:", error);
      setValidationError("No se pudo subir la imagen. Intente nuevamente.");
    } finally {
      setIsUploadingWhoReceives(false);
      // Limpiar el input
      if (fileInputWhoReceivesRef.current) {
        fileInputWhoReceivesRef.current.value = "";
      }
    }
  };

  // Función para subir imagen de trabajo
  const handleUploadWorkImage = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    try {
      setIsUploadingWork(true);
      setValidationError(null);

      // Comprimir la imagen antes de subirla
      const compressedBlob = await compressImage(files[0], 1200, 0.8);
      const compressedFile = blobToFile(
        compressedBlob,
        `work-${Date.now()}.${files[0].name.split(".").pop()}`,
        { type: files[0].type }
      );

      // Subir la imagen comprimida
      const imageUrl = await uploadTaskImage(compressedFile, "work");

      // Agregar nueva imagen a las existentes
      setFinalizeForm({
        ...finalizeForm,
        mediaUrls: [...(finalizeForm.mediaUrls || []), imageUrl],
      });
    } catch (error) {
      console.error("Error al subir imagen:", error);
      setValidationError("No se pudo subir la imagen. Intente nuevamente.");
    } finally {
      setIsUploadingWork(false);
      // Limpiar el input
      if (fileInputWorkRef.current) {
        fileInputWorkRef.current.value = "";
      }
    }
  };

  // Eliminar imagen de trabajo
  const handleRemoveWorkImage = (urlToRemove: string) => {
    setFinalizeForm({
      ...finalizeForm,
      mediaUrls: (finalizeForm.mediaUrls || []).filter(
        (url) => url !== urlToRemove
      ),
    });
  };

  const handleSubmit = async () => {
    setValidationError(null);

    // Validaciones
    if (!finalizeForm.technicalReport) {
      setValidationError("El informe técnico es obligatorio");
      return;
    }

    if (finalizeForm.hoursWorked <= 0) {
      setValidationError("Las horas trabajadas deben ser mayores a 0");
      return;
    }

    // Validar nuevos campos obligatorios
    if (!finalizeForm.nameWhoReceives) {
      setValidationError("El nombre de quien recibe es obligatorio");
      return;
    }

    if (!finalizeForm.positionWhoReceives) {
      setValidationError("El cargo de quien recibe es obligatorio");
      return;
    }

    try {
      setIsSubmitting(true);

      // Aquí enviamos directamente el formulario si el usuario subió imágenes usando el formulario
      // Si no, usamos el proceso API normal

      // Comprobar si tenemos imágenes para enviar como FormData
      const hasWhoReceivesImage =
        fileInputWhoReceivesRef.current?.files?.length > 0;
      const hasWorkImages = fileInputWorkRef.current?.files?.length > 0;

      if (hasWhoReceivesImage || hasWorkImages) {
        // Crear un FormData para enviar los datos y los archivos
        const formData = new FormData();

        // Añadir los datos del formulario
        formData.append("taskId", finalizeForm.taskId.toString());
        formData.append("technicalReport", finalizeForm.technicalReport);
        if (finalizeForm.observations)
          formData.append("observations", finalizeForm.observations);
        formData.append("hoursWorked", finalizeForm.hoursWorked.toString());
        formData.append("nameWhoReceives", finalizeForm.nameWhoReceives);
        formData.append(
          "positionWhoReceives",
          finalizeForm.positionWhoReceives
        );
        if (finalizeForm.endDate)
          formData.append("endDate", finalizeForm.endDate);

        // Añadir imagen de quien recibe si existe
        if (hasWhoReceivesImage) {
          formData.append(
            "imageWhoReceives",
            fileInputWhoReceivesRef.current.files[0]
          );
        } else if (finalizeForm.imageUrlWhoReceives) {
          formData.append(
            "imageUrlWhoReceives",
            finalizeForm.imageUrlWhoReceives
          );
        }

        // Añadir URLs de imágenes ya existentes
        if (finalizeForm.mediaUrls && finalizeForm.mediaUrls.length > 0) {
          // Para enviar un array en FormData, debemos usar notación de corchetes
          finalizeForm.mediaUrls.forEach((url, i) => {
            formData.append(`mediaUrls[${i}]`, url);
          });
        }

        // Añadir las listas de técnicos
        if (finalizeForm.technicians && finalizeForm.technicians.length > 0) {
          finalizeForm.technicians.forEach((tech, i) => {
            formData.append(`technicians[${i}]`, tech);
          });
        }

        // Añadir nuevas imágenes de trabajo
        if (hasWorkImages) {
          Array.from(fileInputWorkRef.current.files).forEach((file) => {
            formData.append("image", file);
          });
        }

        // Obtener token para la petición
        const session = await import("next-auth/react").then((mod) =>
          mod.getSession()
        );
        const accessToken = session?.accessToken;

        // Enviar los datos directamente con fetch
        const response = await fetch(
          `${process.env.NEXT_PUBLIC_API_URL}/tasks/finalize`,
          {
            method: "POST",
            headers: {
              ...(accessToken
                ? { Authorization: `Bearer ${accessToken}` }
                : {}),
            },
            credentials: "include",
            body: formData,
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({
            message: `Error ${response.status}: ${response.statusText}`,
          }));

          throw new Error(
            errorData.message ||
              `Error al finalizar tarea: ${response.statusText}`
          );
        }

        const result = await response.json();

        // Continuar con el flujo normal después de la operación exitosa
        setProgress(100);
        onClose();
      } else {
        // Si no hay archivos para subir, usamos el método normal
        await onSave(finalizeForm);
        setProgress(100);
      }
    } catch (error) {
      console.error("Error al finalizar la tarea:", error);
      setValidationError("Ocurrió un error al finalizar la tarea");
    } finally {
      // Retraso para asegurar que se vea la animación completa
      setTimeout(() => {
        setIsSubmitting(false);
      }, 300);
    }
  };

  // Fusionar los estados de carga
  const isFormDisabled =
    isLoading || isSubmitting || isUploadingWhoReceives || isUploadingWork;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && !isFormDisabled && onClose()}
    >
      <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <CheckCircle2 className="h-5 w-5 text-green-500" />
            Finalizar Tarea
          </DialogTitle>
        </DialogHeader>

        {/* Barra de progreso */}
        {isSubmitting && (
          <div className="h-1 w-full bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-green-500 transition-all duration-300 ease-out"
              style={{ width: `${progress}%` }}
            />
          </div>
        )}

        <div className="space-y-4">
          <p className="font-medium">{task ? task.title : ""}</p>

          {/* Mostrar los técnicos asignados */}
          {task?.assignedWorkers && task.assignedWorkers.length > 0 && (
            <div className="border rounded-md p-3 bg-blue-50">
              <div className="flex items-center gap-2 mb-2">
                <Users className="h-4 w-4 text-blue-500" />
                <h3 className="font-medium text-blue-700">
                  Técnicos asignados
                </h3>
              </div>
              <div className="flex flex-wrap gap-2">
                {task.assignedWorkers.map((assignment) => (
                  <Badge
                    key={assignment.workerId}
                    variant="secondary"
                    className="px-2 py-1 text-sm"
                  >
                    {assignment.worker.name}
                  </Badge>
                ))}
              </div>
            </div>
          )}

          <FormField>
            <FormLabel>Informe técnico</FormLabel>
            <FormTextarea
              value={finalizeForm.technicalReport}
              onChange={(e) =>
                setFinalizeForm({
                  ...finalizeForm,
                  technicalReport: e.target.value,
                })
              }
              required
              disabled={isFormDisabled}
              placeholder="Describa el trabajo realizado y los resultados obtenidos"
            />
          </FormField>

          <FormField>
            <FormLabel>Observaciones</FormLabel>
            <FormTextarea
              value={finalizeForm.observations || ""}
              onChange={(e) =>
                setFinalizeForm({
                  ...finalizeForm,
                  observations: e.target.value,
                })
              }
              disabled={isFormDisabled}
              placeholder="Cualquier observación adicional (opcional)"
            />
          </FormField>

          <FormField>
            <FormLabel>Horas trabajadas</FormLabel>
            <div className="relative">
              <Input
                type="number"
                value={finalizeForm.hoursWorked}
                onChange={(e) =>
                  setFinalizeForm({
                    ...finalizeForm,
                    hoursWorked: parseFloat(e.target.value),
                  })
                }
                min="0.5"
                step="0.5"
                required
                disabled={isFormDisabled}
              />
              {isFormDisabled && (
                <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
                  <Loader2 className="h-4 w-4 animate-spin text-primary" />
                </div>
              )}
            </div>
            <div className="text-sm text-gray-500 mt-1">
              Total de horas trabajadas:{" "}
              {formatNumber(finalizeForm.hoursWorked)}
            </div>
          </FormField>

          <FormField>
            <FormLabel>Fecha de finalización</FormLabel>
            <div className="relative">
              <Input
                type="date"
                value={finalizeForm.endDate || ""}
                onChange={(e) =>
                  setFinalizeForm({
                    ...finalizeForm,
                    endDate: e.target.value,
                  })
                }
                required
                disabled={isFormDisabled}
              />
              {isFormDisabled && (
                <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
                  <Loader2 className="h-4 w-4 animate-spin text-primary" />
                </div>
              )}
            </div>
          </FormField>

          {/* NUEVOS CAMPOS */}
          <div className="border p-4 rounded-md bg-accent/10 space-y-4">
            <h3 className="font-medium">
              Información de quien recibe el trabajo
            </h3>

            <FormField>
              <FormLabel>Nombre de quien recibe</FormLabel>
              <Input
                value={finalizeForm.nameWhoReceives || ""}
                onChange={(e) =>
                  setFinalizeForm({
                    ...finalizeForm,
                    nameWhoReceives: e.target.value,
                  })
                }
                required
                disabled={isFormDisabled}
                placeholder="Nombre completo"
              />
            </FormField>

            <FormField>
              <FormLabel>Cargo de quien recibe</FormLabel>
              <Input
                value={finalizeForm.positionWhoReceives || ""}
                onChange={(e) =>
                  setFinalizeForm({
                    ...finalizeForm,
                    positionWhoReceives: e.target.value,
                  })
                }
                required
                disabled={isFormDisabled}
                placeholder="Ej: Administrador, Conserje, etc."
              />
            </FormField>

            <FormField>
              <FormLabel>Foto de quien recibe (opcional)</FormLabel>
              <div className="flex flex-col gap-4">
                <input
                  type="file"
                  ref={fileInputWhoReceivesRef}
                  onChange={handleUploadWhoReceivesImage}
                  accept="image/*"
                  style={{ display: "none" }}
                />

                {finalizeForm.imageUrlWhoReceives && (
                  <div className="relative w-full h-32 bg-gray-100 rounded-md overflow-hidden">
                    <img
                      src={finalizeForm.imageUrlWhoReceives}
                      alt="Firma de quien recibe"
                      className="w-full h-full object-contain"
                    />
                  </div>
                )}

                <Button
                  type="button"
                  variant="outline"
                  onClick={() => fileInputWhoReceivesRef.current?.click()}
                  disabled={isFormDisabled}
                  className="w-full"
                >
                  {isUploadingWhoReceives ? (
                    <div className="flex items-center">
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      <span>Subiendo...</span>
                    </div>
                  ) : finalizeForm.imageUrlWhoReceives ? (
                    <>
                      <Edit className="mr-2 h-4 w-4" />
                      Cambiar imagen
                    </>
                  ) : (
                    <>
                      <Camera className="mr-2 h-4 w-4" />
                      Tomar foto de quien recibe
                    </>
                  )}
                </Button>
              </div>
            </FormField>
          </div>

          {/* Sección de fotos del trabajo realizado */}
          <div className="border p-4 rounded-md bg-accent/10 space-y-4">
            <h3 className="font-medium">Fotos del trabajo realizado</h3>

            <FormField>
              <FormLabel>Fotos de la instalación o servicio</FormLabel>
              <FormDescription>
                Agregue fotos del trabajo realizado (antes/después, detalles,
                etc.)
              </FormDescription>

              <input
                type="file"
                ref={fileInputWorkRef}
                onChange={handleUploadWorkImage}
                accept="image/*"
                style={{ display: "none" }}
              />

              {/* Grid de imágenes */}
              {finalizeForm.mediaUrls && finalizeForm.mediaUrls.length > 0 && (
                <div className="grid grid-cols-2 md:grid-cols-3 gap-4 my-4">
                  {finalizeForm.mediaUrls.map((url, index) => (
                    <div key={url} className="relative group">
                      <div className="h-32 bg-gray-100 rounded-md overflow-hidden">
                        <img
                          src={url}
                          alt={`Imagen ${index + 1}`}
                          className="w-full h-full object-cover"
                        />
                      </div>
                      <button
                        type="button"
                        onClick={() => handleRemoveWorkImage(url)}
                        className="absolute top-2 right-2 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity"
                        disabled={isFormDisabled}
                      >
                        <X className="h-4 w-4" />
                      </button>
                    </div>
                  ))}
                </div>
              )}

              <Button
                type="button"
                variant="outline"
                onClick={() => fileInputWorkRef.current?.click()}
                disabled={isFormDisabled}
                className="w-full mt-2"
              >
                {isUploadingWork ? (
                  <div className="flex items-center">
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    <span>Subiendo...</span>
                  </div>
                ) : (
                  <>
                    <Plus className="mr-2 h-4 w-4" />
                    Agregar foto
                  </>
                )}
              </Button>
            </FormField>
          </div>

          {/* Mensaje de validación */}
          {validationError && (
            <div className="border border-red-300 rounded-md p-3 bg-red-50 text-red-800 animate-fadeIn">
              <p className="text-sm font-medium">{validationError}</p>
            </div>
          )}
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isFormDisabled}>
            Cancelar
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={isFormDisabled}
            variant="success"
            className="bg-green-600 hover:bg-green-700 text-white"
          >
            {isFormDisabled ? (
              <div className="flex items-center">
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                <span>Finalizando...</span>
              </div>
            ) : (
              <div className="flex items-center">
                <CheckCircle2 className="h-4 w-4 mr-2" />
                <span>Finalizar Tarea</span>
              </div>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\tasks\TaskDetail.tsx
// C:\workspace\gestion\web\components\tasks\TaskDetail.tsx
import { useState, useEffect } from "react";
import { Task } from "@/services/tasks";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Calendar,
  Clock,
  Edit,
  Trash,
  CheckCircle,
  Loader2,
  MapPin,
  FileText,
  User,
  Briefcase,
  Image as ImageIcon,
  ExternalLink,
  Download,
  PenTool,
} from "lucide-react";
import QuotationInfo from "../quotes/QuotationInfo";
import { formatDateSafely } from "@/utils/date-format";
import DownloadTaskReportButton from "@/components/tasks/DownloadTaskReportButton";

interface TaskDetailProps {
  task: Task;
  isAdmin: boolean;
  onEdit: (task: Task) => void;
  onDelete: (task: Task) => void;
  onFinalize: (task: Task) => void;
  onStart: (task: Task) => void;
}

export default function TaskDetail({
  task,
  isAdmin,
  onEdit,
  onDelete,
  onFinalize,
  onStart,
}: TaskDetailProps) {
  const [showDetails, setShowDetails] = useState(false);
  const [isStarting, setIsStarting] = useState(false);
  const [isFinalizing, setIsFinalizing] = useState(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const getStateDisplay = (state: string) => {
    switch (state) {
      case "PENDIENTE":
        return (
          <Badge variant="warning" className="mr-2">
            Pendiente
          </Badge>
        );
      case "EN_CURSO":
        return (
          <Badge variant="info" className="mr-2">
            En curso
          </Badge>
        );
      case "FINALIZADO":
        return (
          <Badge variant="success" className="mr-2">
            Finalizado
          </Badge>
        );
      default:
        return (
          <Badge variant="secondary" className="mr-2">
            {state}
          </Badge>
        );
    }
  };

  const handleStartTask = async () => {
    try {
      setIsStarting(true);
      await onStart(task);
    } finally {
      setIsStarting(false);
    }
  };

  const handleFinalizeTask = async () => {
    try {
      setIsFinalizing(true);
      await onFinalize(task);
    } finally {
      setIsFinalizing(false);
    }
  };

  // Componente para mostrar la imagen ampliada
  const ImagePreview = () => {
    if (!selectedImage) return null;

    return (
      <div
        className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4"
        onClick={() => setSelectedImage(null)}
      >
        <div
          className="relative max-w-4xl max-h-[90vh] w-full"
          onClick={(e) => e.stopPropagation()}
        >
          <Button
            variant="outline"
            size="icon"
            className="absolute right-0 top-0 bg-background z-10 m-2"
            onClick={() => setSelectedImage(null)}
          >
            ✕
          </Button>
          <div className="bg-white p-2 rounded-md">
            <img
              src={selectedImage}
              alt="Vista previa"
              className="max-h-[85vh] max-w-full object-contain mx-auto"
            />
          </div>
          <div className="mt-2 flex justify-center">
            <Button
              variant="outline"
              onClick={() => window.open(selectedImage, "_blank")}
              className="bg-background"
            >
              <ExternalLink className="h-4 w-4 mr-2" />
              Abrir en nueva pestaña
            </Button>
          </div>
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-6">
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <div>
            <CardTitle className="text-xl">{task.title}</CardTitle>
            <div className="flex items-center mt-2">
              {getStateDisplay(task.state)}
              {task.types &&
                task.types.map((type) => (
                  <Badge key={type} variant="outline" className="mr-2">
                    {type}
                  </Badge>
                ))}
            </div>
          </div>

          <div className="flex space-x-2">
            {isAdmin && (
              <>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => onEdit(task)}
                >
                  <Edit className="h-4 w-4 mr-1" />
                  Editar
                </Button>
                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => onDelete(task)}
                >
                  <Trash className="h-4 w-4 mr-1" />
                  Eliminar
                </Button>
              </>
            )}
            {task.state === "PENDIENTE" && (
              <Button
                variant="default"
                size="sm"
                onClick={handleStartTask}
                disabled={isStarting}
              >
                {isStarting ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                    Iniciando...
                  </>
                ) : (
                  <>
                    <Clock className="h-4 w-4 mr-1" />
                    Iniciar
                  </>
                )}
              </Button>
            )}
            {task.state === "EN_CURSO" && (
              <Button
                variant="default"
                size="sm"
                onClick={handleFinalizeTask}
                disabled={isFinalizing}
              >
                {isFinalizing ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-1 animate-spin" />
                    Finalizando...
                  </>
                ) : (
                  <>
                    <CheckCircle className="h-4 w-4 mr-1" />
                    Finalizar
                  </>
                )}
              </Button>
            )}
          </div>
        </div>
      </CardHeader>

      <CardContent>
        {/* Descripción de la tarea */}
        {task.description && (
          <div className="mb-4">
            <p className="text-sm text-content-subtle">{task.description}</p>
          </div>
        )}

        {/* Información de la cotización si existe */}
        {task.quotationId && <QuotationInfo quotationId={task.quotationId} />}

        {/* Información básica */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <h3 className="font-medium mb-2">Información del Cliente</h3>
            {task.client ? (
              <div className="space-y-1">
                <p className="text-sm">
                  <span className="font-medium">Nombre:</span>{" "}
                  {task.client.name}
                </p>
                <p className="text-sm">
                  <span className="font-medium">Email:</span>{" "}
                  {task.client.email}
                </p>
                {task.client.phone && (
                  <p className="text-sm">
                    <span className="font-medium">Teléfono:</span>{" "}
                    {task.client.phone}
                  </p>
                )}
                {task.client.address && (
                  <p className="text-sm flex">
                    <span className="font-medium mr-1">Dirección:</span>{" "}
                    <MapPin className="h-4 w-4 mx-1 text-content-subtle" />
                    <span>{task.client.address}</span>
                  </p>
                )}
                {task.client.rut && (
                  <p className="text-sm">
                    <span className="font-medium">RUT:</span> {task.client.rut}
                  </p>
                )}
                {task.client.commune && (
                  <p className="text-sm">
                    <span className="font-medium">Comuna:</span>{" "}
                    {task.client.commune}
                  </p>
                )}
                {task.client.administrator && (
                  <p className="text-sm">
                    <span className="font-medium">Administrador:</span>{" "}
                    {task.client.administrator}
                  </p>
                )}
                {task.client.butler && (
                  <p className="text-sm">
                    <span className="font-medium">Mayordomo:</span>{" "}
                    {task.client.butler}
                  </p>
                )}
              </div>
            ) : (
              <p className="text-sm text-content-subtle">
                Sin cliente asignado
              </p>
            )}
          </div>

          <div>
            <h3 className="font-medium mb-2">Fechas</h3>
            <div className="space-y-1">
              <p className="text-sm flex items-center">
                <Calendar className="h-4 w-4 mr-2 text-content-subtle" />
                <span className="font-medium mr-1">Inicio:</span>
                {formatDateSafely(task.startDate)}
              </p>
              {task.endDate && (
                <p className="text-sm flex items-center">
                  <Calendar className="h-4 w-4 mr-2 text-content-subtle" />
                  <span className="font-medium mr-1">Fin:</span>
                  {formatDateSafely(task.endDate)}
                </p>
              )}
              {task.hoursWorked !== undefined && (
                <p className="text-sm flex items-center">
                  <Clock className="h-4 w-4 mr-2 text-content-subtle" />
                  <span className="font-medium mr-1">Horas trabajadas:</span>
                  {task.hoursWorked}
                </p>
              )}
            </div>
          </div>
        </div>

        {/* Técnicos asignados */}
        <div className="mb-4">
          <h3 className="font-medium mb-2">Técnicos Asignados</h3>
          {task.assignedWorkers && task.assignedWorkers.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
              {task.assignedWorkers.map((assignment) => (
                <div
                  key={assignment.workerId}
                  className="flex items-center p-2 bg-muted/40 rounded"
                >
                  <div className="ml-2">
                    <p className="font-medium text-sm">
                      {assignment.worker.name}
                    </p>
                    <p className="text-xs text-content-subtle">
                      {assignment.worker.email}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-sm text-content-subtle">
              No hay técnicos asignados
            </p>
          )}
        </div>

        {/* Categorías */}
        {task.categories && task.categories.length > 0 && (
          <div className="mb-4">
            <h3 className="font-medium mb-2">Categorías</h3>
            <div className="flex flex-wrap gap-1">
              {task.categories.map((category, index) => (
                <Badge key={index} variant="outline">
                  {category}
                </Badge>
              ))}
            </div>
          </div>
        )}

        {/* Mostrar más detalles si la tarea está finalizada */}
        {task.state === "FINALIZADO" && (
          <div className="border-t border-border pt-4 mt-4">
            <div className="bg-accent/10 p-3 rounded-md mb-4">
              <h3 className="font-medium mb-2 flex items-center">
                <FileText className="h-4 w-4 mr-2" />
                Informe Técnico
              </h3>
              <p className="text-sm whitespace-pre-line mb-4">
                {task.technicalReport}
              </p>
            </div>

            {task.observations && (
              <div className="bg-muted/30 p-3 rounded-md mb-4">
                <h3 className="font-medium mb-2">Observaciones</h3>
                <p className="text-sm whitespace-pre-line">
                  {task.observations}
                </p>
              </div>
            )}

            {/* Información de la persona que recibió el trabajo */}
            {task.metadata?.receivedBy && (
              <div className="mb-6 border border-border rounded-lg p-4">
                <h3 className="font-medium mb-3">Información de Recepción</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <p className="text-sm flex items-center">
                      <User className="h-4 w-4 mr-2 text-content-subtle" />
                      <span className="font-medium mr-1">Recibido por:</span>
                      {task.metadata.receivedBy.name}
                    </p>
                    {task.metadata.receivedBy.position && (
                      <p className="text-sm flex items-center">
                        <Briefcase className="h-4 w-4 mr-2 text-content-subtle" />
                        <span className="font-medium mr-1">Cargo:</span>
                        {task.metadata.receivedBy.position}
                      </p>
                    )}
                    {task.metadata.receivedBy.date && (
                      <p className="text-sm flex items-center">
                        <Calendar className="h-4 w-4 mr-2 text-content-subtle" />
                        <span className="font-medium mr-1">
                          Fecha de recepción:
                        </span>
                        {formatDateSafely(task.metadata.receivedBy.date)}
                      </p>
                    )}
                  </div>
                  {task.metadata.receivedBy.imageUrl && (
                    <div className="flex justify-center items-center">
                      <div
                        className="relative border border-border rounded overflow-hidden cursor-pointer"
                        onClick={() =>
                          setSelectedImage(task.metadata.receivedBy.imageUrl)
                        }
                      >
                        <div className="absolute inset-0 flex items-center justify-center bg-black/5 opacity-0 hover:opacity-100 transition-opacity">
                          <div className="bg-black/60 text-white p-1 rounded">
                            <ImageIcon className="h-5 w-5" />
                          </div>
                        </div>
                        <img
                          src={task.metadata.receivedBy.imageUrl}
                          alt="Firma de recepción"
                          className="max-w-full max-h-32 object-contain"
                        />
                      </div>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Galería de imágenes */}
            {task.mediaUrls && task.mediaUrls.length > 0 && (
              <div className="mb-6">
                <h3 className="font-medium mb-3 flex items-center">
                  <ImageIcon className="h-4 w-4 mr-2" />
                  Imágenes Adjuntas
                </h3>
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                  {task.mediaUrls.map((url, index) => (
                    <div
                      key={index}
                      className="relative border border-border rounded-md overflow-hidden aspect-square cursor-pointer"
                      onClick={() => setSelectedImage(url)}
                    >
                      <div className="absolute inset-0 flex items-center justify-center bg-black/5 opacity-0 hover:opacity-100 transition-opacity">
                        <div className="bg-black/60 text-white p-1 rounded">
                          <ImageIcon className="h-5 w-5" />
                        </div>
                      </div>
                      <img
                        src={url}
                        alt={`Adjunto ${index + 1}`}
                        className="w-full h-full object-cover"
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </CardContent>

      {/* Visor de imágenes en grande */}
      <ImagePreview />
    </Card>
  );
}


Ruta: components\tasks\TaskFilters.tsx
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Plus, Loader2, CalendarIcon } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

// Constantes para tipos y estados de tareas
const TASK_STATES = ["PENDIENTE", "EN_CURSO", "FINALIZADO"];

interface TasksFilterOptions {
  view: "daily" | "weekly" | "monthly";
  date: string;
  state?: string;
}

interface TaskFiltersProps {
  filters: TasksFilterOptions;
  onFilterChange: (newFilters: TasksFilterOptions) => void;
  searchTerm: string;
  onSearchChange: (value: string) => void;
  onAddTask: () => void;
  isAdmin: boolean;
  isLoading?: boolean;
}

export default function TaskFilters({
  filters,
  onFilterChange,
  searchTerm,
  onSearchChange,
  onAddTask,
  isAdmin,
  isLoading = false,
}: TaskFiltersProps) {
  return (
    <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
      <h2 className="text-xl font-semibold">Lista de Tareas</h2>
      <div className="flex flex-col md:flex-row gap-4 w-full md:w-auto">
        <div className="flex gap-2">
          <Select
            value={filters.view}
            onValueChange={(value: "daily" | "weekly" | "monthly") =>
              onFilterChange({ ...filters, view: value })
            }
            disabled={isLoading}
          >
            <SelectTrigger className="w-[120px]">
              {isLoading ? (
                <div className="flex items-center">
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  <span>Cargando</span>
                </div>
              ) : (
                <SelectValue placeholder="Vista" />
              )}
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="daily">Diaria</SelectItem>
              <SelectItem value="weekly">Semanal</SelectItem>
              <SelectItem value="monthly">Mensual</SelectItem>
            </SelectContent>
          </Select>

          <div className="relative">
            <Input
              type="date"
              value={filters.date}
              onChange={(e) =>
                onFilterChange({ ...filters, date: e.target.value })
              }
              className="w-[150px]"
              disabled={isLoading}
            />
            {isLoading && (
              <div className="absolute inset-0 flex items-center justify-center bg-background/80 rounded-md">
                <Loader2 className="h-4 w-4 animate-spin text-primary" />
              </div>
            )}
          </div>

          <Select
            value={filters.state || ""}
            onValueChange={(value) =>
              onFilterChange({ ...filters, state: value || undefined })
            }
            disabled={isLoading}
          >
            <SelectTrigger className="w-[140px]">
              {isLoading ? (
                <div className="flex items-center">
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  <span>Cargando</span>
                </div>
              ) : (
                <SelectValue placeholder="Estado" />
              )}
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="All">Todos</SelectItem>
              {TASK_STATES.map((state) => (
                <SelectItem key={state} value={state}>
                  {state === "PENDIENTE"
                    ? "Pendiente"
                    : state === "EN_CURSO"
                    ? "En curso"
                    : "Finalizado"}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        <div className="relative">
          <Input
            placeholder="Buscar tareas..."
            value={searchTerm}
            onChange={(e) => onSearchChange(e.target.value)}
            className="md:w-60"
            disabled={isLoading}
          />
          {isLoading && (
            <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
              <Loader2 className="h-4 w-4 animate-spin text-primary" />
            </div>
          )}
        </div>

        {isAdmin && (
          <Button
            onClick={onAddTask}
            className="whitespace-nowrap"
            disabled={isLoading}
          >
            {isLoading ? (
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            ) : (
              <Plus className="mr-2 h-4 w-4" />
            )}
            Nueva Tarea
          </Button>
        )}
      </div>
    </div>
  );
}


Ruta: components\tasks\TaskForm.tsx
// web\components\tasks\TaskForm.tsx
import { useState, useEffect } from "react";
import { FormField, FormLabel } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { FormTextarea } from "@/components/ui/form-textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Task } from "@/services/tasks";
import { Client } from "@/services/clients";
import { User } from "@/services/users";
import { Quotation, getQuotationsByClient } from "@/services/quotations";
import ClientSelect from "@/components/clients/ClientSelect";
import UserMultiSelect from "@/components/tasks/UserMultiSelect";
import { useNotification } from "@/contexts/NotificationContext";
import { Loader2 } from "lucide-react";

interface TaskFormProps {
  isOpen: boolean;
  task: Task | null;
  clients: Client[];
  workers: User[];
  onSave: (task: Task) => Promise<void>;
  onClose: () => void;
  onUserCreated?: (user: User) => void;
  onClientCreated?: (client: Client) => void;
  isLoading?: boolean;
  isLoadingClients?: boolean;
  isLoadingWorkers?: boolean;
}

// Constantes para tipos y estados de tareas
const TASK_STATES = ["PENDIENTE", "EN_CURSO", "FINALIZADO"];
const TASK_TYPES = ["REVISION", "REPARACION", "MANTENCION", "INSTALACION"];
const TASK_CATEGORIES = [
  "CCTV",
  "Citofonia",
  "Cerco eléctrico",
  "Alarma",
  "Alarma de robo",
  "Alarma de incendio",
  "Control de acceso",
  "Porton automatico",
  "Circuito de fuerza",
  "Fibra optica",
  "Redes",
  "Otros",
];

export default function TaskForm({
  isOpen,
  task,
  clients,
  workers,
  onSave,
  onClose,
  onUserCreated,
  onClientCreated,
  isLoading = false,
  isLoadingClients = false,
  isLoadingWorkers = false,
}: TaskFormProps) {
  const { addNotification } = useNotification();
  const [taskForm, setTaskForm] = useState<Task>({
    title: "",
    description: "",
    state: "PENDIENTE",
    types: [],
    categories: [],
    startDate: new Date().toISOString().split("T")[0],
  });
  const [clientQuotations, setClientQuotations] = useState<Quotation[]>([]);
  const [isLoadingQuotations, setIsLoadingQuotations] = useState(false);
  const [selectedWorkerIds, setSelectedWorkerIds] = useState<number[]>([]);
  const [isSavingInProgress, setIsSavingInProgress] = useState(false);
  const [formValidationError, setFormValidationError] = useState<string | null>(
    null
  );

  // Para depuración
  useEffect(() => {
    console.log("Workers disponibles en TaskForm:", workers);
    console.log("Task actual:", task);
  }, [workers, task]);

  useEffect(() => {
    if (task) {
      // Asegurar que los arrays estén definidos
      setTaskForm({
        ...task,
        types: task.types || [],
        categories: task.categories || [],
        startDate: new Date(task.startDate).toISOString().split("T")[0],
        endDate: task.endDate
          ? new Date(task.endDate).toISOString().split("T")[0]
          : undefined,
      });

      // Si la tarea tiene trabajadores asignados, establecer los IDs seleccionados
      if (task.assignedWorkers && task.assignedWorkers.length > 0) {
        const workerIds = task.assignedWorkers.map(
          (assignment) => assignment.workerId
        );
        setSelectedWorkerIds(workerIds);
      } else {
        setSelectedWorkerIds([]);
      }

      // Si la tarea tiene un cliente, cargar sus cotizaciones
      if (task.clientId) {
        loadClientQuotations(task.clientId);
      }
    } else {
      // Reset form for new task
      setTaskForm({
        title: "",
        description: "",
        state: "PENDIENTE",
        types: [],
        categories: [],
        startDate: new Date().toISOString().split("T")[0],
      });
      setSelectedWorkerIds([]);
      setClientQuotations([]);
    }

    // Limpiar errores de validación
    setFormValidationError(null);
  }, [task, isOpen]);

  // Función para cargar cotizaciones del cliente seleccionado
  const loadClientQuotations = async (clientId: number) => {
    setIsLoadingQuotations(true);
    try {
      const quotations = await getQuotationsByClient(clientId);
      console.log("Cotizaciones del cliente:", quotations);
      setClientQuotations(quotations);
    } catch (error) {
      console.error("Error al cargar cotizaciones del cliente:", error);
      addNotification("error", "Error al cargar cotizaciones del cliente");
      setClientQuotations([]);
    } finally {
      // Pequeño retraso para mostrar el estado de carga
      setTimeout(() => {
        setIsLoadingQuotations(false);
      }, 400);
    }
  };

  const handleSave = async () => {
    // Limpiar errores previos
    setFormValidationError(null);

    // Validación básica
    if (!taskForm.title) {
      setFormValidationError("El título es obligatorio");
      return;
    }

    if (!taskForm.startDate) {
      setFormValidationError("La fecha de inicio es obligatoria");
      return;
    }

    setIsSavingInProgress(true);

    try {
      // Preparar datos para enviar
      const taskData: Task = {
        ...taskForm,
        // Convertir explícitamente a undefined si es necesario
        quotationId: taskForm.quotationId || undefined,
        // Asegurar que se envíen arrays vacíos en lugar de undefined
        types: taskForm.types || [],
        categories: taskForm.categories || [],
        // Asignar los trabajadores seleccionados
        assignedWorkerIds: selectedWorkerIds,
      };

      console.log("Datos de tarea a guardar:", taskData);
      await onSave(taskData);
    } catch (error) {
      console.error("Error al guardar la tarea:", error);
      setFormValidationError("Ha ocurrido un error al guardar la tarea");
    } finally {
      setIsSavingInProgress(false);
    }
  };

  const handleTypeToggle = (type: string) => {
    setTaskForm((prev) => {
      const types = prev.types || [];
      if (types.includes(type)) {
        return {
          ...prev,
          types: types.filter((t) => t !== type),
        };
      } else {
        return {
          ...prev,
          types: [...types, type],
        };
      }
    });
  };

  const handleCategoryToggle = (category: string) => {
    setTaskForm((prev) => {
      const categories = prev.categories || [];
      if (categories.includes(category)) {
        return {
          ...prev,
          categories: categories.filter((c) => c !== category),
        };
      } else {
        return {
          ...prev,
          categories: [...categories, category],
        };
      }
    });
  };

  const handleClientChange = (value: string, client?: Client) => {
    const clientId = value ? parseInt(value) : undefined;

    setTaskForm({
      ...taskForm,
      clientId: clientId,
      client: client,
      // Al cambiar de cliente, limpiar la cotización seleccionada
      quotationId: undefined,
      quotation: undefined,
    });

    // Si hay un cliente seleccionado, cargar sus cotizaciones
    if (clientId) {
      loadClientQuotations(clientId);
    } else {
      // Si no hay cliente, limpiar las cotizaciones
      setClientQuotations([]);
    }
  };

  const handleQuotationChange = (value: string) => {
    if (!value || value === "-") {
      // Si selecciona "Sin cotización"
      setTaskForm({
        ...taskForm,
        quotationId: undefined,
        quotation: undefined,
      });
      return;
    }

    const quotationId = parseInt(value);
    const selectedQuotation = clientQuotations.find(
      (q) => q.id === quotationId
    );

    if (selectedQuotation) {
      setTaskForm({
        ...taskForm,
        quotationId: quotationId,
        quotation: {
          id: selectedQuotation.id,
          title: selectedQuotation.title,
          amount: selectedQuotation.amount || 0,
        },
      });
    }
  };

  const handleWorkerSelectionChange = (workerIds: number[]) => {
    setSelectedWorkerIds(workerIds);
  };

  // Mostrar estado de carga al abrir el formulario
  if (!isOpen) return null;

  // Indicador de carga para el formulario completo
  const isFormLoading =
    isLoading || isLoadingClients || isLoadingWorkers || isSavingInProgress;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && !isFormLoading && onClose()}
    >
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>{task ? "Editar Tarea" : "Nueva Tarea"}</DialogTitle>
        </DialogHeader>

        {/* Barra de progreso para guardado */}
        {isSavingInProgress && (
          <div className="h-1 w-full bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-primary animate-pulse"
              style={{ width: "100%" }}
            />
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <FormField>
            <FormLabel>Título</FormLabel>
            <Input
              value={taskForm.title}
              onChange={(e) =>
                setTaskForm({ ...taskForm, title: e.target.value })
              }
              required
              disabled={isFormLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Cliente</FormLabel>
            <ClientSelect
              clients={clients}
              value={taskForm.clientId?.toString() || ""}
              onValueChange={handleClientChange}
              onClientCreated={onClientCreated}
              isLoading={isLoadingClients}
              placeholder="Seleccionar cliente"
            />
          </FormField>

          {/* Selector de cotizaciones (solo aparece si hay un cliente seleccionado) */}
          {taskForm.clientId && (
            <FormField>
              <FormLabel>Cotización</FormLabel>
              <div className="relative">
                <Select
                  value={taskForm.quotationId?.toString() || "-"}
                  onValueChange={handleQuotationChange}
                  disabled={
                    isLoadingQuotations ||
                    clientQuotations.length === 0 ||
                    isFormLoading
                  }
                >
                  <SelectTrigger>
                    {isLoadingQuotations ? (
                      <div className="flex items-center">
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        <span>Cargando cotizaciones...</span>
                      </div>
                    ) : (
                      <SelectValue placeholder="Seleccionar cotización" />
                    )}
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="-">Sin cotización</SelectItem>
                    {isLoadingQuotations ? (
                      <SelectItem value="loading" disabled>
                        Cargando cotizaciones...
                      </SelectItem>
                    ) : clientQuotations.length > 0 ? (
                      clientQuotations.map((quotation) => (
                        <SelectItem
                          key={quotation.id}
                          value={quotation.id.toString()}
                        >
                          {quotation.title} - $
                          {quotation.amount?.toLocaleString()}
                        </SelectItem>
                      ))
                    ) : (
                      <SelectItem value="empty" disabled>
                        No hay cotizaciones para este cliente
                      </SelectItem>
                    )}
                  </SelectContent>
                </Select>
                {isLoadingQuotations && (
                  <div className="absolute right-10 top-1/2 transform -translate-y-1/2">
                    <Loader2 className="h-4 w-4 animate-spin text-primary" />
                  </div>
                )}
              </div>
            </FormField>
          )}

          <FormField className="md:col-span-2">
            <FormLabel>Descripción</FormLabel>
            <FormTextarea
              value={taskForm.description || ""}
              onChange={(e) =>
                setTaskForm({ ...taskForm, description: e.target.value })
              }
              disabled={isFormLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Estado</FormLabel>
            <Select
              value={taskForm.state}
              onValueChange={(value) =>
                setTaskForm({ ...taskForm, state: value })
              }
              disabled={isFormLoading}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {TASK_STATES.map((state) => (
                  <SelectItem key={state} value={state}>
                    {state === "PENDIENTE"
                      ? "Pendiente"
                      : state === "EN_CURSO"
                      ? "En curso"
                      : "Finalizado"}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </FormField>

          <div className="space-y-2">
            <FormLabel>Fecha de inicio</FormLabel>
            <Input
              type="date"
              value={taskForm.startDate}
              onChange={(e) =>
                setTaskForm({ ...taskForm, startDate: e.target.value })
              }
              required
              disabled={isFormLoading}
            />
          </div>

          <div className="space-y-2">
            <FormLabel>Fecha de fin (opcional)</FormLabel>
            <Input
              type="date"
              value={taskForm.endDate || ""}
              onChange={(e) =>
                setTaskForm({
                  ...taskForm,
                  endDate: e.target.value || undefined,
                })
              }
              disabled={isFormLoading}
            />
          </div>

          <div className="md:col-span-2 space-y-2">
            <FormLabel>Tipo de servicio</FormLabel>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {TASK_TYPES.map((type) => (
                <div key={type} className="flex items-center space-x-2">
                  <Checkbox
                    id={`type-${type}`}
                    checked={(taskForm.types || []).includes(type)}
                    onCheckedChange={() => handleTypeToggle(type)}
                    disabled={isFormLoading}
                  />
                  <label
                    htmlFor={`type-${type}`}
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                  >
                    {type}
                  </label>
                </div>
              ))}
            </div>
          </div>

          <div className="md:col-span-2 space-y-2">
            <FormLabel>Categorías</FormLabel>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {TASK_CATEGORIES.map((category) => (
                <div key={category} className="flex items-center space-x-2">
                  <Checkbox
                    id={`category-${category}`}
                    checked={(taskForm.categories || []).includes(category)}
                    onCheckedChange={() => handleCategoryToggle(category)}
                    disabled={isFormLoading}
                  />
                  <label
                    htmlFor={`category-${category}`}
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                  >
                    {category}
                  </label>
                </div>
              ))}
            </div>
          </div>

          <div className="md:col-span-2">
            <FormLabel>Técnicos asignados</FormLabel>
            <UserMultiSelect
              workers={workers}
              selectedWorkerIds={selectedWorkerIds}
              onSelectionChange={handleWorkerSelectionChange}
              onUserCreated={onUserCreated}
              isLoading={isLoadingWorkers}
              disabled={isFormLoading}
            />
          </div>
        </div>

        {/* Mostrar información de la cotización seleccionada si existe */}
        {taskForm.quotationId && taskForm.quotation && (
          <div className="border border-border rounded-md p-3 mb-4 bg-muted/30">
            <h4 className="font-medium mb-2">Información de la cotización</h4>
            <p className="text-sm">
              <span className="font-medium">Título:</span>{" "}
              {taskForm.quotation.title}
            </p>
            <p className="text-sm">
              <span className="font-medium">Monto total:</span> $
              {taskForm.quotation.amount.toLocaleString()}
            </p>
          </div>
        )}

        {/* Mensaje de error de validación */}
        {formValidationError && (
          <div className="border border-red-300 rounded-md p-3 mb-4 bg-red-50 text-red-800 animate-fadeIn">
            <p className="text-sm font-medium">{formValidationError}</p>
          </div>
        )}

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isFormLoading}>
            Cancelar
          </Button>
          <Button onClick={handleSave} disabled={isFormLoading}>
            {isSavingInProgress ? (
              <div className="flex items-center">
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                <span>{task ? "Actualizando..." : "Creando..."}</span>
              </div>
            ) : (
              <span>{task ? "Guardar cambios" : "Crear tarea"}</span>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\tasks\TaskList.tsx
// web\components\tasks\TaskList.tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { DataTable, type ColumnDef } from "@/components/ui/table";
import {
  Calendar,
  Clock,
  CheckCircle,
  AlertTriangle,
  Edit,
  Trash,
  Loader2,
  Eye,
} from "lucide-react";
import { Task } from "@/services/tasks";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface TaskListProps {
  tasks: Task[];
  isLoading: boolean;
  isAdmin: boolean;
  onEdit: (task: Task) => void;
  onView: (task: Task) => void;
  onDelete: (task: Task) => void;
  onFinalize: (task: Task) => void;
}

export default function TaskList({
  tasks,
  isLoading,
  isAdmin,
  onEdit,
  onView,
  onDelete,
  onFinalize,
}: TaskListProps) {
  const [loadingTaskAction, setLoadingTaskAction] = useState<{
    id: number | null;
    action: "edit" | "delete" | "finalize" | "view" | null;
  }>({ id: null, action: null });

  // Obtener estado formateado para mostrar
  const getStateDisplay = (state: string) => {
    switch (state) {
      case "PENDIENTE":
        return (
          <div className="flex items-center gap-2 text-yellow-600">
            <AlertTriangle className="h-4 w-4" />
            <span>Pendiente</span>
          </div>
        );
      case "EN_CURSO":
        return (
          <div className="flex items-center gap-2 text-blue-600">
            <Clock className="h-4 w-4" />
            <span>En curso</span>
          </div>
        );
      case "FINALIZADO":
        return (
          <div className="flex items-center gap-2 text-green-600">
            <CheckCircle className="h-4 w-4" />
            <span>Finalizado</span>
          </div>
        );
      default:
        return state;
    }
  };

  const handleActionStart = (
    taskId: number,
    action: "edit" | "delete" | "finalize" | "view"
  ) => {
    setLoadingTaskAction({ id: taskId, action });

    // Simular una pequeña demora antes de ejecutar la acción real
    // Esto es opcional, pero proporciona retroalimentación visual al usuario
    setTimeout(() => {
      switch (action) {
        case "edit":
          const taskToEdit = tasks.find((task) => task.id === taskId);
          if (taskToEdit) onEdit(taskToEdit);
          break;
        case "delete":
          const taskToDelete = tasks.find((task) => task.id === taskId);
          if (taskToDelete) onDelete(taskToDelete);
          break;
        case "finalize":
          const taskToFinalize = tasks.find((task) => task.id === taskId);
          if (taskToFinalize) onFinalize(taskToFinalize);
          break;
        case "view":
          const taskToView = tasks.find((task) => task.id === taskId);
          if (taskToView) onView(taskToView);
          break;
      }

      // Limpiar el estado de carga
      setTimeout(() => {
        setLoadingTaskAction({ id: null, action: null });
      }, 300);
    }, 300);
  };

  // Columnas para la tabla de tareas
  const columns: ColumnDef<Task>[] = [
    {
      accessorKey: "title",
      header: "Título",
      cell: ({ row }) => (
        <div
          className="cursor-pointer hover:text-primary"
          onClick={() => handleActionStart(row.original.id!, "view")}
        >
          <p className="font-medium">{row.original.title}</p>
          {row.original.description && (
            <p className="text-sm text-content-subtle truncate max-w-xs">
              {row.original.description.length > 60
                ? `${row.original.description.substring(0, 60)}...`
                : row.original.description}
            </p>
          )}
        </div>
      ),
    },
    {
      accessorKey: "client",
      header: "Cliente",
      cell: ({ row }) =>
        row.original.client ? (
          <div>
            <p>{row.original.client.name}</p>
            <p className="text-sm text-content-subtle">
              {row.original.client.phone}
            </p>
          </div>
        ) : (
          <span className="text-content-subtle">-</span>
        ),
    },
    {
      accessorKey: "state",
      header: "Estado",
      cell: ({ row }) => getStateDisplay(row.original.state),
    },
    {
      accessorKey: "types",
      header: "Tipo",
      cell: ({ row }) => (
        <div className="flex flex-wrap gap-1">
          {(row.original.types || []).map((type) => (
            <span
              key={type}
              className="px-2 py-1 text-xs bg-accent text-primary rounded-full"
            >
              {type}
            </span>
          ))}
        </div>
      ),
    },
    {
      accessorKey: "startDate",
      header: "Fecha",
      cell: ({ row }) => (
        <div className="flex items-center gap-2">
          <Calendar className="h-4 w-4 text-content-subtle" />
          <span>{new Date(row.original.startDate).toLocaleDateString()}</span>
        </div>
      ),
    },
    {
      accessorKey: "assignedWorkers",
      header: "Técnicos",
      cell: ({ row }) => {
        const assignedWorkers = row.original.assignedWorkers || [];
        const totalWorkers = assignedWorkers.length;

        if (totalWorkers === 0) {
          return <span className="text-content-subtle">Sin asignar</span>;
        }

        // Mostrar hasta 2 técnicos directamente
        const displayLimit = 2;
        const displayedWorkers = assignedWorkers.slice(0, displayLimit);
        const remainingCount = totalWorkers - displayLimit;

        return (
          <div className="flex flex-col gap-1">
            {displayedWorkers.map((assignment) => (
              <span key={assignment.workerId} className="text-sm">
                {assignment.worker.name}
              </span>
            ))}

            {remainingCount > 0 && (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <span className="text-xs text-content-subtle cursor-help">
                      + {remainingCount} más
                    </span>
                  </TooltipTrigger>
                  <TooltipContent>
                    <div className="space-y-1 p-1">
                      {assignedWorkers.slice(displayLimit).map((assignment) => (
                        <p key={assignment.workerId} className="text-xs">
                          {assignment.worker.name}
                        </p>
                      ))}
                    </div>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            )}
          </div>
        );
      },
    },
    {
      id: "actions",
      header: "Acciones",
      cell: ({ row }) => (
        <div className="flex space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => handleActionStart(row.original.id!, "view")}
            disabled={loadingTaskAction.id === row.original.id}
          >
            {loadingTaskAction.id === row.original.id &&
            loadingTaskAction.action === "view" ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Eye className="h-4 w-4" />
            )}
          </Button>

          {isAdmin && (
            <>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleActionStart(row.original.id!, "edit")}
                disabled={loadingTaskAction.id === row.original.id}
              >
                {loadingTaskAction.id === row.original.id &&
                loadingTaskAction.action === "edit" ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Edit className="h-4 w-4" />
                )}
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleActionStart(row.original.id!, "delete")}
                disabled={loadingTaskAction.id === row.original.id}
              >
                {loadingTaskAction.id === row.original.id &&
                loadingTaskAction.action === "delete" ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Trash className="h-4 w-4" />
                )}
              </Button>
            </>
          )}
          {row.original.state !== "FINALIZADO" && (
            <Button
              variant="ghost"
              size="sm"
              onClick={() => handleActionStart(row.original.id!, "finalize")}
              disabled={loadingTaskAction.id === row.original.id}
            >
              {loadingTaskAction.id === row.original.id &&
              loadingTaskAction.action === "finalize" ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <CheckCircle className="h-4 w-4" />
              )}
            </Button>
          )}
        </div>
      ),
    },
  ];

  if (isLoading) {
    return (
      <div className="text-center h-96 flex flex-col items-center justify-center">
        <Loader2 className="h-8 w-8 mb-4 text-primary animate-spin" />
        <p>Cargando tareas...</p>
      </div>
    );
  }

  if (tasks.length === 0) {
    return (
      <div className="text-center h-60 flex flex-col items-center justify-center">
        <p className="text-gray-500 mb-2">No hay tareas disponibles</p>
        <p className="text-sm text-gray-400">
          Prueba a cambiar los filtros o crear una nueva tarea
        </p>
      </div>
    );
  }

  return <DataTable columns={columns} data={tasks} />;
}


Ruta: components\tasks\UserMultiSelect.tsx
// web\components\tasks\UserMultiSelect.tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { 
  Command, 
  CommandEmpty, 
  CommandGroup, 
  CommandInput, 
  CommandItem, 
  CommandList 
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogFooter 
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Check, ChevronsUpDown, Loader2, Plus, X, Users } from "lucide-react";
import { User } from "@/services/users";
import { createUser } from "@/services/users";
import { useNotification } from "@/contexts/NotificationContext";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

interface UserMultiSelectProps {
  workers: User[];
  selectedWorkerIds: number[];
  onSelectionChange: (selectedWorkerIds: number[]) => void;
  onUserCreated?: (user: User) => void;
  isLoading?: boolean;
  disabled?: boolean;
}

export default function UserMultiSelect({
  workers,
  selectedWorkerIds,
  onSelectionChange,
  onUserCreated,
  isLoading = false,
  disabled = false,
}: UserMultiSelectProps) {
  const { addNotification } = useNotification();
  const [open, setOpen] = useState(false);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isSavingUser, setIsSavingUser] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [newUser, setNewUser] = useState<Partial<User>>({
    name: "",
    email: "",
    password: "",
    role: "WORKER",
    phone: "",
  });
  const [validationError, setValidationError] = useState<string | null>(null);

  // Filtrar trabajadores según término de búsqueda
  const filteredWorkers = workers.filter((worker) => {
    const search = searchTerm.toLowerCase();
    return (
      worker.name?.toLowerCase().includes(search) ||
      worker.email?.toLowerCase().includes(search)
    );
  });

  // Actualizar selecciones
  const handleSelectWorker = (workerId: number) => {
    if (selectedWorkerIds.includes(workerId)) {
      onSelectionChange(selectedWorkerIds.filter(id => id !== workerId));
    } else {
      onSelectionChange([...selectedWorkerIds, workerId]);
    }
  };

  // Eliminar un trabajador seleccionado
  const handleRemoveWorker = (e: React.MouseEvent, workerId: number) => {
    e.stopPropagation();
    onSelectionChange(selectedWorkerIds.filter(id => id !== workerId));
  };

  // Preparar para agregar nuevo usuario
  const handleAddNewUser = () => {
    setIsAddModalOpen(true);
    setNewUser({
      name: "",
      email: "",
      password: "",
      role: "WORKER",
      phone: "",
    });
    setValidationError(null);
  };

  // Guardar nuevo usuario
  const handleSaveNewUser = async () => {
    // Validación básica
    if (!newUser.name) {
      setValidationError("El nombre es obligatorio");
      return;
    }
    if (!newUser.email) {
      setValidationError("El email es obligatorio");
      return;
    }
    if (!newUser.password) {
      setValidationError("La contraseña es obligatoria");
      return;
    }

    try {
      setIsSavingUser(true);
      const createdUser = await createUser(newUser as User);
      if (createdUser) {
        setIsAddModalOpen(false);
        if (onUserCreated) {
          onUserCreated(createdUser);
        }
        // Seleccionar automáticamente el usuario recién creado
        if (createdUser.id) {
          handleSelectWorker(createdUser.id);
        }
        addNotification("success", "Usuario creado correctamente");
      }
    } catch (error) {
      console.error("Error al crear usuario:", error);
      setValidationError("Error al crear el usuario");
      addNotification("error", "Error al crear el usuario");
    } finally {
      setIsSavingUser(false);
    }
  };

  // Encontrar los usuarios seleccionados
  const selectedUsers = workers.filter(worker => 
    selectedWorkerIds.includes(worker.id)
  );

  // Texto a mostrar en el botón desplegable
  const getButtonText = () => {
    if (isLoading) return "Cargando técnicos...";
    if (selectedWorkerIds.length === 0) return "Seleccionar técnicos";
    if (selectedWorkerIds.length === 1) return `${selectedUsers.length > 0 ? selectedUsers[0].name : '1 técnico seleccionado'}`;
    return `${selectedWorkerIds.length} técnicos seleccionados`;
  };

  return (
    <div className="space-y-2">
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="outline"
            role="combobox"
            aria-expanded={open}
            className="w-full justify-between"
            disabled={isLoading || disabled}
          >
            <div className="flex items-center overflow-hidden">
              <Users className="h-4 w-4 mr-2 text-gray-500" />
              <span className="truncate">{getButtonText()}</span>
            </div>
            {isLoading ? (
              <Loader2 className="ml-2 h-4 w-4 shrink-0 opacity-50 animate-spin" />
            ) : (
              <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[300px] p-0">
          <Command>
            <CommandInput 
              placeholder="Buscar técnico..." 
              value={searchTerm}
              onValueChange={setSearchTerm}
            />
            <CommandList>
              <CommandEmpty>
                <div className="py-3 px-4 text-center space-y-2">
                  <p className="text-sm">No se encontraron técnicos</p>
                  <Button 
                    variant="outline" 
                    size="sm" 
                    className="w-full"
                    onClick={handleAddNewUser}
                  >
                    <Plus className="h-4 w-4 mr-1" />
                    Agregar nuevo técnico
                  </Button>
                </div>
              </CommandEmpty>
              <CommandGroup heading="Técnicos disponibles">
                {filteredWorkers.map((worker) => {
                  const isSelected = selectedWorkerIds.includes(worker.id);
                  return (
                    <CommandItem
                      key={worker.id}
                      value={worker.id.toString()}
                      onSelect={() => handleSelectWorker(worker.id)}
                      className="flex items-center justify-between"
                    >
                      <div className="flex flex-col">
                        <span>{worker.name}</span>
                        <span className="text-xs text-gray-500">{worker.email}</span>
                      </div>
                      {isSelected && <Check className="h-4 w-4 text-primary"/>}
                    </CommandItem>
                  );
                })}
              </CommandGroup>
              <div className="p-2 border-t">
                <Button
                  variant="ghost"
                  size="sm"
                  className="w-full justify-start"
                  onClick={handleAddNewUser}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Agregar nuevo técnico
                </Button>
              </div>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>

      {/* Mostrar usuarios seleccionados como badges */}
      <div className="flex flex-wrap gap-2 mt-2">
        {selectedUsers.map((user) => (
          <Badge key={user.id} variant="secondary" className="px-2 py-1 text-sm">
            {user.name}
            <X 
              className="h-3 w-3 ml-1 cursor-pointer" 
              onClick={(e) => handleRemoveWorker(e, user.id)}
            />
          </Badge>
        ))}
      </div>

      {/* Modal para agregar nuevo usuario */}
      <Dialog open={isAddModalOpen} onOpenChange={setIsAddModalOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Agregar nuevo técnico</DialogTitle>
          </DialogHeader>

          <div className="grid gap-4 py-3">
            <div className="grid gap-2">
              <Label htmlFor="name">Nombre</Label>
              <Input
                id="name"
                value={newUser.name || ""}
                onChange={(e) => setNewUser({...newUser, name: e.target.value})}
                disabled={isSavingUser}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={newUser.email || ""}
                onChange={(e) => setNewUser({...newUser, email: e.target.value})}
                disabled={isSavingUser}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="password">Contraseña</Label>
              <Input
                id="password"
                type="password"
                value={newUser.password || ""}
                onChange={(e) => setNewUser({...newUser, password: e.target.value})}
                disabled={isSavingUser}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="phone">Teléfono (opcional)</Label>
              <Input
                id="phone"
                value={newUser.phone || ""}
                onChange={(e) => setNewUser({...newUser, phone: e.target.value})}
                disabled={isSavingUser}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="role">Rol</Label>
              <Select
                value={newUser.role || "WORKER"}
                onValueChange={(value) => setNewUser({...newUser, role: value})}
                disabled={isSavingUser}
              >
                <SelectTrigger id="role">
                  <SelectValue placeholder="Seleccionar rol" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="WORKER">Técnico</SelectItem>
                  <SelectItem value="ADMIN">Administrador</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {validationError && (
              <div className="text-sm text-red-500 bg-red-50 border border-red-200 p-2 rounded">
                {validationError}
              </div>
            )}
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsAddModalOpen(false)}
              disabled={isSavingUser}
            >
              Cancelar
            </Button>
            <Button 
              onClick={handleSaveNewUser}
              disabled={isSavingUser}
            >
              {isSavingUser ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Guardando...
                </>
              ) : (
                "Guardar"
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

Ruta: components\tasks\UserSelect.tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Plus, Loader2 } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import UserForm from "@/components/users/UserForm";
import { User } from "@/services/users";
import { useNotification } from "@/contexts/NotificationContext";
import { register } from "@/services/auth";

interface UserSelectProps {
  workers: User[];
  value: string;
  onValueChange: (value: string, worker?: User) => void;
  onUserCreated?: (user: User) => void;
  placeholder?: string;
  isLoading?: boolean;
}

export default function UserSelect({
  workers,
  value,
  onValueChange,
  onUserCreated,
  placeholder = "Seleccionar técnico",
  isLoading = false,
}: UserSelectProps) {
  const [isAddingUser, setIsAddingUser] = useState(false);
  const [isCreatingUser, setIsCreatingUser] = useState(false);
  const { addNotification } = useNotification();
  const [processedWorkers, setProcessedWorkers] = useState<User[]>([]);

  useEffect(() => {
    // Procesar workers para asegurarse de que tengan todos los campos necesarios
    if (workers && Array.isArray(workers)) {
      const processed = workers.map((worker) => ({
        ...worker,
        // Asegurar que exista un nombre (usar email si no hay nombre)
        name: worker.name || worker.email || `Técnico ${worker.id}`,
        // Asegurar que tenga un rol (asumir WORKER si no hay rol)
        role: worker.role || "WORKER",
        // Asegurar que tenga un email
        email: worker.email || "",
      }));
      setProcessedWorkers(processed);
      console.log("Workers procesados:", processed);
    } else {
      setProcessedWorkers([]);
      console.log("No hay workers para procesar");
    }
  }, [workers]);

  const handleAddUser = async (userData: User) => {
    try {
      setIsCreatingUser(true);
      // Asegurar que el rol sea WORKER
      userData.role = "WORKER";

      // Extraer solo los campos necesarios para el registro
      const response = await register(
        userData.name,
        userData.email,
        userData.password || ""
      );

      if (response.success && response.data) {
        // Crear un objeto User con los datos devueltos
        const newUser: User = {
          id: response.data.user.id,
          name: userData.name,
          email: userData.email,
          role: "WORKER",
          createdAt: response.data.user.createdAt,
          updatedAt: response.data.user.updatedAt,
        };

        // Si existe la función para notificar la creación de un usuario
        if (onUserCreated) {
          onUserCreated(newUser);
        }

        // Seleccionar el usuario recién creado
        onValueChange(newUser.id.toString(), newUser);
        addNotification("success", "Técnico creado correctamente");
        setIsAddingUser(false);
      } else {
        throw new Error(response.error || "Error al crear el técnico");
      }
    } catch (error) {
      console.error("Error al crear técnico:", error);
      addNotification("error", "Error al crear el técnico");
    } finally {
      setIsCreatingUser(false);
    }
  };

  return (
    <>
      <div className="flex gap-2 items-center">
        <Select
          value={value}
          onValueChange={(val) => {
            if (val === "new") {
              setIsAddingUser(true);
              return;
            }

            // Si seleccionamos sin asignar
            if (val === "-") {
              onValueChange("");
              return;
            }

            // Encontrar el worker correspondiente por ID
            const selectedWorker = processedWorkers.find(
              (w) => w.id.toString() === val
            );
            onValueChange(val, selectedWorker);
          }}
          className="flex-1"
          disabled={isLoading || isCreatingUser}
        >
          <SelectTrigger>
            {isLoading ? (
              <div className="flex items-center">
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                <span>Cargando técnicos...</span>
              </div>
            ) : (
              <SelectValue placeholder={placeholder} />
            )}
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="-">Sin asignar</SelectItem>
            <SelectItem value="new">
              <div className="flex items-center">
                <Plus className="h-4 w-4 mr-2" />
                Crear nuevo técnico
              </div>
            </SelectItem>
            {processedWorkers && processedWorkers.length > 0 ? (
              processedWorkers.map((worker) => (
                <SelectItem key={worker.id} value={worker.id.toString()}>
                  {worker.name || worker.email || `Técnico ${worker.id}`}
                </SelectItem>
              ))
            ) : (
              <SelectItem value="empty" disabled>
                No hay técnicos disponibles
              </SelectItem>
            )}
          </SelectContent>
        </Select>
      </div>

      {/* Formulario para crear nuevo técnico */}
      <UserForm
        isOpen={isAddingUser}
        user={null}
        onSave={handleAddUser}
        onClose={() => setIsAddingUser(false)}
        isLoading={isCreatingUser}
      />
    </>
  );
}


Ruta: components\ui\alert.tsx
// components/ui/alert.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };


Ruta: components\ui\badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-gray-900 text-white hover:bg-gray-800",
        primary:
          "border-transparent bg-blue-100 text-blue-800 hover:bg-blue-200",
        secondary:
          "border-transparent bg-gray-100 text-gray-800 hover:bg-gray-200",
        destructive:
          "border-transparent bg-red-100 text-red-800 hover:bg-red-200",
        success:
          "border-transparent bg-green-100 text-green-800 hover:bg-green-200",
        warning:
          "border-transparent bg-amber-100 text-amber-800 hover:bg-amber-200",
        info:
          "border-transparent bg-blue-100 text-blue-800 hover:bg-blue-200",
        outline: "border-gray-300 text-gray-600 hover:bg-gray-50",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

Ruta: components\ui\button.tsx
// components/ui/button.tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { type VariantProps, cva } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-bold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary-hover",
        destructive: "bg-error text-error-foreground hover:bg-error/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-primary",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-primary",
        link: "underline-offset-4 hover:underline text-primary",
        success: "bg-success text-success-foreground hover:bg-success/90",
        warning: "bg-yellow-600 text-white hover:bg-yellow-700",
        subtle: "bg-accent text-primary hover:bg-accent-hover",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-9 px-3 rounded-md",
        lg: "h-11 px-8 rounded-md",
        xl: "h-12 px-10 rounded-lg",
        icon: "h-10 w-10",
      },
      loading: {
        true: "cursor-not-allowed opacity-70",
      },
      fullWidth: {
        true: "w-full",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
      loading: false,
      fullWidth: false,
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  loading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant,
      size,
      loading,
      leftIcon,
      rightIcon,
      fullWidth,
      asChild = false,
      children,
      disabled,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button";

    return (
      <Comp
        className={cn(
          buttonVariants({ variant, size, loading, fullWidth, className })
        )}
        ref={ref}
        disabled={disabled || loading}
        {...props}
      >
        {loading ? (
          <>
            <svg
              className="mr-2 h-4 w-4 animate-spin"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              ></circle>
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
            Cargando...
          </>
        ) : (
          <>
            {leftIcon && <span className="mr-2">{leftIcon}</span>}
            {children}
            {rightIcon && <span className="ml-2">{rightIcon}</span>}
          </>
        )}
      </Comp>
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };


Ruta: components\ui\calendar.tsx
// web\components\ui\calendar.tsx
"use client";

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";
import { es } from "date-fns/locale";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={false}
      hideWeekdays
      className={cn("p-3 bg-white", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      locale={es}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };


Ruta: components\ui\card.tsx
// components/ui/card.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border border-border bg-background text-content shadow transition-all duration-200",
      className
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLHeadingElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("text-lg font-bold text-content-emphasis", className)}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-content-subtle", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};


Ruta: components\ui\checkbox.tsx
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };


Ruta: components\ui\command.tsx
// web\components\ui\command.tsx
"use client";

import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";

import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground",
      className
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

Ruta: components\ui\confirm-dialog.tsx
//web\components\ui\confirm-dialog.tsx
"use client";

import React from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { AlertTriangle, Loader2 } from "lucide-react";

interface ConfirmDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  onConfirm: () => Promise<void> | void;
  confirmLabel?: string;
  cancelLabel?: string;
  isLoading?: boolean;
}

export function ConfirmDialog({
  open,
  onOpenChange,
  title,
  description,
  onConfirm,
  confirmLabel = "Confirmar",
  cancelLabel = "Cancelar",
  isLoading = false,
}: ConfirmDialogProps) {
  return (
    <Dialog
      open={open}
      onOpenChange={(newOpen) => {
        // Solo permitir cerrar el diálogo si no está en estado de carga
        if (!isLoading || !newOpen) {
          onOpenChange(newOpen);
        }
      }}
    >
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <div className="flex items-center gap-4">
            <div className="w-10 h-10 rounded-full bg-yellow-100 flex items-center justify-center">
              <AlertTriangle className="h-5 w-5 text-yellow-600" />
            </div>
            <DialogTitle>{title}</DialogTitle>
          </div>
        </DialogHeader>
        <div className="py-4">
          <p className="text-content-subtle">{description}</p>
        </div>
        <DialogFooter className="flex justify-end space-x-2">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isLoading}
          >
            {cancelLabel}
          </Button>
          <Button
            variant="destructive"
            onClick={async () => {
              try {
                await onConfirm();
                onOpenChange(false);
              } catch (error) {
                console.error("Error en la acción de confirmación:", error);
                // Mantener el diálogo abierto en caso de error
              }
            }}
            disabled={isLoading}
          >
            {isLoading ? (
              <span className="flex items-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Procesando...
              </span>
            ) : (
              confirmLabel
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\ui\csrf-protected-form.tsx
"use client";

import React, {
  FormHTMLAttributes,
  ReactNode,
  useEffect,
  useState,
  forwardRef,
  FormEvent,
} from "react";
import {
  generateCSRFToken,
  storeCSRFToken,
  validateCSRFToken,
} from "@/lib/tokenService";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";

interface CSRFProtectedFormProps extends FormHTMLAttributes<HTMLFormElement> {
  children: ReactNode;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  className?: string;
  submitText?: string;
  isLoading?: boolean;
  error?: string | null;
  showSubmitButton?: boolean;
  submitButtonProps?: {
    type?: "submit" | "button" | "reset";
    disabled?: boolean;
    variant?:
      | "default"
      | "destructive"
      | "outline"
      | "secondary"
      | "ghost"
      | "link";
    size?: "default" | "sm" | "lg" | "icon";
    className?: string;
  };
}

/**
 * Componente de formulario con protección CSRF integrada
 * Genera un token CSRF al montar y lo incluye automáticamente al enviar el formulario
 */
export const CSRFProtectedForm = forwardRef<
  HTMLFormElement,
  CSRFProtectedFormProps
>(
  (
    {
      children,
      onSubmit,
      className,
      submitText = "Guardar",
      isLoading = false,
      error = null,
      showSubmitButton = true,
      submitButtonProps = {},
      ...props
    },
    ref
  ) => {
    const [csrfToken, setCsrfToken] = useState<string>("");

    // Generar un nuevo token CSRF al montar el componente
    useEffect(() => {
      const token = generateCSRFToken();
      setCsrfToken(token);
      storeCSRFToken(token);
    }, []);

    // Manejador de envío con validación CSRF
    const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();

      // Validar que el token del formulario coincida con el almacenado
      if (validateCSRFToken(csrfToken)) {
        // Pasar el evento al manejador proporcionado
        onSubmit(e);
      } else {
        console.error("Error de validación CSRF: Los tokens no coinciden");
        // Podríamos mostrar un mensaje de error o tomar otra acción
        alert(
          "Error de seguridad: Por favor, recarga la página e intenta nuevamente."
        );
      }
    };

    return (
      <form
        onSubmit={handleSubmit}
        className={cn("space-y-6", className)}
        ref={ref}
        {...props}
      >
        {/* Token CSRF oculto */}
        <input type="hidden" name="csrfToken" value={csrfToken} />

        {/* Contenido del formulario */}
        <div className="space-y-4">{children}</div>

        {/* Mensaje de error */}
        {error && (
          <div className="p-3 rounded-lg bg-error/10 border border-error/20">
            <p className="text-sm text-error text-center">{error}</p>
          </div>
        )}

        {/* Botón de envío */}
        {showSubmitButton && (
          <Button
            type="submit"
            disabled={isLoading || submitButtonProps.disabled}
            variant={submitButtonProps.variant || "default"}
            size={submitButtonProps.size || "default"}
            className={cn("w-full", submitButtonProps.className)}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Cargando...
              </>
            ) : (
              submitText
            )}
          </Button>
        )}
      </form>
    );
  }
);

CSRFProtectedForm.displayName = "CSRFProtectedForm";


Ruta: components\ui\dialog.tsx
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";
import { useScrollLock } from "@/hooks/useScrollLock"; // Ajusta la ruta según tu estructura

const Dialog = ({ children, open, onOpenChange, ...props }) => {
  // Usar nuestro hook personalizado
  useScrollLock(open);

  return <DialogPrimitive.Root open={open} onOpenChange={onOpenChange} {...props}>{children}</DialogPrimitive.Root>;
};

const DialogTrigger = DialogPrimitive.Trigger;
const DialogClose = DialogPrimitive.Close;

type ExtendedDialogPortalProps = DialogPrimitive.DialogPortalProps & {
  className?: string;
};

const DialogPortal = ({
  children,
  className,
  ...props
}: ExtendedDialogPortalProps) => (
  <DialogPrimitive.Portal {...props}>
    <div className={cn(className)}>{children}</div>
  </DialogPrimitive.Portal>
);
DialogPortal.displayName = "DialogPortal";

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50",
      "data-[state=open]:animate-fadeIn",
      "data-[state=closed]:animate-fadeOut",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = "DialogOverlay";

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & {
    className?: string;
    children?: React.ReactNode;
  }
>(({ className, children, ...props }, ref) => {
  // El manejo de scroll ahora está en el componente Dialog con el hook
  return (
    <DialogPortal>
      <DialogOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed z-50 top-1/2 left-1/2 max-h-[85vh] w-full max-w-2xl -translate-x-1/2 -translate-y-1/2 overflow-y-auto rounded-lg bg-background p-6 shadow-lg border border-border",
          "data-[state=open]:animate-zoomIn",
          "data-[state=closed]:animate-zoomOut",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-full p-1 text-content hover:bg-accent hover:text-primary">
          <X className="h-4 w-4" />
          <span className="sr-only">Cerrar</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
});
DialogContent.displayName = "DialogContent";

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-bold text-content-emphasis", className)}
    {...props}
  />
));
DialogTitle.displayName = "DialogTitle";

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-content-subtle", className)}
    {...props}
  />
));
DialogDescription.displayName = "DialogDescription";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
  DialogClose,
};

Ruta: components\ui\dropdown-menu.tsx
"use client";

import React, { forwardRef, ElementRef, ComponentPropsWithoutRef } from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;
const DropdownMenuGroup = DropdownMenuPrimitive.Group;
const DropdownMenuPortal = DropdownMenuPrimitive.Portal;
const DropdownMenuSub = DropdownMenuPrimitive.Sub;
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "bg-white flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-white p-1 text-content shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.Content>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-border bg-background p-1 text-content shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.Item>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-primary" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.Label>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-content",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = forwardRef<
  ElementRef<typeof DropdownMenuPrimitive.Separator>,
  ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-content-subtle",
        className
      )}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};


Ruta: components\ui\entity-form.tsx
"use client";

import React, { ReactNode } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { CSRFProtectedForm } from "@/components/ui/csrf-protected-form";

interface EntityFormProps {
  isOpen: boolean;
  onClose: (e?: React.MouseEvent) => void;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  title: string;
  children: ReactNode;
  isLoading?: boolean;
  error?: string | null;
  footerContent?: ReactNode;
  formClassName?: string;
  maxWidth?: string;
  preventClose?: boolean;
}

export function EntityForm({
  isOpen,
  onClose,
  onSubmit,
  title,
  children,
  isLoading = false,
  error = null,
  footerContent,
  formClassName,
  maxWidth = "max-w-md",
  preventClose = false,
}: EntityFormProps) {
  const handleOpenChange = (open: boolean) => {
    if (!open && !preventClose) {
      onClose();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleOpenChange}>
      <DialogContent className={maxWidth} onClick={(e) => e.stopPropagation()}>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>

        <CSRFProtectedForm
          onSubmit={(e) => {
            e.stopPropagation();
            onSubmit(e);
            return false;
          }}
          className={formClassName}
          isLoading={isLoading}
          error={error}
          showSubmitButton={false} // No mostramos el botón predeterminado para poder personalizarlo en el footer
        >
          {children}

          <DialogFooter className="flex justify-end space-x-2 pt-4">
            {footerContent || (
              <>
                <Button
                  variant="outline"
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onClose(e);
                  }}
                  type="button"
                >
                  Cancelar
                </Button>
                <Button
                  type="submit"
                  disabled={isLoading}
                  onClick={(e) => e.stopPropagation()}
                >
                  {isLoading ? "Guardando..." : "Guardar"}
                </Button>
              </>
            )}
          </DialogFooter>
        </CSRFProtectedForm>
      </DialogContent>
    </Dialog>
  );
}


Ruta: components\ui\error-message.tsx
// components/ui/error-message.tsx (mejorado)
"use client";

import { useState } from "react";
import {
  AlertCircle,
  X,
  ChevronDown,
  ChevronUp,
  RefreshCw,
  HelpCircle,
  Shield,
  Database,
  AlertTriangle,
  FileWarning,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { ErrorType } from "@/lib/errorHandler";
import { Button } from "@/components/ui/button";

interface ErrorMessageProps {
  type: ErrorType | string;
  message: string;
  details?: string | React.ReactNode;
  statusCode?: number;
  timestamp?: number;
  action?: () => void;
  actionLabel?: string;
  showClose?: boolean;
  onClose?: () => void;
  className?: string;
  severity?: "low" | "medium" | "high" | "critical";
}

/**
 * Componente para mostrar mensajes de error detallados con acciones
 * y la posibilidad de mostrar más información técnica
 */
export function ErrorMessage({
  type,
  message,
  details,
  statusCode,
  timestamp,
  action,
  actionLabel = "Reintentar",
  showClose = true,
  onClose,
  className,
  severity = "medium",
}: ErrorMessageProps) {
  const [expanded, setExpanded] = useState(false);

  // Determinar el estilo según el tipo de error
  const getErrorStyle = (type: string) => {
    if (type.startsWith("auth/")) {
      return "border-orange-400 bg-orange-50 text-orange-700";
    } else if (type.startsWith("api/")) {
      return "border-blue-400 bg-blue-50 text-blue-700";
    } else if (type.startsWith("validation/")) {
      return "border-yellow-400 bg-yellow-50 text-yellow-700";
    } else if (type.startsWith("data/")) {
      return "border-purple-400 bg-purple-50 text-purple-700";
    } else if (type.startsWith("csrf/")) {
      return "border-red-500 bg-red-50 text-red-800";
    } else if (type.startsWith("security/")) {
      return "border-red-600 bg-red-100 text-red-900";
    } else {
      return "border-red-400 bg-red-50 text-red-700";
    }
  };

  // Determinar el título según el tipo de error
  const getErrorTitle = (type: string) => {
    if (type.startsWith("auth/")) {
      return "Error de autenticación";
    } else if (type.startsWith("api/")) {
      return "Error de API";
    } else if (type.startsWith("validation/")) {
      return "Error de validación";
    } else if (type.startsWith("data/")) {
      return "Error de datos";
    } else if (type.startsWith("csrf/")) {
      return "Error de seguridad CSRF";
    } else if (type.startsWith("security/")) {
      return "Error de seguridad";
    } else if (type === "unknown/error") {
      return "Error desconocido";
    } else {
      return "Error";
    }
  };

  // Obtener icono para el tipo de error
  const ErrorIcon = () => {
    if (type.startsWith("auth/")) {
      return <Shield className="h-5 w-5" />;
    } else if (type.startsWith("api/")) {
      return <AlertCircle className="h-5 w-5" />;
    } else if (type.startsWith("validation/")) {
      return <FileWarning className="h-5 w-5" />;
    } else if (type.startsWith("data/")) {
      return <Database className="h-5 w-5" />;
    } else if (type.startsWith("csrf/") || type.startsWith("security/")) {
      return <Shield className="h-5 w-5" />;
    } else {
      return <AlertTriangle className="h-5 w-5" />;
    }
  };

  // Clases para la severidad
  const getSeverityClasses = () => {
    switch (severity) {
      case "low":
        return "border-l-4 border-l-yellow-400";
      case "medium":
        return "border-l-4 border-l-orange-400";
      case "high":
        return "border-l-4 border-l-red-500";
      case "critical":
        return "border-l-4 border-l-red-700 shadow-md";
      default:
        return "border-l-4 border-l-orange-400";
    }
  };

  return (
    <div
      className={cn(
        "rounded-md border p-4 relative",
        getErrorStyle(type),
        getSeverityClasses(),
        className
      )}
    >
      {/* Cabecera del mensaje */}
      <div className="flex items-start justify-between">
        <div className="flex items-center">
          <ErrorIcon />
          <div className="ml-3">
            <h3 className="text-sm font-medium">{getErrorTitle(type)}</h3>
            <div className="mt-1 text-sm">{message}</div>
          </div>
        </div>

        {/* Botón de cierre */}
        {showClose && onClose && (
          <button
            type="button"
            className="ml-auto inline-flex h-6 w-6 items-center justify-center rounded-md"
            onClick={onClose}
            aria-label="Cerrar mensaje de error"
          >
            <X className="h-4 w-4" />
            <span className="sr-only">Cerrar</span>
          </button>
        )}
      </div>

      {/* Acciones */}
      <div className="mt-3 flex items-center gap-2">
        {action && (
          <Button
            variant="secondary"
            size="sm"
            onClick={action}
            className="inline-flex items-center"
          >
            <RefreshCw className="mr-2 h-3 w-3" />
            {actionLabel}
          </Button>
        )}

        {details && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setExpanded(!expanded)}
            className="inline-flex items-center"
          >
            {expanded ? (
              <>
                <ChevronUp className="mr-2 h-3 w-3" />
                Ocultar detalles
              </>
            ) : (
              <>
                <ChevronDown className="mr-2 h-3 w-3" />
                Ver detalles
              </>
            )}
          </Button>
        )}

        {statusCode && (
          <Button
            variant="link"
            size="sm"
            className="ml-auto text-xs text-gray-500"
            asChild
          >
            
              href={`https://developer.mozilla.org/es/docs/Web/HTTP/Status/${statusCode}`}
              target="_blank"
              rel="noopener noreferrer"
            >
              <HelpCircle className="mr-1 h-3 w-3" />
              Más información sobre el error {statusCode}
            </a>
          </Button>
        )}
      </div>

      {/* Detalles técnicos (expandibles) */}
      {expanded && details && (
        <div className="mt-3 border-t pt-3 text-sm">
          <h4 className="font-medium mb-1">Detalles técnicos:</h4>
          {typeof details === "string" ? (
            <pre className="bg-gray-100 p-2 rounded text-xs overflow-auto max-h-40">
              {details}
            </pre>
          ) : (
            details
          )}

          {timestamp && (
            <div className="mt-2 text-xs text-gray-500">
              Ocurrido el: {new Date(timestamp).toLocaleString()}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

Ruta: components\ui\form-input-sanitized.tsx
// components/ui/form-input-sanitized.tsx (mejorado)
"use client";

import React, { useState, useEffect, InputHTMLAttributes } from "react";
import { Input } from "@/components/ui/input";
import {
  FormField,
  FormLabel,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import {
  sanitizeText,
  isValidEmail,
  isValidPhone,
  isValidURL,
  sanitizeSQLInput,
} from "@/lib/inputSanitizer";
import { cn } from "@/lib/utils";
import { LucideIcon } from "lucide-react";

// Tipos de validación disponibles
type ValidationType =
  | "email"
  | "phone"
  | "url"
  | "text"
  | "number"
  | "sql"
  | "custom";

interface FormInputSanitizedProps
  extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  description?: string;
  icon?: LucideIcon;
  validationType?: ValidationType;
  customValidator?: (value: string) => boolean;
  customErrorMessage?: string;
  onSanitizedChange?: (value: string) => void;
  containerClassName?: string;
  fullWidth?: boolean;
  sanitize?: boolean; // Opción para desactivar sanitización en casos específicos
}

/**
 * Componente de entrada con sanitización y validación integrada
 */
export function FormInputSanitized({
  label,
  description,
  icon: Icon,
  validationType = "text",
  customValidator,
  customErrorMessage,
  onSanitizedChange,
  containerClassName,
  fullWidth = false,
  className,
  value,
  onChange,
  onBlur,
  sanitize = true,
  ...props
}: FormInputSanitizedProps) {
  const [inputValue, setInputValue] = useState((value as string) || "");
  const [sanitizedValue, setSanitizedValue] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [touched, setTouched] = useState(false);

  // Actualizar el estado interno cuando cambia el valor externo
  useEffect(() => {
    if (value !== undefined && value !== inputValue) {
      setInputValue(value as string);
      sanitizeAndValidate(value as string);
    }
  }, [value]);

  /**
   * Sanitiza y valida el valor de entrada
   */
  const sanitizeAndValidate = (val: string) => {
    if (!sanitize) {
      setSanitizedValue(val);
      return val;
    }

    // Sanitizar el texto de entrada según el tipo
    let sanitized = val;
    switch (validationType) {
      case "sql":
        sanitized = sanitizeSQLInput(val);
        break;
      case "email":
        // Para email, solo sanitizamos caracteres HTML, no el formato del email
        sanitized = sanitizeText(val);
        break;
      default:
        sanitized = sanitizeText(val);
    }

    setSanitizedValue(sanitized);

    // Si hay una función de cambio externa, llamarla con el valor sanitizado
    if (onSanitizedChange) {
      onSanitizedChange(sanitized);
    }

    // Validar según el tipo especificado
    if (touched) {
      validateInput(sanitized);
    }

    return sanitized;
  };

  /**
   * Valida el valor de entrada según el tipo especificado
   */
  const validateInput = (val: string): boolean => {
    // Si el campo es requerido y está vacío
    if (props.required && !val) {
      setError("Este campo es requerido");
      return false;
    }

    // Si el campo está vacío y no es requerido, no hay error
    if (!val) {
      setError(null);
      return true;
    }

    // Validar según el tipo
    switch (validationType) {
      case "email":
        if (!isValidEmail(val)) {
          setError("Por favor, ingresa un correo electrónico válido");
          return false;
        }
        break;
      case "phone":
        if (!isValidPhone(val)) {
          setError("Por favor, ingresa un número de teléfono válido");
          return false;
        }
        break;
      case "url":
        if (!isValidURL(val)) {
          setError("Por favor, ingresa una URL válida");
          return false;
        }
        break;
      case "number":
        if (isNaN(Number(val))) {
          setError("Por favor, ingresa un número válido");
          return false;
        }
        break;
      case "sql":
        // Validar que no contiene patrones sospechosos de SQL injection
        const suspiciousPatterns =
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|ALTER|UNION|CREATE|EXEC)\b)|(--)|(\/\*)/i;
        if (suspiciousPatterns.test(val)) {
          setError("La entrada contiene caracteres no permitidos");
          return false;
        }
        break;
      case "custom":
        if (customValidator && !customValidator(val)) {
          setError(customErrorMessage || "Entrada no válida");
          return false;
        }
        break;
    }

    // Si pasó todas las validaciones, no hay error
    setError(null);
    return true;
  };

  /**
   * Manejador del evento de cambio
   */
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    const sanitized = sanitizeAndValidate(newValue);

    // Propagar el evento con el valor sanitizado
    if (onChange) {
      const syntheticEvent = {
        ...e,
        target: {
          ...e.target,
          value: sanitized,
        },
      };
      onChange(syntheticEvent as React.ChangeEvent<HTMLInputElement>);
    }
  };

  /**
   * Manejador del evento de desenfoque
   */
  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    setTouched(true);
    validateInput(sanitizedValue);

    if (onBlur) {
      onBlur(e);
    }
  };

  return (
    <FormField className={containerClassName}>
      {label && (
        <FormLabel>
          <div className="flex items-center gap-2 relative">
            {Icon && <Icon className="h-4 w-4 text-content-subtle" />}
            {label}
          </div>
        </FormLabel>
      )}

      <Input
        className={cn(
          Icon && "pl-8",
          error && "border-error focus:ring-error",
          fullWidth && "w-full",
          className
        )}
        value={inputValue}
        onChange={handleChange}
        onBlur={handleBlur}
        {...props}
      />

      {description && <FormDescription>{description}</FormDescription>}
      {error && <FormMessage>{error}</FormMessage>}
    </FormField>
  );
}


Ruta: components\ui\form-input.tsx
// components/ui/form-input.tsx
import {
  FormField,
  FormLabel,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { cn } from "@/lib/utils";
import { LucideIcon } from "lucide-react";

interface FormInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  icon?: LucideIcon;
  description?: string;
  error?: string;
  fullWidth?: boolean;
  containerClassName?: string;
}

export function FormInput({
  label,
  icon: Icon,
  description,
  error,
  fullWidth = false,
  containerClassName,
  className,
  disabled,
  ...props
}: FormInputProps) {
  return (
    <FormField className={containerClassName}>
      <FormLabel>
        <div className="flex items-center gap-2 relative">
          {Icon && (
            <Icon className="h-4 w-4 text-content-subtle absolute top-3 left-2" />
          )}
          {label && label}
        </div>
      </FormLabel>
      <Input
        className={cn(
          Icon && "pl-8 !m-0",
          error && "border-error focus:ring-error",
          className
        )}
        disabled={disabled}
        {...props}
      />
      {description && <FormDescription>{description}</FormDescription>}
      {error && <FormMessage>{error}</FormMessage>}
    </FormField>
  );
}


Ruta: components\ui\form-switch.tsx
import { Switch } from "./switch";
import { FormField, FormLabel, FormDescription } from "@/components/ui/form";
import { LucideIcon } from "lucide-react";

interface FormSwitchProps {
  label?: string;
  description?: string;
  checked: boolean;
  onCheckedChange: (checked: boolean) => void;
  icon?: LucideIcon;
  size?: "sm" | "md" | "lg";
  disabled?: boolean;
  className?: string;
}

export function FormSwitch({
  label,
  description,
  checked,
  onCheckedChange,
  icon: Icon,
  size,
  disabled,
  className,
}: FormSwitchProps) {
  return (
    <div className="flex items-center justify-between py-3">
      <div className="flex items-center gap-3">
        {Icon && <Icon className="h-5 w-5 text-content-subtle" />}
        <div>
          {label && <p className="font-medium">{label}</p>}
          {description && (
            <p className="text-sm text-content-subtle">{description}</p>
          )}
        </div>
      </div>
      <Switch
        checked={checked}
        onCheckedChange={onCheckedChange}
        size={size}
        disabled={disabled}
        className={className}
      />
    </div>
  );
}


Ruta: components\ui\form-textarea.tsx
// components/ui/form-textarea.tsx
import {
  FormField,
  FormLabel,
  FormDescription,
  FormMessage,
} from "@/components/ui/form";
import { cn } from "@/lib/utils";
import { LucideIcon } from "lucide-react";

interface FormTextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  label?: string;
  icon?: LucideIcon;
  description?: string;
  error?: string;
  fullWidth?: boolean;
  containerClassName?: string;
}

export function FormTextarea({
  label,
  icon: Icon,
  description,
  error,
  fullWidth = false,
  containerClassName,
  className,
  disabled,
  ...props
}: FormTextareaProps) {
  return (
    <FormField className={containerClassName}>
      <FormLabel>
        <div className="flex items-center gap-2">
          {Icon && <Icon className="h-4 w-4 text-content-subtle" />}
          {label}
        </div>
      </FormLabel>
      <textarea
        className={cn(
          "min-h-[100px] w-full rounded-md border border-border bg-background px-3 py-2 text-sm",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
          "disabled:cursor-not-allowed disabled:opacity-50",
          "resize-y",
          className
        )}
        disabled={disabled}
        {...props}
      />
      {description && <FormDescription>{description}</FormDescription>}
      {error && <FormMessage>{error}</FormMessage>}
    </FormField>
  );
}


Ruta: components\ui\form.tsx
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/utils";

const FormField = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("space-y-2", className)} {...props} />
));
FormField.displayName = "FormField";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
));
FormLabel.displayName = "FormLabel";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-content-subtle", className)}
    {...props}
  />
));
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm font-medium text-error", className)}
    {...props}
  >
    {children}
  </p>
));
FormMessage.displayName = "FormMessage";

export { FormField, FormLabel, FormDescription, FormMessage };


Ruta: components\ui\icons.tsx
// components/ui/icons.tsx
export function CheckIcon(props: React.ComponentProps<"svg">) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <polyline points="20 6 9 17 4 12" />
    </svg>
  );
}

export function AlertIcon(props: React.ComponentProps<"svg">) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" />
      <path d="M12 9v4" />
      <path d="M12 17h.01" />
    </svg>
  );
}

export function XIcon(props: React.ComponentProps<"svg">) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M18 6 6 18" />
      <path d="m6 6 12 12" />
    </svg>
  );
}


Ruta: components\ui\input.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

export const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-border bg-background px-3 py-2 text-sm ring-offset-background",
          "file:border-0 file:bg-transparent file:text-sm file:font-medium",
          "placeholder:text-content-subtle",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2",
          "disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);

Input.displayName = "Input";


Ruta: components\ui\label.tsx
// web\components\ui\label.tsx
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };


Ruta: components\ui\popover.tsx
// web\components\ui\popover.tsx
"use client";

import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-white p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
      style={{
        ...props.style,
        backgroundColor: "white",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
      }}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };


Ruta: components\ui\scroll-area.tsx
// components/ui/scroll-area.tsx
"use client";

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";


import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };


Ruta: components\ui\select.tsx
//web\components\ui\select.tsx
"use client";

import React, { forwardRef, ElementRef, ComponentPropsWithoutRef } from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

const SelectTrigger = forwardRef<
  ElementRef<typeof SelectPrimitive.Trigger>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-border bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-content-subtle focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <ChevronDown className="h-4 w-4 opacity-50" />
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = forwardRef<
  ElementRef<typeof SelectPrimitive.Content>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-border bg-background text-content shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectItem = forwardRef<
  ElementRef<typeof SelectPrimitive.Item>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-primary data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4 text-primary" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectLabel = forwardRef<
  ElementRef<typeof SelectPrimitive.Label>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectSeparator = forwardRef<
  ElementRef<typeof SelectPrimitive.Separator>,
  ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
};


Ruta: components\ui\sheet.tsx
// components/ui/sheet.tsx
"use client";

import * as React from "react";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Cerrar</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};


Ruta: components\ui\skeleton.tsx
// components/ui/skeleton.tsx
import { cn } from "@/lib/utils";

interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {}

export function Skeleton({ className, ...props }: SkeletonProps) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-gray-200", className)}
      {...props}
    />
  );
}


Ruta: components\ui\switch.tsx
"use client";

import React, { forwardRef, ElementRef, ComponentPropsWithoutRef } from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "@/lib/utils";

const Switch = forwardRef<
  ElementRef<typeof SwitchPrimitives.Root>,
  ComponentPropsWithoutRef<typeof SwitchPrimitives.Root> & {
    size?: "sm" | "md" | "lg";
  }
>(({ className, size = "md", ...props }, ref) => {
  const sizes = {
    sm: {
      container: "h-5 w-9",
      thumb: "h-3.5 w-3.5",
      translate: "translate-x-4",
    },
    md: {
      container: "h-6 w-11",
      thumb: "h-5 w-5",
      translate: "translate-x-5",
    },
    lg: {
      container: "h-7 w-14",
      thumb: "h-6 w-6",
      translate: "translate-x-7",
    },
  };

  return (
    <SwitchPrimitives.Root
      className={cn(
        "peer inline-flex shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent",
        "transition-colors duration-200 ease-in-out",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-background",
        "disabled:cursor-not-allowed disabled:opacity-50",
        "data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        sizes[size].container,
        className
      )}
      {...props}
      ref={ref}
    >
      <SwitchPrimitives.Thumb
        className={cn(
          "pointer-events-none rounded-full bg-background",
          "shadow-lg ring-0 transition-transform duration-200 ease-in-out",
          "data-[state=checked]:bg-primary-foreground data-[state=unchecked]:bg-content",
          "data-[state=checked]:" + sizes[size].translate,
          sizes[size].thumb
        )}
      />
    </SwitchPrimitives.Root>
  );
});
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };


Ruta: components\ui\table.tsx
// components/ui/table.tsx
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
  getPaginationRowModel,
  getSortedRowModel,
  type ColumnDef,
  type SortingState,
} from "@tanstack/react-table";
import {
  ChevronDown,
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
  ArrowUpDown,
} from "lucide-react";
import { Button } from "./button";

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  onRowClick?: (row: TData) => void;
  pagination?: boolean;
  sorting?: boolean;
}

interface TablePaginationProps {
  table: any;
}

const TablePagination = ({ table }: TablePaginationProps) => {
  return (
    <div className="flex items-center justify-between px-2 py-4">
      <div className="flex-1 text-sm text-content-subtle hidden md:block">
        {table.getFilteredSelectedRowModel().rows.length} de{" "}
        {table.getFilteredRowModel().rows.length} fila(s) seleccionada(s).
      </div>
      <div className="flex items-center space-x-6 lg:space-x-8">
        <div className="flex items-center space-x-2">
          <p className="text-sm font-medium hidden md:block">Filas por página</p>
          <select
            value={table.getState().pagination.pageSize}
            onChange={(e) => {
              table.setPageSize(Number(e.target.value));
            }}
            className="h-8 w-[70px] rounded-md border border-input bg-transparent"
          >
            {[10, 20, 30, 40, 50].map((pageSize) => (
              <option key={pageSize} value={pageSize}>
                {pageSize}
              </option>
            ))}
          </select>
        </div>
        <div className="flex w-[100px] items-center justify-center text-sm font-medium">
          Página {table.getState().pagination.pageIndex + 1} de{" "}
          {table.getPageCount()}
        </div>
        <div className="flex items-center space-x-2">
          <Button
            variant="outline"
            className="hidden h-8 w-8 p-0 lg:flex"
            onClick={() => table.setPageIndex(0)}
            disabled={!table.getCanPreviousPage()}
          >
            <span className="sr-only">Ir a la primera página</span>
            <ChevronsLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="h-8 w-8 p-0"
            onClick={() => table.previousPage()}
            disabled={!table.getCanPreviousPage()}
          >
            <span className="sr-only">Ir a la página anterior</span>
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="h-8 w-8 p-0"
            onClick={() => table.nextPage()}
            disabled={!table.getCanNextPage()}
          >
            <span className="sr-only">Ir a la página siguiente</span>
            <ChevronRight className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="hidden h-8 w-8 p-0 lg:flex"
            onClick={() => table.setPageIndex(table.getPageCount() - 1)}
            disabled={!table.getCanNextPage()}
          >
            <span className="sr-only">Ir a la última página</span>
            <ChevronsRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};

export function DataTable<TData, TValue>({
  columns,
  data,
  onRowClick,
  pagination = true,
  sorting = true,
}: DataTableProps<TData, TValue>) {
  const [sorting_, setSorting] = React.useState<SortingState>([]);

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: pagination ? getPaginationRowModel() : undefined,
    getSortedRowModel: sorting ? getSortedRowModel() : undefined,
    onSortingChange: setSorting,
    state: {
      sorting: sorting_,
    },
  });

  return (
    <div className="rounded-md border border-border">
      <div className="relative w-full overflow-auto">
        <table className="w-full caption-bottom text-sm">
          <thead className="[&_tr]:border-b bg-accent/50">
            {table.getHeaderGroups().map((headerGroup) => (
              <tr key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <th
                      key={header.id}
                      className="h-12 px-4 text-left align-middle font-medium text-content [&:has([role=checkbox])]:pr-0"
                    >
                      {header.isPlaceholder ? null : (
                        <div>
                          {sorting && header.column.getCanSort() ? (
                            <Button
                              variant="ghost"
                              size="sm"
                              className="-ml-3 h-8 data-[state=open]:bg-accent hover:text-primary"
                              onClick={header.column.getToggleSortingHandler()}
                            >
                              {flexRender(
                                header.column.columnDef.header,
                                header.getContext()
                              )}
                              {{
                                asc: <ChevronDown className="ml-2 h-4 w-4" />,
                                desc: (
                                  <ChevronDown className="ml-2 h-4 w-4 rotate-180" />
                                ),
                              }[header.column.getIsSorted() as string] ?? (
                                <ArrowUpDown className="ml-2 h-4 w-4" />
                              )}
                            </Button>
                          ) : (
                            flexRender(
                              header.column.columnDef.header,
                              header.getContext()
                            )
                          )}
                        </div>
                      )}
                    </th>
                  );
                })}
              </tr>
            ))}
          </thead>
          <tbody className="[&_tr:last-child]:border-0">
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <tr
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                  className={cn(
                    "border-b transition-colors hover:bg-accent/30 data-[state=selected]:bg-accent/50",
                    onRowClick && "cursor-pointer"
                  )}
                  onClick={() => onRowClick?.(row.original)}
                >
                  {row.getVisibleCells().map((cell) => (
                    <td
                      key={cell.id}
                      className="p-4 align-middle [&:has([role=checkbox])]:pr-0"
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </td>
                  ))}
                </tr>
              ))
            ) : (
              <tr>
                <td
                  colSpan={columns.length}
                  className="h-24 text-center text-content-subtle"
                >
                  No hay resultados.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      {pagination && <TablePagination table={table} />}
    </div>
  );
}

// Re-export the type helpers
export type { ColumnDef } from "@tanstack/react-table";


Ruta: components\ui\toast.tsx
// components/ui/toast.tsx
import * as React from "react";
import { Cross2Icon } from "@radix-ui/react-icons";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed bottom-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};


Ruta: components\ui\toaster.tsx
// components/ui/toaster.tsx
"use client";

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({
        id,
        title,
        description,
        action,
        icon,
        ...props
      }) {
        return (
          <Toast key={id} {...props}>
            {icon && <div className="mr-2">{icon}</div>}
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}


Ruta: components\ui\tooltip.tsx
// web\components\ui\tooltip.tsx
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

Ruta: components\ui\use-toast.tsx
// components/ui/use-toast.tsx
import * as React from "react";
import { ReactNode } from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 5;
const TOAST_REMOVE_DELAY = 1000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
  icon?: ReactNode;
  duration?: number;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: string;
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: string;
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: ((state: State) => void)[] = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open: boolean) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };


Ruta: components\users\UserForm.tsx
// web/components/users/UserForm.tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { FormField, FormLabel } from "@/components/ui/form";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { User } from "@/services/users";
import { Loader2 } from "lucide-react";
import { useSession } from "next-auth/react";

interface UserFormProps {
  isOpen: boolean;
  user: User | null;
  onSave: (userData: User, newPassword?: string) => Promise<void>;
  onClose: () => void;
  isLoading?: boolean;
  showRoleSelector?: boolean;
}

export default function UserForm({
  isOpen,
  user,
  onSave,
  onClose,
  isLoading = false,
  showRoleSelector = false,
}: UserFormProps) {
  const { data: session } = useSession();
  const [userForm, setUserForm] = useState<User & { password?: string }>({
    id: 0, // Temporal, se sobrescribe
    name: "",
    email: "",
    role: "WORKER",
    password: "",
    phone: "",
  });
  const [newPasswordByAdmin, setNewPasswordByAdmin] = useState(""); // Para admin cambiando contraseña de otro
  const [confirmNewPasswordByAdmin, setConfirmNewPasswordByAdmin] =
    useState(""); // Para admin

  const [error, setError] = useState<string | null>(null);

  const loggedInUser = session?.user;
  const isAdminLoggedIn = loggedInUser?.role === "ADMIN";
  // Determina si un admin está editando a OTRO usuario (no a sí mismo)
  const isAdminEditingOtherUser =
    isAdminLoggedIn && user && user.id !== parseInt(loggedInUser?.id || "0");

  useEffect(() => {
    if (isOpen) {
      // Resetear estados solo cuando el diálogo se abre
      if (user) {
        setUserForm({
          ...user,
          password: "", // No precargar contraseña al editar
        });
      } else {
        setUserForm({
          id: 0, // Temporal
          name: "",
          email: "",
          role: "WORKER",
          password: "", // Para creación de nuevo usuario
          phone: "",
        });
      }
      setNewPasswordByAdmin("");
      setConfirmNewPasswordByAdmin("");
      setError(null);
    }
  }, [user, isOpen]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!userForm.name || !userForm.email) {
      setError("Nombre y email son obligatorios.");
      return;
    }

    let passwordPayload: string | undefined = undefined;

    if (!user) {
      // Creando un nuevo usuario
      if (!userForm.password || userForm.password.length < 8) {
        setError(
          "La contraseña para el nuevo usuario debe tener al menos 8 caracteres."
        );
        return;
      }
      if (userForm.password !== confirmNewPasswordByAdmin) {
        // Reutilizamos confirmNewPasswordByAdmin para la confirmación del nuevo usuario
        setError("Las contraseñas para el nuevo usuario no coinciden.");
        return;
      }
      passwordPayload = userForm.password;
    } else if (isAdminEditingOtherUser) {
      // Admin editando a otro usuario
      if (newPasswordByAdmin) {
        // Si el admin ingresó una nueva contraseña
        if (newPasswordByAdmin.length < 8) {
          setError(
            "La nueva contraseña establecida por el administrador debe tener al menos 8 caracteres."
          );
          return;
        }
        if (newPasswordByAdmin !== confirmNewPasswordByAdmin) {
          setError(
            "Las nuevas contraseñas establecidas por el administrador no coinciden."
          );
          return;
        }
        passwordPayload = newPasswordByAdmin;
      }
    }

    try {
      // El password en userForm (para creación) o newPasswordByAdmin (para admin editando)
      // se pasa como segundo argumento a onSave.
      await onSave(userForm, passwordPayload);
    } catch (err: any) {
      setError(err.message || "Error al guardar el usuario");
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && !isLoading && onClose()}
    >
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>{user ? "Editar Usuario" : "Nuevo Usuario"}</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          <FormField>
            <FormLabel>Nombre</FormLabel>
            <Input
              value={userForm.name}
              onChange={(e) =>
                setUserForm({ ...userForm, name: e.target.value })
              }
              required
              disabled={isLoading}
            />
          </FormField>

          <FormField>
            <FormLabel>Email</FormLabel>
            <Input
              type="email"
              value={userForm.email}
              onChange={(e) =>
                setUserForm({ ...userForm, email: e.target.value })
              }
              required
              disabled={isLoading || !!user} // No permitir cambiar email al editar por simplicidad, o manejarlo con cuidado en backend
            />
          </FormField>

          <FormField>
            <FormLabel>Teléfono (opcional)</FormLabel>
            <Input
              value={userForm.phone || ""}
              onChange={(e) =>
                setUserForm({ ...userForm, phone: e.target.value })
              }
              disabled={isLoading}
            />
          </FormField>

          {showRoleSelector && (
            <FormField>
              <FormLabel>Rol</FormLabel>
              <Select
                value={userForm.role}
                onValueChange={(value) =>
                  setUserForm({
                    ...userForm,
                    role: value as "ADMIN" | "WORKER",
                  })
                }
                disabled={
                  isLoading || user?.id === parseInt(loggedInUser?.id || "0")
                } // Admin no puede cambiarse el rol a sí mismo
              >
                <SelectTrigger>
                  <SelectValue placeholder="Seleccionar rol" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="ADMIN">Administrador</SelectItem>
                  <SelectItem value="WORKER">Técnico</SelectItem>
                </SelectContent>
              </Select>
            </FormField>
          )}

          {!user && ( // Campos de contraseña solo para la creación de nuevos usuarios
            <>
              <FormField>
                <FormLabel>Contraseña</FormLabel>
                <Input
                  type="password"
                  value={userForm.password}
                  onChange={(e) =>
                    setUserForm({ ...userForm, password: e.target.value })
                  }
                  required={!user}
                  disabled={isLoading}
                  placeholder="Mínimo 8 caracteres"
                />
              </FormField>

              <FormField>
                <FormLabel>Confirmar Contraseña</FormLabel>
                <Input
                  type="password"
                  value={confirmNewPasswordByAdmin}
                  onChange={(e) => setConfirmNewPasswordByAdmin(e.target.value)}
                  required={!user}
                  disabled={isLoading}
                />
              </FormField>
            </>
          )}

          {isAdminEditingOtherUser && (
            <div className="mt-4 pt-4 border-t">
              <h3 className="text-md font-semibold mb-2">
                Establecer Nueva Contraseña (Admin)
              </h3>
              <p className="text-xs text-gray-500 mb-2">
                Dejar en blanco para no cambiar la contraseña actual del
                usuario.
              </p>
              <FormField>
                <FormLabel>Nueva Contraseña</FormLabel>
                <Input
                  type="password"
                  value={newPasswordByAdmin}
                  onChange={(e) => setNewPasswordByAdmin(e.target.value)}
                  disabled={isLoading}
                  placeholder="Mínimo 8 caracteres"
                />
              </FormField>
              <FormField>
                <FormLabel>Confirmar Nueva Contraseña</FormLabel>
                <Input
                  type="password"
                  value={confirmNewPasswordByAdmin}
                  onChange={(e) => setConfirmNewPasswordByAdmin(e.target.value)}
                  disabled={isLoading}
                />
              </FormField>
            </div>
          )}

          {error && (
            <div className="text-red-500 text-sm p-2 bg-red-50 border border-red-200 rounded">
              {error}
            </div>
          )}

          <DialogFooter className="pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={onClose}
              disabled={isLoading}
            >
              Cancelar
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? (
                <div className="flex items-center">
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  {user ? "Guardando..." : "Creando..."}
                </div>
              ) : user ? (
                "Guardar cambios"
              ) : (
                "Crear usuario"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}


Ruta: config\navigation.ts
// config/navigation.ts
import {
  LayoutDashboard,
  Users,
  MessagesSquare,
  User,
  Boxes,
  Anvil,
  Calendar,
} from "lucide-react";

type NavigationItem = {
  name: string;
  href: string;
  icon: any;
  description: string;
  badge?: number;
  requiredRole?: string | string[]; // Propiedad para controlar el acceso
};

type Navigation = {
  title: string;
  items: NavigationItem[];
};

export const navigation: Navigation[] = [
  {
    title: "Principal",
    items: [
      {
        name: "Dashboard",
        href: "/dashboard",
        icon: LayoutDashboard,
        description: "Vista general de tu cuenta",
        requiredRole: ["ADMIN", "WORKER"],
      },
    ],
  },
  {
    title: "Gestión",
    items: [
      {
        name: "Productos",
        href: "/dashboard/products",
        icon: Boxes,
        description: "Gestiona tus productos",
        requiredRole: "ADMIN",
      },
      {
        name: "Clientes",
        href: "/dashboard/customers",
        icon: Users,
        description: "Administra tus clientes",
        requiredRole: "ADMIN",
      },
      {
        name: "Cotizaciones",
        href: "/dashboard/quotes",
        icon: MessagesSquare,
        description: "Centro de mensajes",
        requiredRole: "ADMIN",
      },
      {
        name: "Trabajos",
        href: "/dashboard/tasks",
        icon: Anvil,
        description: "Gestiona tus trabajos",
        requiredRole: "ADMIN",
      },
      {
        name: "Mantenimientos",
        href: "/dashboard/maintenance",
        icon: Calendar,
        description: "Gestiona los mantenimientos",
        requiredRole: "ADMIN",
      },
      {
        name: "Agenda",
        href: "/dashboard/agenda",
        icon: Calendar,
        description: "Vista de agenda para tareas",
        requiredRole: ["ADMIN", "WORKER"], // Permitir tanto a ADMIN como WORKER
      },
    ],
  },
  {
    title: "Equipo",
    items: [
      {
        name: "Usuarios",
        href: "/dashboard/users",
        icon: Users,
        description: "Gestiona tu equipo",
        requiredRole: "ADMIN",
      },
    ],
  },
  {
    title: "Cuenta",
    items: [
      {
        name: "Perfil",
        href: "/dashboard/profile",
        icon: User,
        description: "Tus datos personales",
        requiredRole: "ALL",
      },
    ],
  },
];


Ruta: contexts\NotificationContext.tsx
"use client";

import React, { createContext, useContext, useState } from "react";
import { useToast } from "@/components/ui/use-toast";
import { ToastAction } from "@/components/ui/toast";
import { CheckCircle, AlertCircle, Info, AlertTriangle } from "lucide-react";

type NotificationType = "success" | "error" | "warning" | "info";

interface NotificationContextProps {
  addNotification: (
    type: NotificationType,
    message: string,
    action?: {
      label: string;
      onClick: () => void;
    }
  ) => void;
}

const NotificationContext = createContext<NotificationContextProps | undefined>(
  undefined
);

export function NotificationProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { toast } = useToast();

  const addNotification = (
    type: NotificationType,
    message: string,
    action?: {
      label: string;
      onClick: () => void;
    }
  ) => {
    const icon = getNotificationIcon(type);

    toast({
      variant: type === "error" ? "destructive" : "default",
      title: getNotificationTitle(type),
      description: message,
      action: action ? (
        <ToastAction altText={action.label} onClick={action.onClick}>
          {action.label}
        </ToastAction>
      ) : undefined,
      icon,
      duration: 5000,
    });
  };

  return (
    <NotificationContext.Provider value={{ addNotification }}>
      {children}
    </NotificationContext.Provider>
  );
}

function getNotificationIcon(type: NotificationType) {
  switch (type) {
    case "success":
      return <CheckCircle className="h-5 w-5 text-green-500" />;
    case "error":
      return <AlertCircle className="h-5 w-5 text-red-500" />;
    case "warning":
      return <AlertTriangle className="h-5 w-5 text-amber-500" />;
    case "info":
      return <Info className="h-5 w-5 text-blue-500" />;
    default:
      return <Info className="h-5 w-5" />;
  }
}

function getNotificationTitle(type: NotificationType): string {
  switch (type) {
    case "success":
      return "Éxito";
    case "error":
      return "Error";
    case "warning":
      return "Advertencia";
    case "info":
      return "Información";
    default:
      return "";
  }
}

export function useNotification() {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error(
      "useNotification debe ser usado dentro de un NotificationProvider"
    );
  }
  return context;
}


Ruta: hooks\useScrollLock.tsx
"use client";

import { useEffect, useRef } from "react";

/**
 * Hook personalizado para bloquear el scroll del body
 * @param shouldLock - Determina si el scroll debe estar bloqueado
 */
export function useScrollLock(shouldLock: boolean) {
  // Referencia para almacenar el valor original del overflow
  const originalStyleRef = useRef<string | null>(null);

  useEffect(() => {
    // No hacer nada si no hay document (en SSR)
    if (typeof document === "undefined") return;

    // Función para bloquear el scroll
    const blockScroll = () => {
      // Guardar el estilo original solo una vez
      if (originalStyleRef.current === null) {
        originalStyleRef.current = document.body.style.overflow;
      }

      // Calcular el ancho de la scrollbar para evitar saltos
      const scrollbarWidth =
        window.innerWidth - document.documentElement.clientWidth;

      // Aplicar estilos para bloquear
      document.body.style.overflow = "hidden";
      document.body.style.paddingRight = `${scrollbarWidth}px`;
    };

    // Función para restaurar el scroll
    const allowScroll = () => {
      if (originalStyleRef.current !== null) {
        document.body.style.overflow = originalStyleRef.current;
        document.body.style.paddingRight = "0px";
        originalStyleRef.current = null;
      }
    };

    // Aplicar o restaurar según el valor de shouldLock
    if (shouldLock) {
      blockScroll();
    } else {
      allowScroll();
    }

    // Asegurar la limpieza al desmontar
    return () => {
      allowScroll();
    };
  }, [shouldLock]);
}

// Ejemplo de uso:
// const MyComponent = ({ isOpen }) => {
//   useScrollLock(isOpen);
//   return <div>...</div>;
// };


Ruta: lib\definitions.ts
// lib/definitions.ts
export type User = {
  id: string;
  name: string;
  email: string;
  password: string;
  role: string;
};

// Extendemos la sesión de NextAuth
declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      name: string;
      email: string;
      role: string;
    };
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    name: string;
    email: string;
    role: string;
  }
}


Ruta: lib\errorHandler.ts
// lib/errorHandler.ts (mejorado)
/**
 * Sistema centralizado para manejo de errores de la aplicación
 */

// Tipos de errores que pueden ocurrir en la aplicación
export enum ErrorType {
    // Errores de autenticación
    AUTH_INVALID_CREDENTIALS = "auth/invalid-credentials",
    AUTH_SESSION_EXPIRED = "auth/session-expired",
    AUTH_NOT_AUTHENTICATED = "auth/not-authenticated",
    AUTH_INSUFFICIENT_PERMISSIONS = "auth/insufficient-permissions",
  
    // Errores de API
    API_REQUEST_FAILED = "api/request-failed",
    API_NETWORK_ERROR = "api/network-error",
    API_TIMEOUT = "api/timeout",
    API_SERVER_ERROR = "api/server-error",
    API_NOT_FOUND = "api/not-found",
  
    // Errores de validación
    VALIDATION_REQUIRED_FIELD = "validation/required-field",
    VALIDATION_INVALID_FORMAT = "validation/invalid-format",
    VALIDATION_INVALID_EMAIL = "validation/invalid-email",
    VALIDATION_INVALID_PASSWORD = "validation/invalid-password",
    VALIDATION_PASSWORDS_DONT_MATCH = "validation/passwords-dont-match",
  
    // Errores de datos
    DATA_NOT_FOUND = "data/not-found",
    DATA_ALREADY_EXISTS = "data/already-exists",
    DATA_CORRUPTED = "data/corrupted",
  
    // Errores generales
    UNKNOWN_ERROR = "unknown/error",
    FEATURE_NOT_IMPLEMENTED = "feature/not-implemented",
    OPERATION_CANCELED = "operation/canceled",
    RATE_LIMIT_EXCEEDED = "rate-limit/exceeded",
    
    // Errores de CSRF
    CSRF_TOKEN_MISSING = "csrf/token-missing",
    CSRF_TOKEN_INVALID = "csrf/token-invalid",
    
    // Errores de seguridad
    SECURITY_INVALID_INPUT = "security/invalid-input",
  }
  
  // Interfaz para errores personalizados de la aplicación
  export interface AppError {
    type: ErrorType;
    message: string;
    statusCode?: number;
    details?: any;
    timestamp: number;
    handled: boolean;
    stack?: string;
    source?: string;
  }
  
  // Mapeo de códigos HTTP a tipos de errores
  const HTTP_STATUS_TO_ERROR: Record<number, ErrorType> = {
    400: ErrorType.API_REQUEST_FAILED,
    401: ErrorType.AUTH_SESSION_EXPIRED,
    403: ErrorType.AUTH_INSUFFICIENT_PERMISSIONS,
    404: ErrorType.API_NOT_FOUND,
    408: ErrorType.API_TIMEOUT,
    409: ErrorType.DATA_ALREADY_EXISTS,
    422: ErrorType.VALIDATION_INVALID_FORMAT,
    429: ErrorType.RATE_LIMIT_EXCEEDED,
    500: ErrorType.API_SERVER_ERROR,
    502: ErrorType.API_SERVER_ERROR,
    503: ErrorType.API_SERVER_ERROR,
    504: ErrorType.API_TIMEOUT,
  };
  
  // Mensajes de error predeterminados por tipo
  const ERROR_MESSAGES: Record<ErrorType, string> = {
    [ErrorType.AUTH_INVALID_CREDENTIALS]:
      "Credenciales inválidas. Por favor, verifica tu correo y contraseña.",
    [ErrorType.AUTH_SESSION_EXPIRED]:
      "Tu sesión ha expirado. Por favor, inicia sesión nuevamente.",
    [ErrorType.AUTH_NOT_AUTHENTICATED]:
      "Debes iniciar sesión para acceder a esta funcionalidad.",
    [ErrorType.AUTH_INSUFFICIENT_PERMISSIONS]:
      "No tienes permisos suficientes para realizar esta acción.",
  
    [ErrorType.API_REQUEST_FAILED]:
      "La solicitud no pudo ser procesada. Por favor, intenta nuevamente.",
    [ErrorType.API_NETWORK_ERROR]:
      "Error de conexión. Verifica tu conexión a internet e intenta nuevamente.",
    [ErrorType.API_TIMEOUT]:
      "La solicitud ha tardado demasiado. Por favor, intenta nuevamente.",
    [ErrorType.API_SERVER_ERROR]:
      "Ha ocurrido un error en el servidor. Nuestro equipo ha sido notificado.",
    [ErrorType.API_NOT_FOUND]:
      "El recurso solicitado no existe o no está disponible.",
  
    [ErrorType.VALIDATION_REQUIRED_FIELD]: "Este campo es obligatorio.",
    [ErrorType.VALIDATION_INVALID_FORMAT]: "El formato ingresado no es válido.",
    [ErrorType.VALIDATION_INVALID_EMAIL]:
      "Por favor, ingresa un correo electrónico válido.",
    [ErrorType.VALIDATION_INVALID_PASSWORD]:
      "La contraseña no cumple con los requisitos de seguridad.",
    [ErrorType.VALIDATION_PASSWORDS_DONT_MATCH]: "Las contraseñas no coinciden.",
  
    [ErrorType.DATA_NOT_FOUND]: "No se encontraron los datos solicitados.",
    [ErrorType.DATA_ALREADY_EXISTS]: "Este registro ya existe en el sistema.",
    [ErrorType.DATA_CORRUPTED]: "Los datos están dañados o son inválidos.",
  
    [ErrorType.UNKNOWN_ERROR]: "Ha ocurrido un error inesperado.",
    [ErrorType.FEATURE_NOT_IMPLEMENTED]:
      "Esta funcionalidad aún no está disponible.",
    [ErrorType.OPERATION_CANCELED]: "La operación ha sido cancelada.",
    [ErrorType.RATE_LIMIT_EXCEEDED]:
      "Has realizado demasiadas solicitudes. Por favor, intenta más tarde.",
      
    [ErrorType.CSRF_TOKEN_MISSING]: 
      "Token de seguridad faltante. Por favor, recarga la página e intenta nuevamente.",
    [ErrorType.CSRF_TOKEN_INVALID]:
      "Token de seguridad inválido. Por favor, recarga la página e intenta nuevamente.",
      
    [ErrorType.SECURITY_INVALID_INPUT]: 
      "La entrada contiene caracteres no permitidos. Por favor, revisa e intenta nuevamente.",
  };
  
  /**
   * Crea un objeto de error de la aplicación a partir de un error nativo o un tipo de error
   * @param error Error nativo o tipo de error
   * @param customMessage Mensaje personalizado opcional
   * @param statusCode Código de estado HTTP opcional
   * @param details Detalles adicionales opcionales
   * @returns Objeto AppError normalizado
   */
  export function createAppError(
    error: Error | ErrorType | string | unknown,
    customMessage?: string,
    statusCode?: number,
    details?: any
  ): AppError {
    let errorType: ErrorType = ErrorType.UNKNOWN_ERROR;
    let errorMessage: string =
      customMessage || ERROR_MESSAGES[ErrorType.UNKNOWN_ERROR];
    let errorStack: string | undefined;
    let errorSource: string | undefined;
  
    // Si es un tipo de error definido, usarlo directamente
    if (
      typeof error === "string" &&
      Object.values(ErrorType).includes(error as ErrorType)
    ) {
      errorType = error as ErrorType;
      errorMessage = customMessage || ERROR_MESSAGES[errorType];
    }
    // Si es un error de respuesta HTTP con código de estado
    else if (statusCode && HTTP_STATUS_TO_ERROR[statusCode]) {
      errorType = HTTP_STATUS_TO_ERROR[statusCode];
      errorMessage = customMessage || ERROR_MESSAGES[errorType];
    }
    // Si es un error nativo
    else if (error instanceof Error) {
      errorMessage = customMessage || error.message;
      errorStack = error.stack;
      errorSource = error.name;
  
      // Intentar detectar errores comunes por el mensaje
      if (
        error.message.includes("network") ||
        error.message.includes("connection")
      ) {
        errorType = ErrorType.API_NETWORK_ERROR;
      } else if (error.message.includes("timeout")) {
        errorType = ErrorType.API_TIMEOUT;
      } else if (error.message.includes("CSRF") || error.message.includes("csrf")) {
        errorType = ErrorType.CSRF_TOKEN_INVALID;
      }
    }
  
    return {
      type: errorType,
      message: errorMessage,
      statusCode,
      details,
      timestamp: Date.now(),
      handled: false,
      stack: errorStack,
      source: errorSource,
    };
  }
  
  /**
   * Registra un error en el sistema (consola, servicio de monitoreo, etc.)
   * @param error Error a registrar
   */
  export function logError(error: AppError | Error | unknown): void {
    // Normalizar a AppError si no lo es
    const appError =
      error instanceof Error && !(error as any).type
        ? createAppError(error)
        : (error as AppError);
  
    // Registrar en consola para desarrollo
    console.error("[ERROR]", appError);
  
    // En producción, aquí se enviaría a un servicio de monitoreo como Sentry
    if (process.env.NODE_ENV === "production") {
      // Implementar integración con servicio de monitoreo
      // Por ejemplo: Sentry.captureException(appError);
      
      // Enviar a un endpoint para registro
      try {
        fetch('/api/log-error', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(appError),
        }).catch(e => console.error('Error sending error to logging endpoint:', e));
      } catch (e) {
        // Silenciar errores al registrar
      }
    }
  
    // Marcar como manejado
    if ((appError as AppError).handled !== undefined) {
      (appError as AppError).handled = true;
    }
    
    // Si es un error de seguridad crítico, registrar de manera más detallada
    if (
      appError.type === ErrorType.CSRF_TOKEN_INVALID ||
      appError.type === ErrorType.SECURITY_INVALID_INPUT
    ) {
      console.error('SECURITY ERROR DETECTED:', {
        ...appError,
        time: new Date().toISOString(),
        url: typeof window !== 'undefined' ? window.location.href : 'server-side',
      });
    }
  }
  
  /**
   * Determina si un error debe ser reportado al usuario
   * @param error Error a evaluar
   * @returns true si el error debe ser reportado, false de lo contrario
   */
  export function shouldReportErrorToUser(error: AppError): boolean {
    // Errores que no deberían mostrar notificaciones al usuario
    const silentErrors = [
      ErrorType.OPERATION_CANCELED,
      // Añadir más según sea necesario
    ];
  
    return !silentErrors.includes(error.type);
  }
  
  /**
   * Maneja un error, registrándolo y potencialmente notificando al usuario
   * @param error Error a manejar
   * @param notifyUser Función para notificar al usuario
   * @returns El error manejado
   */
  export function handleError(
    error: Error | ErrorType | string | unknown,
    notifyUser?: (message: string, type: "error" | "warning" | "info") => void
  ): AppError {
    // Crear un AppError si no lo es
    const appError =
      error instanceof Error && !(error as any).type
        ? createAppError(error)
        : (error as AppError);
  
    // Registrar el error
    logError(appError);
  
    // Notificar al usuario si es necesario y se proporciona una función
    if (notifyUser && shouldReportErrorToUser(appError)) {
      notifyUser(appError.message, "error");
    }
  
    return appError;
  }

Ruta: lib\httpClient.ts
// web/lib/httpClient.ts
import { getSession, signOut } from "next-auth/react";
import type { Session } from "next-auth";

// --- Error Handling (Asumido de tus archivos previos) ---
export enum ErrorType {
  API_REQUEST_FAILED = "API_REQUEST_FAILED",
  API_TIMEOUT = "API_TIMEOUT",
  API_NETWORK_ERROR = "API_NETWORK_ERROR",
  AUTH_SESSION_EXPIRED = "AUTH_SESSION_EXPIRED",
  VALIDATION_ERROR = "VALIDATION_ERROR",
  UNKNOWN_ERROR = "UNKNOWN_ERROR",
}

export interface AppError extends Error {
  type: ErrorType;
  statusCode?: number;
  details?: any;
}

export function createAppError(
  type: ErrorType,
  message: string,
  statusCode?: number,
  details?: any
): AppError {
  const error = new Error(message) as AppError;
  error.type = type;
  error.statusCode = statusCode;
  error.details = details;
  return error;
}

export function logError(error: AppError, additionalContext?: any): void {
  console.error(
    `[AppError] Type: ${error.type}, Status: ${
      error.statusCode || "N/A"
    }, Message: ${error.message}`,
    {
      details: error.details,
      stack: error.stack,
      additionalContext,
    }
  );
}
// --- Fin Error Handling ---

const REQUEST_TIMEOUT = 15000; // 15 segundos, ajústalo según sea necesario
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000"; // Asegúrate que tu backend esté en esta URL

interface SessionCache {
  session: Session | null;
  timestamp: number;
  promise?: Promise<Session | null>;
}

let sessionCache: SessionCache | null = null;
const CACHE_EXPIRY_MS = 30 * 1000; // Cachear la sesión por 30 segundos para reducir llamadas a getSession

async function getCachedSession(): Promise<Session | null> {
  const now = Date.now();
  if (sessionCache) {
    if (sessionCache.promise) {
      // console.log("[getCachedSession] Returning existing session promise.");
      return sessionCache.promise;
    }
    if (now - sessionCache.timestamp < CACHE_EXPIRY_MS) {
      // console.log("[getCachedSession] Returning cached session.");
      return sessionCache.session;
    }
  }

  // console.log("[getCachedSession] Cache expired or empty. Fetching new session...");
  const sessionPromise = getSession()
    .then((session) => {
      if (sessionCache && sessionCache.promise === sessionPromise) {
        sessionCache = { session, timestamp: Date.now(), promise: undefined };
      }
      // console.log("[getCachedSession] Fetched new session:", session ? { user: session.user?.id, expires: session.expires, error: (session as any).error } : null);
      return session;
    })
    .catch((err) => {
      console.error("[getCachedSession] Error fetching session:", err);
      if (sessionCache && sessionCache.promise === sessionPromise) {
        sessionCache = {
          session: null,
          timestamp: Date.now(),
          promise: undefined,
        };
      }
      return null;
    });

  sessionCache = { session: null, timestamp: now, promise: sessionPromise };
  return sessionPromise;
}

export function invalidateSessionCache(): void {
  console.log("[invalidateSessionCache] Invalidating session cache.");
  sessionCache = null;
}

function clearAuthCookies(): void {
  if (typeof document === "undefined") return;

  console.log(
    "[clearAuthCookies] Attempting to clear NextAuth cookies from client-side."
  );
  const cookieNames = [
    "next-auth.session-token",
    "next-auth.callback-url",
    "next-auth.csrf-token",
    "__Secure-next-auth.session-token",
    "__Secure-next-auth.callback-url",
    "__Secure-next-auth.csrf-token",
    "__Host-next-auth.session-token", // Para configuraciones más estrictas
  ];

  const domainParts = window.location.hostname.split(".");
  const domainsToTry: string[] = [window.location.hostname]; // Dominio actual

  if (window.location.hostname !== "localhost") {
    domainsToTry.push(`.${window.location.hostname}`); // Con punto al inicio para subdominios
    if (domainParts.length > 2) {
      // Dominio base (ej. .example.com para app.example.com)
      domainsToTry.push(`.${domainParts.slice(-2).join(".")}`);
    }
  }
  const uniqueDomains = [...new Set(domainsToTry)];

  cookieNames.forEach((name) => {
    uniqueDomains.forEach((d) => {
      // Para HTTP y HTTPS (SameSite=Lax es un buen default)
      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; domain=${d}; path=/; SameSite=Lax`;
      // Intento para Secure si aplica, aunque SameSite=None requiere Secure
      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; domain=${d}; path=/; SameSite=Lax; Secure`;
    });
    // Intento adicional sin especificar dominio (principalmente para localhost o si los otros no funcionan)
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Lax`;
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Lax; Secure`;
  });
  console.log("[clearAuthCookies] Standard NextAuth cookies clear attempted.");
}

async function forceLogoutAndRedirect(reason: string): Promise<void> {
  console.warn(
    `[forceLogoutAndRedirect] Forcing logout and redirect. Reason: "${reason}"`
  );
  invalidateSessionCache();
  clearAuthCookies(); // Limpieza manual de cookies como refuerzo

  try {
    // Intentar signOut para que NextAuth limpie su estado del lado del servidor y cookies HttpOnly
    await signOut({ redirect: false }); // No redirigir desde signOut, lo haremos manualmente
    console.log(
      "[forceLogoutAndRedirect] signOut({ redirect: false }) completed."
    );
  } catch (e) {
    console.error("[forceLogoutAndRedirect] Error during signOut:", e);
  }

  if (typeof window !== "undefined") {
    // Construir la URL de login con la razón como parámetro de error
    let loginUrl = `/login?error=SessionInvalidated&reason=${encodeURIComponent(
      reason
    )}`;
    // Evitar anidar callbackUrl si ya estamos en /login o si es un error muy genérico
    if (window.location.pathname !== "/login") {
      const callbackUrl = encodeURIComponent(
        window.location.pathname + window.location.search
      );
      loginUrl += `&callbackUrl=${callbackUrl}`;
    }

    console.log(`[forceLogoutAndRedirect] Redirecting to: ${loginUrl}`);
    window.location.href = loginUrl; // Redirección forzada del lado del cliente
  }
}

// La función checkAndRefreshToken y otras de tokenService.ts no están siendo usadas activamente
// por httpClient si auth.ts está en modo simplificado sin refresco de backend.
// Se dejan aquí por si se reactiva la lógica de refresco de backend.
// Actualmente, la expiración del accessToken del backend (1h) llevará a 401, y eso
// activará forceLogoutAndRedirect.

type CustomHeadersInit = Record<string, string | undefined>;

interface HttpClientOptions extends Omit<RequestInit, "headers"> {
  headers?: CustomHeadersInit;
  timeout?: number;
  skipErrorHandling?: boolean;
  // skipTokenRefresh?: boolean; // No relevante con auth.ts simplificado
}

export async function httpClient<T = any>(
  url: string,
  options: HttpClientOptions = {}
): Promise<T> {
  const {
    timeout = REQUEST_TIMEOUT,
    skipErrorHandling = false,
    // skipTokenRefresh = true, // Con auth.ts simplificado, no hay refresco de backend que controlar aquí
    ...fetchOptions
  } = options;

  let session: Session | null = null;
  try {
    session = await getCachedSession();
  } catch (sessionError) {
    console.error(
      "[httpClient] Critical error fetching session:",
      sessionError
    );
    await forceLogoutAndRedirect("Error crítico al obtener sesión");
    throw createAppError(
      ErrorType.AUTH_SESSION_EXPIRED,
      "Error crítico al obtener sesión",
      500,
      sessionError
    );
  }

  let logoutReason: string | null = null;

  if (!session) {
    logoutReason = "No session object returned by getSession";
  } else if (!session.user || !session.user.id) {
    logoutReason = "Session user or user.id is missing";
  } else if (!session.accessToken) {
    logoutReason = "Session accessToken is missing";
  } else if ((session as any).error) {
    logoutReason = `Session error property set: ${(session as any).error}`;
  }
  // Adicional: Verificar si el token de NextAuth (no el del backend) está muy cerca de expirar o expiró
  // Esto es por si el callback jwt no logró poner exp=0 a tiempo debido a un timeout de lambda
  const sessionExpiresTimestamp = session?.expires
    ? new Date(session.expires).getTime()
    : 0;
  if (
    sessionExpiresTimestamp &&
    Date.now() >= sessionExpiresTimestamp - 10 * 1000
  ) {
    // 10 segundos de gracia
    logoutReason =
      logoutReason ||
      `NextAuth session itself is expired or expiring very soon (expires: ${session?.expires})`;
  }

  if (logoutReason) {
    console.warn(
      `[httpClient] Invalid session state detected: "${logoutReason}". Forcing logout. Session (condensed):`,
      session
        ? {
            user: session.user?.id,
            expires: session.expires,
            error: (session as any).error,
            accessTokenPresent: !!session.accessToken,
          }
        : "null"
    );
    await forceLogoutAndRedirect(logoutReason);
    // forceLogoutAndRedirect ya lanza un error, pero para typescript:
    throw createAppError(ErrorType.AUTH_SESSION_EXPIRED, logoutReason, 401);
  }

  const accessToken = session!.accessToken as string; // Sabemos que existe por el chequeo anterior

  const baseHeaders: Record<string, string> = {
    "Content-Type": "application/json",
    Accept: "application/json",
  };
  if (accessToken) {
    baseHeaders["Authorization"] = `Bearer ${accessToken}`;
  }

  const method = (fetchOptions.method || "GET").toUpperCase();
  // CSRF token no es relevante para este flujo de API Bearer token, a menos que tu backend lo requiera específicamente.

  const mergedHeaders: Record<string, string> = { ...baseHeaders };
  if (fetchOptions.headers) {
    Object.entries(fetchOptions.headers).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        mergedHeaders[key] = String(value);
      }
    });
  }

  const fullUrl = url.startsWith("http")
    ? url
    : `${API_BASE_URL}${url.startsWith("/") ? url : `/${url}`}`;

  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    console.warn(
      `[httpClient] Request to ${method} ${fullUrl} TIMED OUT after ${timeout}ms.`
    );
    controller.abort();
  }, timeout);

  console.log(`[httpClient] Request: ${method} ${fullUrl}`);
  // console.log(`[httpClient] Using accessToken (first 10): ${accessToken ? accessToken.substring(0,10) + '...' : 'N/A'}`);

  try {
    const requestOptions: RequestInit = {
      ...fetchOptions,
      method,
      headers: mergedHeaders,
      credentials: "include", // Importante para que las cookies de NextAuth se envíen si son necesarias para alguna ruta API del frontend
      signal: controller.signal,
    };

    const response = await fetch(fullUrl, requestOptions);
    clearTimeout(timeoutId); // Limpiar el timeout si la respuesta llega

    if (!response.ok) {
      const statusCode = response.status;
      let errorData: any = {
        message: `Error ${statusCode}: ${response.statusText}`,
      };
      try {
        const text = await response.text();
        if (text) {
          errorData = JSON.parse(text);
        }
      } catch (e) {
        // No se pudo parsear el cuerpo del error, usar el statusText
        console.warn(
          `[httpClient] Could not parse error response body for status ${statusCode}.`
        );
      }
      console.warn(
        `[httpClient] API Error: ${method} ${fullUrl} - Status: ${statusCode}`,
        errorData
      );

      if (statusCode === 401) {
        // El backend indica que el token no es válido (expirado o incorrecto)
        await forceLogoutAndRedirect(`API returned 401 for ${method} ${url}`);
        // Esto lanza un error, por lo que no se llegará a la siguiente línea
        throw createAppError(
          ErrorType.AUTH_SESSION_EXPIRED,
          "API Unauthorized",
          statusCode,
          errorData
        );
      }

      const error = createAppError(
        ErrorType.API_REQUEST_FAILED,
        errorData?.message || `Error ${statusCode}: ${response.statusText}`,
        statusCode,
        errorData
      );
      if (!skipErrorHandling) logError(error);
      throw error;
    }

    if (response.status === 204) {
      // No Content
      console.log(
        `[httpClient] Response: ${method} ${fullUrl} - Status: 204 No Content`
      );
      return {} as T;
    }

    const responseText = await response.text();
    try {
      const jsonData = JSON.parse(responseText);
      console.log(
        `[httpClient] Response: ${method} ${fullUrl} - Status: ${response.status}`
      );
      return jsonData as T;
    } catch (e) {
      console.warn(
        `[httpClient] Response for ${method} ${fullUrl} - Status: ${response.status} was not valid JSON. Returning raw text. Error:`,
        e
      );
      return responseText as unknown as T; // Devolver como texto si no es JSON
    }
  } catch (error: unknown) {
    clearTimeout(timeoutId); // Asegurarse de limpiar el timeout en cualquier error

    // Si es un error de aborto por nuestro timeout
    if (error instanceof Error && error.name === "AbortError") {
      const timeoutError = createAppError(
        ErrorType.API_TIMEOUT,
        `Timeout en la petición a ${method} ${url} después de ${timeout}ms`,
        408
      );
      if (!skipErrorHandling) logError(timeoutError);
      throw timeoutError;
    }

    // Si el error ya es un AppError (lanzado por forceLogoutAndRedirect o internamente), simplemente re-lanzarlo
    if (
      typeof error === "object" &&
      error !== null &&
      "type" in error &&
      typeof (error as any).type === "string"
    ) {
      console.warn(
        `[httpClient] Propagating existing AppError: ${
          (error as AppError).type
        } - ${(error as AppError).message}`
      );
      throw error;
    }

    // Para otros errores de red o excepciones inesperadas
    const networkError = createAppError(
      ErrorType.API_NETWORK_ERROR,
      `Error de red o desconocido en ${method} ${url}: ${
        error instanceof Error ? error.message : "Error desconocido"
      }`,
      undefined,
      error // el error original
    );
    if (!skipErrorHandling) logError(networkError);
    throw networkError;
  }
}


Ruta: lib\inputSanitizer.ts
// lib/inputSanitizer.ts (mejorado)
/**
 * Utilidades para sanitizar y validar entradas de usuario
 * Estas funciones ayudan a prevenir ataques de inyección y XSS
 */

/**
 * Sanitiza texto general para evitar inyección HTML
 * @param input Texto a sanitizar
 * @returns Texto sanitizado
 */
export function sanitizeText(input: string): string {
  if (!input) return "";

  // Reemplazar caracteres HTML especiales por entidades
  return input
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

/**
 * Sanitiza HTML permitiendo solo ciertas etiquetas y atributos seguros
 * @param html HTML a sanitizar
 * @returns HTML sanitizado
 */
export function sanitizeHTML(html: string): string {
  if (!html) return "";

  // Lista de etiquetas HTML permitidas
  const allowedTags = [
    "p",
    "b",
    "i",
    "u",
    "strong",
    "em",
    "a",
    "ul",
    "ol",
    "li",
    "br",
  ];

  // Lista de atributos permitidos por etiqueta
  const allowedAttributes: Record<string, string[]> = {
    a: ["href", "target", "rel"],
    // Añadir más etiquetas y atributos permitidos según sea necesario
  };

  // Eliminar scripts y eventos inline
  let sanitized = html
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
    .replace(/on\w+="[^"]*"/gi, "")
    .replace(/on\w+='[^']*'/gi, "")
    .replace(/on\w+=\w+/gi, "");

  // Eliminar etiquetas no permitidas y sus contenidos
  allowedTags.forEach((tag) => {
    const regex = new RegExp(`<(?!\/?${tag}\\b)[^>]+>`, "gi");
    sanitized = sanitized.replace(regex, "");
  });

  return sanitized;
}

/**
 * Valida un correo electrónico
 * @param email Correo electrónico a validar
 * @returns true si el correo es válido, false de lo contrario
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(email);
}

/**
 * Valida un número de teléfono (formato básico)
 * @param phone Número de teléfono a validar
 * @returns true si el número es válido, false de lo contrario
 */
export function isValidPhone(phone: string): boolean {
  // Validación básica, adaptar según los requisitos específicos
  const phoneRegex = /^\+?[0-9]{7,15}$/;
  return phoneRegex.test(phone);
}

/**
 * Valida una URL
 * @param url URL a validar
 * @returns true si la URL es válida, false de lo contrario
 */
export function isValidURL(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Sanitiza un nombre de archivo para evitar inyecciones de ruta
 * @param filename Nombre de archivo a sanitizar
 * @returns Nombre de archivo sanitizado
 */
export function sanitizeFilename(filename: string): string {
  if (!filename) return "";

  // Eliminar caracteres que podrían usarse para navegación de directorios
  return filename
    .replace(/\.\.\//g, "") // Eliminar ../
    .replace(/\\/g, "") // Eliminar backslashes
    .replace(/\//g, "") // Eliminar forward slashes
    .replace(/~/g, "") // Eliminar tildes
    .replace(/:/g, "") // Eliminar dos puntos
    .replace(/\|/g, "") // Eliminar pipes
    .replace(/\*/g, "") // Eliminar asteriscos
    .replace(/"/g, "") // Eliminar comillas
    .replace(/</g, "") // Eliminar menor que
    .replace(/>/g, "") // Eliminar mayor que
    .replace(/\?/g, "") // Eliminar signos de interrogación
    .trim(); // Eliminar espacios al inicio y final
}

/**
 * Verifica si una contraseña cumple con los requisitos mínimos de seguridad
 * @param password Contraseña a verificar
 * @returns true si la contraseña es segura, false de lo contrario
 */
export function isSecurePassword(password: string): boolean {
  if (!password || password.length < 8) return false;

  // Verificar requisitos mínimos:
  // - Al menos 8 caracteres
  // - Al menos una letra mayúscula
  // - Al menos una letra minúscula
  // - Al menos un número
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /[0-9]/.test(password);

  return hasUpperCase && hasLowerCase && hasNumbers;
}

/**
 * Sanitiza y valida entrada de JSON para prevenir inyecciones
 * @param jsonInput String que contiene JSON
 * @returns JSON parseado y sanitizado o null si es inválido
 */
export function sanitizeJSON(jsonInput: string): any | null {
  try {
    // Parsear el JSON para verificar que es válido
    const parsed = JSON.parse(jsonInput);

    // Función recursiva para sanitizar todos los strings en el objeto
    const sanitizeObject = (obj: any): any => {
      if (typeof obj === "string") {
        return sanitizeText(obj);
      } else if (Array.isArray(obj)) {
        return obj.map((item) => sanitizeObject(item));
      } else if (obj !== null && typeof obj === "object") {
        const result: any = {};
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            // Sanitizar tanto la clave como el valor
            const sanitizedKey = sanitizeText(key);
            result[sanitizedKey] = sanitizeObject(obj[key]);
          }
        }
        return result;
      }
      return obj;
    };

    return sanitizeObject(parsed);
  } catch (e) {
    console.error("Error parsing JSON:", e);
    return null;
  }
}

/**
 * Sanitiza datos de entrada para prevenir ataques de SQL Injection
 * Nota: Esto debe usarse como una capa adicional de seguridad, no como reemplazo
 * de prepared statements en el backend
 *
 * @param input String a sanitizar
 * @returns String sanitizado
 */
export function sanitizeSQLInput(input: string): string {
  if (!input) return "";

  // Escapar caracteres comunes en SQL injection
  return input
    .replace(/'/g, "''") // Escapar comillas simples
    .replace(/;/g, "") // Remover punto y coma
    .replace(/--/g, "") // Remover comentarios
    .replace(/\/\*/g, "") // Remover inicio de comentario multilínea
    .replace(/\*\//g, ""); // Remover fin de comentario multilínea
}


Ruta: lib\themes.ts
// lib/themes.ts
export const themes = {
  default: {
    primary: {
      DEFAULT: "#b42516", // Color principal rojo
      foreground: "#FFFFFF", // Texto blanco
      hover: "#9e2113", // Un tono más oscuro para hover
      focus: "#8a1d10", // Un tono aún más oscuro para focus
    },
    secondary: {
      DEFAULT: "#F3F4F6", // Gris claro
      foreground: "#374151", // Gris oscuro
      hover: "#E5E7EB", // Gris más claro para hover
      focus: "#D1D5DB", // Gris aún más claro para focus
    },
    background: {
      DEFAULT: "#FFFFFF", // Fondo blanco
      secondary: "#F9FAFB", // Gris muy claro
    },
    border: {
      DEFAULT: "#E5E7EB", // Borde gris claro
      focus: "#b42516", // Borde rojo al enfocar
    },
    ring: {
      DEFAULT: "#E5E7EB", // Anillo gris claro
      focus: "#b42516", // Anillo rojo al enfocar
    },
    content: {
      subtle: "#6B7280", // Texto gris
      DEFAULT: "#1F2937", // Texto casi negro
      emphasis: "#111827", // Texto negro
    },
    accent: {
      DEFAULT: "#f8d7d4", // Un tono claro de rojo como acento
      hover: "#f5c5c1", // Un tono más oscuro para hover
    },
    error: {
      DEFAULT: "#EF4444", // Rojo para errores
      foreground: "#FFFFFF", // Texto blanco
    },
    success: {
      DEFAULT: "#22C55E", // Verde para éxito
      foreground: "#FFFFFF", // Texto blanco
    },
  },
  // dark: {
  //   primary: {
  //     DEFAULT: "#b42516", // Mantener el rojo en modo oscuro
  //     foreground: "#FFFFFF", // Texto blanco
  //     hover: "#9e2113", // Un tono más oscuro para hover
  //     focus: "#8a1d10", // Un tono aún más oscuro para focus
  //   },
  //   secondary: {
  //     DEFAULT: "#374151", // Gris oscuro
  //     foreground: "#F9FAFB", // Texto claro
  //     hover: "#4B5563", // Gris un poco más claro para hover
  //     focus: "#6B7280", // Gris aún más claro para focus
  //   },
  //   background: {
  //     DEFAULT: "#111827", // Fondo negro
  //     secondary: "#1F2937", // Gris muy oscuro
  //   },
  //   border: {
  //     DEFAULT: "#374151", // Borde gris oscuro
  //     focus: "#b42516", // Borde rojo al enfocar
  //   },
  //   ring: {
  //     DEFAULT: "#374151", // Anillo gris oscuro
  //     focus: "#b42516", // Anillo rojo al enfocar
  //   },
  //   content: {
  //     subtle: "#9CA3AF", // Texto gris claro
  //     DEFAULT: "#E5E7EB", // Texto casi blanco
  //     emphasis: "#FFFFFF", // Texto blanco
  //   },
  //   accent: {
  //     DEFAULT: "#7f1a0f", // Un tono oscuro de rojo como acento
  //     hover: "#6a160c", // Un tono más oscuro para hover
  //   },
  //   error: {
  //     DEFAULT: "#F87171", // Rojo más claro para errores en modo oscuro
  //     foreground: "#FFFFFF", // Texto blanco
  //   },
  //   success: {
  //     DEFAULT: "#4ADE80", // Verde más claro para éxito en modo oscuro
  //     foreground: "#FFFFFF", // Texto blanco
  //   },
  // },
};

export type Theme = typeof themes.default;


Ruta: lib\tokenService.ts
/**
 * Servicio para gestionar tokens de autenticación y renovación automática
 */

import { signIn } from "next-auth/react";
import { jwtDecode } from "jwt-decode";

// Tiempo antes de la expiración para intentar renovar el token (5 minutos)
const REFRESH_TOKEN_THRESHOLD = 5 * 60 * 1000; // 5 minutos en milisegundos

// Almacenamiento de timers de renovación para evitar duplicados
let refreshTimers: Record<string, NodeJS.Timeout> = {};

interface DecodedTokenPayload {
  id: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

/**
 * Decodifica un token JWT sin necesidad de bibliotecas externas
 * @param token El token JWT a decodificar
 * @returns El payload decodificado o null si el token no es válido
 */
export function decodeJWT(token: string): DecodedTokenPayload | null {
  try {
    if (!token) return null;
    return jwtDecode<DecodedTokenPayload>(token);
  } catch (error) {
    console.error("Error decodificando JWT:", error);
    return null;
  }
}

/**
 * Verifica si un token JWT está próximo a expirar
 * @param token El token JWT a verificar
 * @returns true si el token expirará pronto, false de lo contrario
 */
export function isTokenExpiringSoon(token: string): boolean {
  const payload = decodeJWT(token);

  if (!payload || !payload.exp) {
    return true; // Si no podemos verificar, asumir que está por expirar
  }

  const expirationTime = payload.exp * 1000; // Convertir a milisegundos
  const currentTime = Date.now();

  // Verificar si el token expirará dentro del umbral definido
  return expirationTime - currentTime < REFRESH_TOKEN_THRESHOLD;
}

/**
 * Programa la renovación automática de un token antes de que expire
 * @param token El token JWT actual
 * @param userId Identificador del usuario para evitar múltiples renovaciones
 */
export function scheduleTokenRefresh(token: string, userId: string) {
  // Cancelar cualquier timer existente para este usuario
  if (refreshTimers[userId]) {
    clearTimeout(refreshTimers[userId]);
  }

  const payload = decodeJWT(token);

  if (!payload || !payload.exp) {
    console.warn(
      "Token sin información de expiración, no se puede programar renovación"
    );
    return;
  }

  const expirationTime = payload.exp * 1000; // Convertir a milisegundos
  const currentTime = Date.now();

  // Si el token ya expiró, no programar renovación
  if (expirationTime <= currentTime) {
    console.warn("Token ya expirado, no se programa renovación");
    return;
  }

  const timeUntilRefresh = Math.max(
    0,
    expirationTime - currentTime - REFRESH_TOKEN_THRESHOLD
  );

  // Máximo un intento cada 30 segundos para evitar ciclos
  const refreshDelay = Math.max(timeUntilRefresh, 30000);

  // Programar la renovación del token
  let refreshAttempts = 0;
  const MAX_ATTEMPTS = 3;

  refreshTimers[userId] = setTimeout(async () => {
    try {
      // Evitar muchos intentos seguidos
      if (refreshAttempts >= MAX_ATTEMPTS) {
        console.warn(
          `Demasiados intentos de renovación (${refreshAttempts}). Suspendiendo renovación automática.`
        );
        return;
      }

      refreshAttempts++;

      // Intentar renovar el token silenciosamente
      const result = await signIn("refresh", { redirect: false });

      if (result?.error) {
        console.error("Error al renovar el token:", result.error);
        // No reprogramar si hay un error crítico
      } else {
        console.log("Token renovado exitosamente");
        refreshAttempts = 0; // Reiniciar contador de intentos tras éxito
      }
    } catch (error) {
      console.error("Error durante la renovación del token:", error);
    }
  }, refreshDelay);

  console.log(
    `Token programado para renovación en ${Math.floor(
      refreshDelay / 1000 / 60
    )} minutos`
  );
}

/**
 * Limpia todos los timers de renovación
 */
export function clearAllRefreshTimers() {
  Object.values(refreshTimers).forEach((timer) => clearTimeout(timer));
  refreshTimers = {};
}

/**
 * Genera un token CSRF aleatorio
 * @returns Token CSRF generado
 */
export function generateCSRFToken(): string {
  const array = new Uint8Array(32);
  window.crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join(
    ""
  );
}

/**
 * Almacena un token CSRF en sessionStorage
 * @param csrfToken El token CSRF a almacenar
 */
export function storeCSRFToken(csrfToken: string): void {
  if (typeof window !== "undefined") {
    sessionStorage.setItem("csrfToken", csrfToken);
  }
}

/**
 * Recupera el token CSRF de sessionStorage
 * @returns El token CSRF almacenado o null si no existe
 */
export function getStoredCSRFToken(): string | null {
  if (typeof window !== "undefined") {
    return sessionStorage.getItem("csrfToken");
  }
  return null;
}

/**
 * Verifica si un token CSRF es válido
 * @param token El token CSRF a verificar
 * @returns true si el token es válido, false de lo contrario
 */
export function validateCSRFToken(token: string): boolean {
  const storedToken = getStoredCSRFToken();
  return storedToken === token;
}


Ruta: lib\utils.ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

Ruta: lib\zod.ts
// lib/zod.ts
import { z } from "zod";

export const signInSchema = z.object({
  email: z
    .string({ required_error: "Email is required" })
    .min(1, "Email is required")
    .email("Invalid email"),
  password: z
    .string({ required_error: "Password is required" })
    .min(1, "Password is required")
    .min(4, "Password must be more than 4 characters") // Ajustado para demo
    .max(32, "Password must be less than 32 characters"),
});


Ruta: middleware\csrfToken.ts
// middleware/csrfToken.ts (mejorado)
import { NextRequest, NextResponse } from "next/server";

// Lista de rutas sensibles que requieren protección CSRF
const PROTECTED_ROUTES = [
  "/api/auth/register",
  "/api/auth/password-reset",
  "/api/profile/update",
  "/api/users",
  "/api/quotations",
  "/api/tasks",
  "/api/clients",
  "/api/products",
  "/api/maintenance",
  // Agregar más rutas según sea necesario
];

// Lista de métodos HTTP que requieren verificación CSRF
const PROTECTED_METHODS = ["POST", "PUT", "PATCH", "DELETE"];

/**
 * Verifica si una solicitud requiere protección CSRF
 */
function requiresCSRFProtection(req: NextRequest): boolean {
  const { pathname } = req.nextUrl;
  const method = req.method;

  // Solo verificar métodos que pueden modificar datos
  if (!PROTECTED_METHODS.includes(method)) {
    return false;
  }

  // Verificar si la ruta está en la lista de protegidas
  return PROTECTED_ROUTES.some((route) => pathname.startsWith(route));
}

/**
 * Middleware para verificar tokens CSRF
 */
export function csrfMiddleware(req: NextRequest) {
  // Verificar si la solicitud requiere protección CSRF
  if (requiresCSRFProtection(req)) {
    // Obtener el token CSRF del encabezado o del cuerpo
    const csrfToken = req.headers.get("X-CSRF-Token");

    // Si no hay token CSRF, rechazar la solicitud
    if (!csrfToken) {
      console.warn(
        `Solicitud rechazada: Token CSRF faltante en ${req.nextUrl.pathname}`
      );
      return NextResponse.json(
        { error: "Token CSRF faltante. Por favor, intenta nuevamente." },
        { status: 403 }
      );
    }

    // Continuar con la solicitud
    return NextResponse.next();
  }

  // Si no requiere protección CSRF, continuar normalmente
  return NextResponse.next();
}

Ruta: middleware.ts
// web/middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
// import { getToken } from "next-auth/jwt"; // No se usa si está desactivado

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  console.log(
    `[Middleware] Path: ${pathname} - MIDDLEWARE TEMPORALMENTE DESACTIVADO. Passing all requests through.`
  );

  // Simplemente permitir todas las peticiones
  return NextResponse.next();
}

// Para desactivar completamente el middleware, también puedes vaciar o comentar el matcher.
// Si dejas el matcher original, el middleware se ejecutará para esas rutas pero solo hará console.log y NextResponse.next().
// Para una desactivación más completa, usa un matcher que no coincida con nada o comenta el objeto config.
export const config = {
  // matcher: [], // Un matcher vacío significa que no se aplicará a ninguna ruta.
  // O comenta todo el objeto config para que el archivo no exporte un 'config' de middleware:
  /*
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|assets|.*\\..*).*)',
    "/dashboard/:path*",
    "/login",
    "/register",
    "/forgot-password",
    "/reset-password",
  ],
  */
};


Ruta: next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


Ruta: next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
};

export default nextConfig;


Ruta: README.md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


Ruta: services\agenda.ts
// services/task.ts
import { httpClient } from "@/lib/httpClient";

export interface Task {
  id?: number;
  title: string;
  description?: string;
  assignedTo: number;
  startDate: string;
  endDate: string;
  frequency: "DAILY" | "WEEKLY" | "MONTHLY";
}

export async function getTasks() {
  return httpClient("/task");
}

export async function getTaskById(id: string) {
  return httpClient(`/task/${id}`);
}

export async function createTask(task: Task) {
  return httpClient("/task", {
    method: "POST",
    body: JSON.stringify(task),
  });
}

export async function updateTask(id: string, task: Task) {
  return httpClient(`/task/${id}`, {
    method: "PUT",
    body: JSON.stringify(task),
  });
}

export async function deleteTask(id: string) {
  return httpClient(`/task/${id}`, {
    method: "DELETE",
  });
}


Ruta: services\auth.ts
export async function register(name: string, email: string, password: string) {
  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/auth/register`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email, password }),
      }
    );

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || "Error en el registro");
    }

    return { success: true, data };
  } catch (error) {
    console.error("Error en el registro:", error);
    // @ts-ignore
    return { success: false, error: error.message };
  }
}


Ruta: services\clients.ts
import { httpClient } from "@/lib/httpClient";

export interface Client {
  id?: string;
  name: string;
  email: string;
  emailSecondary?: string;
  emailTertiary?: string;
  phone: string;
  rut?: string;
  address?: string;
  commune?: string;
  administrator?: string;
  butler?: string;
  notes?: string;
}

interface ClientResponse {
  message?: string;
  client?: Client;
}

export async function getClients(): Promise<Client[]> {
  try {
    const response = await httpClient<Client[]>("/clients");
    console.log("Clientes obtenidos:", response);
    return response;
  } catch (error) {
    console.error("Error al obtener clientes:", error);
    throw error;
  }
}

export async function getClientById(id: string): Promise<Client> {
  try {
    const response = await httpClient<Client>(`/clients/${id}`);
    return response;
  } catch (error) {
    console.error(`Error al obtener cliente ${id}:`, error);
    throw error;
  }
}

export async function createClient(client: Client): Promise<Client> {
  try {
    const response = await httpClient<ClientResponse>("/clients", {
      method: "POST",
      body: JSON.stringify(client),
    });

    console.log("Respuesta al crear cliente:", response);

    // Si el backend devuelve un objeto con la propiedad 'client', usar ese objeto
    if (response.client) {
      return response.client;
    }

    // Si no, asumir que el backend devolvió directamente el cliente
    return response as unknown as Client;
  } catch (error) {
    console.error("Error al crear cliente:", error);
    throw error;
  }
}

export async function updateClient(
  id: string,
  client: Client
): Promise<Client> {
  try {
    const response = await httpClient<ClientResponse>(`/clients/${id}`, {
      method: "PUT",
      body: JSON.stringify(client),
    });

    // Si el backend devuelve un objeto con la propiedad 'client', usar ese objeto
    if (response.client) {
      return response.client;
    }

    // Si no, asumir que el backend devolvió directamente el cliente
    return response as unknown as Client;
  } catch (error) {
    console.error(`Error al actualizar cliente ${id}:`, error);
    throw error;
  }
}

export async function deleteClient(id: string): Promise<{ message: string }> {
  try {
    return await httpClient<{ message: string }>(`/clients/${id}`, {
      method: "DELETE",
    });
  } catch (error) {
    console.error(`Error al eliminar cliente ${id}:`, error);
    throw error;
  }
}


Ruta: services\maintenance.ts
import { httpClient } from "@/lib/httpClient";

export interface Maintenance {
  id?: number;
  clientId: number;
  client?: {
    id: number;
    name: string;
    email: string;
    phone?: string;
    address?: string;
  };
  lastMaintenanceDate: string;
  nextMaintenanceDate: string;
  frequency: "MENSUAL" | "BIMESTRAL" | "TRIMESTRAL" | "SEMESTRAL" | "ANUAL";
  notes?: string;
  taskIds?: number[];
  createdAt?: string;
  updatedAt?: string;
}

export interface MaintenanceResponse {
  message: string;
  maintenance: Maintenance;
}

/**
 * Obtiene todos los mantenimientos
 */
export async function getAllMaintenances(): Promise<Maintenance[]> {
  try {
    console.log("Obteniendo todos los mantenimientos...");
    const response = await httpClient<Maintenance[]>("/maintenance");
    console.log(`Se encontraron ${response.length} mantenimientos`);
    return response;
  } catch (error) {
    console.error("Error al obtener mantenimientos:", error);
    throw error;
  }
}

/**
 * Obtiene un mantenimiento por su ID
 */
export async function getMaintenanceById(id: string): Promise<Maintenance> {
  try {
    console.log(`Obteniendo mantenimiento con ID: ${id}`);
    const response = await httpClient<Maintenance>(`/maintenance/${id}`);
    console.log(`Mantenimiento obtenido: ${JSON.stringify(response, null, 2)}`);
    return response;
  } catch (error) {
    console.error(`Error al obtener mantenimiento ${id}:`, error);
    throw error;
  }
}

/**
 * Obtiene los mantenimientos de un cliente específico
 */
export async function getMaintenancesByClient(
  clientId: string
): Promise<Maintenance[]> {
  try {
    console.log(`Obteniendo mantenimientos para cliente ID: ${clientId}`);
    const response = await httpClient<Maintenance[]>(
      `/maintenance/client/${clientId}`
    );
    console.log(
      `Se encontraron ${response.length} mantenimientos para el cliente`
    );
    return response;
  } catch (error) {
    console.error(
      `Error al obtener mantenimientos del cliente ${clientId}:`,
      error
    );
    throw error;
  }
}

/**
 * Obtiene los mantenimientos próximos en un período de días específico
 */
export async function getUpcomingMaintenances(
  days: number = 30
): Promise<Maintenance[]> {
  try {
    console.log(`Obteniendo mantenimientos próximos (${days} días)...`);
    const response = await httpClient<Maintenance[]>(
      `/maintenance/upcoming?days=${days}`
    );
    console.log(`Se encontraron ${response.length} mantenimientos próximos`);
    return response;
  } catch (error) {
    console.error(
      `Error al obtener mantenimientos próximos (${days} días):`,
      error
    );
    throw error;
  }
}

/**
 * Crea un nuevo mantenimiento
 */
export async function createMaintenance(
  data: Maintenance
): Promise<MaintenanceResponse> {
  try {
    console.log("Creando nuevo mantenimiento:", data);
    const response = await httpClient<MaintenanceResponse>("/maintenance", {
      method: "POST",
      body: JSON.stringify(data),
    });
    console.log(`Mantenimiento creado con ID: ${response.maintenance.id}`);
    return response;
  } catch (error) {
    console.error("Error al crear mantenimiento:", error);
    throw error;
  }
}

/**
 * Actualiza un mantenimiento existente
 */
export async function updateMaintenance(
  id: string,
  data: Maintenance
): Promise<MaintenanceResponse> {
  try {
    console.log(`Actualizando mantenimiento ID: ${id}`, data);
    const response = await httpClient<MaintenanceResponse>(
      `/maintenance/${id}`,
      {
        method: "PUT",
        body: JSON.stringify(data),
      }
    );
    console.log(`Mantenimiento actualizado: ${response.message}`);
    return response;
  } catch (error) {
    console.error(`Error al actualizar mantenimiento ${id}:`, error);
    throw error;
  }
}

/**
 * Elimina un mantenimiento
 */
export async function deleteMaintenance(
  id: string
): Promise<{ message: string }> {
  try {
    console.log(`Eliminando mantenimiento ID: ${id}`);
    const response = await httpClient<{ message: string }>(
      `/maintenance/${id}`,
      {
        method: "DELETE",
      }
    );
    console.log(`Mantenimiento eliminado: ${response.message}`);
    return response;
  } catch (error) {
    console.error(`Error al eliminar mantenimiento ${id}:`, error);
    throw error;
  }
}

/**
 * Verifica el estado de los mantenimientos atrasados y actualiza sus fechas
 * Esta función sería útil para tests o para actualizar desde el frontend
 */
export async function checkExpiredMaintenances(): Promise<{ updated: number }> {
  try {
    console.log("Verificando mantenimientos vencidos...");
    const response = await httpClient<{ updated: number }>(
      "/maintenance/check-expired",
      {
        method: "POST",
      }
    );
    console.log(`Se actualizaron ${response.updated} mantenimientos vencidos`);
    return response;
  } catch (error) {
    console.error("Error al verificar mantenimientos vencidos:", error);
    throw error;
  }
}

export default {
  getAllMaintenances,
  getMaintenanceById,
  getMaintenancesByClient,
  getUpcomingMaintenances,
  createMaintenance,
  updateMaintenance,
  deleteMaintenance,
  checkExpiredMaintenances,
};


Ruta: services\products.ts
//web\services\products.ts
import { httpClient } from "@/lib/httpClient";
import { getSession } from "next-auth/react";
import { roundUp } from "@/utils/number-format";

export interface Product {
  id?: number | string;
  name: string;
  description?: string;
  unitPrice: number;
  markup: number;
  price: number;
  categoryId?: number;
  imageUrl?: string;
  createdAt?: string;
}

interface ProductResponse {
  message?: string;
  product?: Product;
}

export async function getProducts(): Promise<Product[]> {
  try {
    const response = await httpClient<Product[]>("/products");
    return response;
  } catch (error) {
    console.error("Error al obtener productos:", error);
    throw error;
  }
}

export async function getProductById(id: string): Promise<Product> {
  try {
    const response = await httpClient<Product>(`/products/${id}`);
    return response;
  } catch (error) {
    console.error(`Error al obtener producto ${id}:`, error);
    throw error;
  }
}

// Función auxiliar para manejar envío de FormData con autenticación
async function sendFormDataWithAuth(
  url: string,
  formData: FormData,
  method: string
): Promise<any> {
  const session = await getSession();
  const accessToken = session?.accessToken;

  const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000";
  const fullUrl = `${apiUrl}${url}`;

  const response = await fetch(fullUrl, {
    method: method,
    headers: {
      ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
    },
    credentials: "include",
    body: formData,
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error("Error response body:", errorText);

    let errorMessage;
    try {
      const errorJson = JSON.parse(errorText);
      errorMessage =
        errorJson.message ||
        errorJson.error ||
        `Error ${response.status}: ${response.statusText}`;
    } catch (e) {
      errorMessage =
        errorText || `Error ${response.status}: ${response.statusText}`;
    }

    throw new Error(errorMessage);
  }

  return response.json();
}

export const createProduct = async (
  productData: Product | FormData
): Promise<{ message: string; product: Product }> => {
  try {
    if (productData instanceof FormData) {
      // Si es FormData, usar la función auxiliar
      return await sendFormDataWithAuth("/products", productData, "POST");
    } else {
      // Si es un objeto Product, usar httpClient normal
      return await httpClient<{ message: string; product: Product }>(
        "/products",
        {
          method: "POST",
          body: JSON.stringify(productData),
        }
      );
    }
  } catch (error) {
    console.error("Error creating product:", error);
    throw error;
  }
};

export async function updateProduct(
  id: string,
  product: Product | FormData,
  imageFile?: File
): Promise<ProductResponse> {
  try {
    // Si product es FormData, enviarlo directamente
    if (product instanceof FormData) {
      return await sendFormDataWithAuth(`/products/${id}`, product, "PUT");
    }

    // Caso tradicional - manejar object + archivo separado
    // Asegurarse de que se establezca el markup si no se ha definido
    if (product.markup === undefined) {
      product.markup = 35; // 35% por defecto
    }

    // Redondear precio unitario hacia arriba
    product.unitPrice = roundUp(product.unitPrice);

    // Calcular el precio final basado en el precio unitario y el markup
    const markupAmount = Math.ceil((product.unitPrice * product.markup) / 100);
    product.price = product.unitPrice + markupAmount;

    // Si hay una imagen, usar FormData para enviar tanto los datos como la imagen
    if (imageFile) {
      const formData = new FormData();

      // Agregar todos los campos del producto EXCEPTO imageUrl
      Object.keys(product).forEach((key) => {
        // No enviar el campo imageUrl si estamos enviando un archivo
        if (key !== "imageUrl") {
          const value = product[key as keyof Product];
          if (value !== undefined && value !== null) {
            formData.append(key, value.toString());
          }
        }
      });

      // Solo agregar imageUrl si no estamos enviando un archivo nuevo
      if (!imageFile && product.imageUrl) {
        formData.append("imageUrl", product.imageUrl);
      }

      // Agregar el archivo de imagen
      formData.append("image", imageFile);

      console.log("Enviando formData sin imageUrl porque hay archivo nuevo");

      // Usar nuestra función auxiliar para enviar FormData
      return await sendFormDataWithAuth(`/products/${id}`, formData, "PUT");
    } else {
      // Si no hay imagen, usar el httpClient normal con JSON
      const response = await httpClient<ProductResponse>(`/products/${id}`, {
        method: "PUT",
        body: JSON.stringify(product),
      });
      return response;
    }
  } catch (error) {
    console.error(`Error al actualizar producto ${id}:`, error);
    throw error;
  }
}

export async function deleteProduct(id: string): Promise<{ message: string }> {
  try {
    return await httpClient<{ message: string }>(`/products/${id}`, {
      method: "DELETE",
    });
  } catch (error) {
    console.error(`Error al eliminar producto ${id}:`, error);
    throw error;
  }
}

// Función para subir imágenes
export async function uploadProductImage(
  file: File
): Promise<{ imageUrl: string }> {
  try {
    const formData = new FormData();
    formData.append("image", file);

    // Usar nuestra función auxiliar para enviar FormData
    return await sendFormDataWithAuth(
      "/upload/product-image",
      formData,
      "POST"
    );
  } catch (error) {
    console.error("Error al subir la imagen:", error);
    throw error;
  }
}


Ruta: services\profile.ts
// services/profile.ts
import { httpClient } from "@/lib/httpClient";

export interface ProfileUser {
  id: number;
  email: string;
  name: string;
  phone?: string;
  role: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface ProfileResponse {
  message: string;
  user: ProfileUser;
}

export interface ProfileUpdateData {
  name?: string;
  phone?: string;
}

export interface PasswordUpdateData {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

// Obtener el perfil del usuario actual
export async function getProfile(): Promise<ProfileUser> {
  try {
    return await httpClient<ProfileUser>("/users/me");
  } catch (error) {
    console.error("Error al obtener perfil de usuario:", error);
    throw error;
  }
}

// Actualizar el perfil del usuario
export async function updateProfile(
  userData: ProfileUpdateData
): Promise<ProfileResponse> {
  try {
    return await httpClient<ProfileResponse>("/users/me", {
      method: "PUT",
      body: JSON.stringify(userData),
    });
  } catch (error) {
    console.error("Error al actualizar perfil de usuario:", error);
    throw error;
  }
}

// Actualizar la contraseña del usuario
export async function updatePassword(
  data: PasswordUpdateData
): Promise<{ message: string }> {
  // Convertimos los datos al formato que espera el backend
  const passwordData = {
    currentPassword: data.currentPassword,
    newPassword: data.newPassword,
    confirmPassword: data.confirmPassword,
  };

  try {
    return await httpClient<{ message: string }>("/users/me/password", {
      method: "PUT",
      body: JSON.stringify(passwordData),
    });
  } catch (error) {
    console.error("Error al actualizar contraseña:", error);
    throw error;
  }
}


Ruta: services\quotations.ts
//web\services\quotations.ts
import { httpClient } from "@/lib/httpClient";
import { getSession } from "next-auth/react";

export interface QuotationItem {
  productId: number;
  quantity: number;
  price?: number;
  total?: number;
  product: {
    id: number;
    name: string;
    price: number;
    markup: number;
    unitPrice: number;
  };
}

export interface QuotationCategory {
  name: string;
  items: QuotationItem[];
}

export interface Quotation {
  id?: string;
  clientId: number;
  title: string;
  description?: string;
  validUntil?: string;
  categories: QuotationCategory[];
  client: {
    id: string;
    name: string;
    email: string;
  };
  status?: string;
  createdAt?: string;
  updatedAt?: string;
  amount?: number; // Para compatibilidad con la vista de tareas
  advancePercentage?: number; // Nuevo campo para el porcentaje de abono
}

export interface Pagination {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
}

export interface QuotationsDataResponse {
  quotations: Quotation[];
  pagination: Pagination;
}

export interface QuotationResponse {
  message: string;
  quotation: Quotation;
}

export interface QuotationsParams {
  page?: number;
  limit?: number;
  search?: string;
  clientId?: number;
  status?: string;
  startDate?: string;
  endDate?: string;
}

// Obtener cotizaciones filtradas y paginadas
export async function getQuotationsData(
  params: QuotationsParams = {}
): Promise<QuotationsDataResponse> {
  const queryParams = new URLSearchParams();

  if (params.page !== undefined)
    queryParams.append("page", params.page.toString());
  if (params.limit !== undefined)
    queryParams.append("limit", params.limit.toString());
  if (params.search) queryParams.append("search", params.search);
  if (params.clientId !== undefined)
    queryParams.append("clientId", params.clientId.toString());
  if (params.status) queryParams.append("status", params.status);
  if (params.startDate) queryParams.append("startDate", params.startDate);
  if (params.endDate) queryParams.append("endDate", params.endDate);

  const queryString = queryParams.toString();
  const url = `/quotations/data${queryString ? `?${queryString}` : ""}`;

  return httpClient<QuotationsDataResponse>(url);
}

export async function getQuotations(): Promise<Quotation[]> {
  return httpClient<Quotation[]>("/quotations");
}

export async function getQuotationsByDateRange(
  startDate: string,
  endDate: string
): Promise<Quotation[]> {
  const queryParams = new URLSearchParams();
  queryParams.append("startDate", startDate);
  queryParams.append("endDate", endDate);

  return httpClient<Quotation[]>(`/quotations?${queryParams.toString()}`);
}

export async function getQuotationById(id: string): Promise<Quotation> {
  return httpClient<Quotation>(`/quotations/${id}`);
}

// Obtener cotizaciones por cliente
export async function getQuotationsByClient(
  clientId: number
): Promise<Quotation[]> {
  try {
    return await httpClient<Quotation[]>(`/quotations/client/${clientId}`);
  } catch (error) {
    console.error(
      `Error al obtener cotizaciones del cliente ${clientId}:`,
      error
    );
    // En caso de error, devolver un array vacío para manejar mejor el error en los componentes
    return [];
  }
}

export async function createQuotation(
  quotation: Quotation
): Promise<QuotationResponse> {
  // Calcular los totales de items con ganancia del 35% antes de enviar
  const calculatedQuotation = {
    ...quotation,
    status: quotation.status || "SENT", // Estado por defecto
    advancePercentage:
      quotation.advancePercentage !== undefined
        ? quotation.advancePercentage
        : 50, // Usar el valor proporcionado o 50% por defecto
    categories: quotation.categories.map((category) => ({
      ...category,
      items: category.items.map((item) => {
        const providerPrice =
          item.price || (item.product ? item.product.price : 0);
        const total = providerPrice * item.quantity;
        return {
          ...item,
          price: providerPrice, // Precio del proveedor
          total: total, // Total sin ganancia (el backend calculará la ganancia)
        };
      }),
    })),
  };

  return httpClient<QuotationResponse>("/quotations", {
    method: "POST",
    body: JSON.stringify(calculatedQuotation),
  });
}

export async function updateQuotation(
  id: string,
  quotation: Quotation
): Promise<QuotationResponse> {
  // Calcular los totales de items con ganancia del 35% antes de enviar
  const calculatedQuotation = {
    ...quotation,
    // Incluir el porcentaje de abono si está definido
    advancePercentage:
      quotation.advancePercentage !== undefined
        ? quotation.advancePercentage
        : undefined,
    categories: quotation.categories.map((category) => ({
      ...category,
      items: category.items.map((item) => {
        const providerPrice =
          item.price || (item.product ? item.product.price : 0);
        const total = providerPrice * item.quantity;
        return {
          ...item,
          price: providerPrice, // Precio del proveedor
          total: total, // Total sin ganancia (el backend calculará la ganancia)
        };
      }),
    })),
  };

  return httpClient<QuotationResponse>(`/quotations/${id}`, {
    method: "PUT",
    body: JSON.stringify(calculatedQuotation),
  });
}

export async function deleteQuotation(id: string): Promise<any> {
  return httpClient<{ message: string }>(`/quotations/${id}`, {
    method: "DELETE",
  });
}

export async function updateQuotationStatus(
  id: string,
  status: string
): Promise<QuotationResponse> {
  return httpClient<QuotationResponse>(`/quotations/${id}/status`, {
    method: "PUT", // Cambiado de PATCH a PUT para coincidir con el backend
    body: JSON.stringify({ status }),
  });
}

export async function sendQuotationEmail(
  id: string
): Promise<{ message: string }> {
  return httpClient<{ message: string }>(`/quotations/${id}/send-email`, {
    method: "POST",
  });
}

export async function downloadQuotationPDF(id: string): Promise<Blob> {
  const session = await getSession();
  const token = session?.accessToken || "";

  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_URL}/quotations/${id}/pdf`,
    {
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    }
  );

  if (!response.ok) {
    throw new Error("Error al descargar la cotización");
  }

  return response.blob();
}

// Función para obtener estadísticas de cotizaciones
export async function getQuotationStats(
  params: QuotationsParams = {}
): Promise<any> {
  const queryParams = new URLSearchParams();

  if (params.startDate) queryParams.append("startDate", params.startDate);
  if (params.endDate) queryParams.append("endDate", params.endDate);
  if (params.status) queryParams.append("status", params.status);
  if (params.clientId !== undefined)
    queryParams.append("clientId", params.clientId.toString());

  const queryString = queryParams.toString();
  const url = `/quotations/stats${queryString ? `?${queryString}` : ""}`;

  return httpClient<any>(url);
}


Ruta: services\reports.ts
// services/reports.ts
import { httpClient } from "@/lib/httpClient";
import { getSession } from "next-auth/react";
import { QuotationsParams } from "./quotations";

export interface ReportFilter {
  startDate: string;
  endDate: string;
  clientId?: string;
  status?: string;
  productId?: string;
}

export async function generateCustomReport(filter: ReportFilter) {
  const params = new URLSearchParams();
  params.append("startDate", filter.startDate);
  params.append("endDate", filter.endDate);
  if (filter.clientId) {
    params.append("clientId", filter.clientId);
  }
  if (filter.status) {
    params.append("status", filter.status);
  }
  if (filter.productId) {
    params.append("productId", filter.productId);
  }

  return httpClient(`/reports/custom?${params.toString()}`);
}

export async function downloadReportPDF(filter: ReportFilter) {
  const session = await getSession();
  const token = session?.accessToken || "";

  const params = new URLSearchParams();
  params.append("startDate", filter.startDate);
  params.append("endDate", filter.endDate);
  if (filter.clientId) {
    params.append("clientId", filter.clientId);
  }
  if (filter.status) {
    params.append("status", filter.status);
  }
  if (filter.productId) {
    params.append("productId", filter.productId);
  }

  const response = await fetch(
    `${
      process.env.NEXT_PUBLIC_API_URL
    }/reports/custom/pdf?${params.toString()}`,
    {
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    }
  );

  if (!response.ok) {
    throw new Error("Error al descargar el reporte");
  }

  return response.blob();
}

export async function downloadReportExcel(filter: ReportFilter) {
  const session = await getSession();
  const token = session?.accessToken || "";

  const params = new URLSearchParams();
  params.append("startDate", filter.startDate);
  params.append("endDate", filter.endDate);
  if (filter.clientId) {
    params.append("clientId", filter.clientId);
  }
  if (filter.status) {
    params.append("status", filter.status);
  }
  if (filter.productId) {
    params.append("productId", filter.productId);
  }

  const response = await fetch(
    `${
      process.env.NEXT_PUBLIC_API_URL
    }/reports/custom/excel?${params.toString()}`,
    {
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    }
  );

  if (!response.ok) {
    throw new Error("Error al descargar el reporte");
  }

  return response.blob();
}

// Obtener las estadísticas de ventas para el dashboard
export async function getSalesStats(
  period: "week" | "month" | "year" = "month",
  startDate?: string,
  endDate?: string
) {
  try {
    const params = new URLSearchParams();
    params.append("period", period);

    if (startDate) params.append("startDate", startDate);
    if (endDate) params.append("endDate", endDate);

    console.log("getSalesStats URL params:", params.toString());

    const url = `/reports/sales-stats?${params.toString()}`;
    console.log("Petición URL:", url);

    return httpClient(url);
  } catch (error) {
    console.error("Error en getSalesStats:", error);
    throw error;
  }
}

// Actualización para el servicio getQuotationStats
export async function getQuotationStats(
  params: QuotationsParams = {}
): Promise<any> {
  const queryParams = new URLSearchParams();

  if (params.startDate) queryParams.append("startDate", params.startDate);
  if (params.endDate) queryParams.append("endDate", params.endDate);
  if (params.status) queryParams.append("status", params.status);
  if (params.clientId !== undefined)
    queryParams.append("clientId", params.clientId.toString());

  const queryString = queryParams.toString();
  const url = `/quotations/stats${queryString ? `?${queryString}` : ""}`;

  return httpClient<any>(url);
}

// Obtener las métricas de rendimiento para un trabajador específico
export async function getWorkerPerformance(
  workerId: string,
  startDate: string,
  endDate: string
) {
  const params = new URLSearchParams();
  params.append("startDate", startDate);
  params.append("endDate", endDate);

  return httpClient(
    `/reports/worker-performance/${workerId}?${params.toString()}`
  );
}

// Obtener el historial de cotizaciones y trabajos para un cliente específico
export async function getClientHistory(clientId: string) {
  return httpClient(`/reports/client-history/${clientId}`);
}

// Obtener métricas de productos más vendidos
export async function getTopProducts(
  limit: number = 10,
  startDate?: string,
  endDate?: string
) {
  const params = new URLSearchParams();
  params.append("limit", limit.toString());
  if (startDate) params.append("startDate", startDate);
  if (endDate) params.append("endDate", endDate);

  return httpClient(`/reports/top-products?${params.toString()}`);
}


Ruta: services\serviceReports.ts
// services/serviceReports.ts
import { httpClient } from "@/lib/httpClient";
import { getSession } from "next-auth/react";

export interface ServiceReport {
  id?: number;
  taskId: number;
  description: string;
  hoursWorked: number;
  observations?: string;
  photoUrls?: string[];
}

export async function getServiceReports() {
  return httpClient("/service-reports");
}

export async function getServiceReportById(id: string) {
  return httpClient(`/service-reports/${id}`);
}

export async function createServiceReport(report: ServiceReport) {
  return httpClient("/service-reports", {
    method: "POST",
    body: JSON.stringify(report),
  });
}

export async function updateServiceReport(id: string, report: ServiceReport) {
  return httpClient(`/service-reports/${id}`, {
    method: "PUT",
    body: JSON.stringify(report),
  });
}

export async function deleteServiceReport(id: string) {
  return httpClient(`/service-reports/${id}`, {
    method: "DELETE",
  });
}

export async function uploadReportImage(file: File) {
  const formData = new FormData();
  formData.append("file", file);

  const session = await getSession();
  const token = session?.accessToken || "";

  const response = await fetch(
    `${process.env.NEXT_PUBLIC_API_URL}/upload/report-image`,
    {
      method: "POST",
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
      body: formData,
    }
  );

  if (!response.ok) {
    throw new Error("Error al subir la imagen");
  }

  return response.json();
}


Ruta: services\tasks.ts
// services/tasks.ts
import { httpClient } from "@/lib/httpClient";

export interface TaskAssignment {
  taskId: number;
  workerId: number;
  worker: {
    id: number;
    name: string;
    email: string;
  };
}

export interface Task {
  id?: number;
  title: string;
  description?: string;
  quotationId?: number | null;
  clientId?: number;
  state: string;
  types: string[];
  categories: string[];
  technicalReport?: string;
  observations?: string;
  hoursWorked?: number;
  mediaUrls?: string[];
  startDate: string;
  endDate?: string;
  assignedWorkerIds?: number[];
  assignedWorkers?: TaskAssignment[];
  client?: {
    id: number;
    name: string;
    email: string;
    phone?: string;
    rut?: string;
    address?: string;
    commune?: string;
    administrator?: string;
    butler?: string;
  };
  quotation?: {
    id: number;
    title: string;
    amount: number;
  };
  reminderSent?: boolean;
  createdAt?: string;
  updatedAt?: string;
  metadata?: any;
}

export interface TaskResponse {
  message: string;
  task: Task;
}

export interface TasksByDateResponse {
  tasks: Task[];
  start: string;
  end: string;
}

export interface TasksByDateParams {
  date: string;
  view: "daily" | "weekly" | "monthly";
}

export interface FinalizeTaskData {
  taskId: number;
  technicalReport: string;
  observations?: string;
  hoursWorked: number;
  mediaUrls?: string[];
  endDate?: string;
  types?: string[];
  systems?: string[];
  technicians?: string[];
  nameWhoReceives?: string;
  positionWhoReceives?: string;
  imageUrlWhoReceives?: string;
}

// NUEVA INTERFAZ PARA FILTROS
export interface TaskFilterParams {
  clientId?: string;
  taskType?: string;
  startDate?: string;
  endDate?: string;
  state?: string;
  workerId?: string;
  quotationId?: string;
  // Podrías añadir paginación aquí si el backend la soporta para este endpoint
  // page?: number;
  // limit?: number;
}

async function getAuthToken(): Promise<string> {
  const session = await import("next-auth/react").then((mod) =>
    mod.getSession()
  );
  return session?.accessToken || "";
}

function ensureWorkersArray(
  workerIds: number | number[] | undefined
): number[] {
  if (!workerIds) {
    return [];
  }
  if (Array.isArray(workerIds)) {
    return workerIds;
  }
  return [workerIds];
}

// MODIFICADO: getAllTasks ahora puede tomar filtros
export async function getAllTasks(filters?: TaskFilterParams): Promise<Task[]> {
  try {
    let url = "/tasks";
    if (filters) {
      const queryParams = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== "") {
          queryParams.append(key, String(value));
        }
      });
      if (queryParams.toString()) {
        url += `?${queryParams.toString()}`;
      }
    }
    return await httpClient<Task[]>(url);
  } catch (error) {
    console.error("Error al obtener todas las tareas:", error);
    throw error;
  }
}

export async function getTasksByDate(
  queryParams: string | TasksByDateParams
): Promise<TasksByDateResponse> {
  try {
    let queryString: string;
    if (typeof queryParams === "string") {
      queryString = queryParams;
    } else {
      const params = new URLSearchParams();
      params.append("date", queryParams.date);
      params.append("view", queryParams.view);
      queryString = params.toString();
    }
    return await httpClient<TasksByDateResponse>(
      `/tasks/by-date?${queryString}`
    );
  } catch (error) {
    console.error("Error al obtener tareas por fecha:", error);
    throw error;
  }
}

export async function getWorkerTasks(
  queryParams: string | TasksByDateParams
): Promise<TasksByDateResponse> {
  try {
    let queryString: string;
    if (typeof queryParams === "string") {
      queryString = queryParams;
    } else {
      const params = new URLSearchParams();
      params.append("date", queryParams.date);
      params.append("view", queryParams.view);
      queryString = params.toString();
    }
    return await httpClient<TasksByDateResponse>(
      `/tasks/worker?${queryString}`
    );
  } catch (error) {
    console.error("Error al obtener tareas del trabajador:", error);
    throw error;
  }
}

export async function createTask(taskData: Task): Promise<TaskResponse> {
  try {
    const processedData = {
      ...taskData,
      quotationId: taskData.quotationId || undefined,
      types: taskData.types || [],
      categories: taskData.categories || [],
      mediaUrls: taskData.mediaUrls || [],
      assignedWorkerIds: ensureWorkersArray(taskData.assignedWorkerIds),
    };
    return await httpClient<TaskResponse>("/tasks", {
      method: "POST",
      body: JSON.stringify(processedData),
    });
  } catch (error) {
    console.error("Error al crear tarea:", error);
    throw error;
  }
}

export async function updateTask(
  id: string,
  taskData: Task
): Promise<TaskResponse> {
  try {
    const processedData = {
      ...taskData,
      quotationId: taskData.quotationId || undefined,
      types: taskData.types || [],
      categories: taskData.categories || [],
      mediaUrls: taskData.mediaUrls || [],
      assignedWorkerIds: ensureWorkersArray(taskData.assignedWorkerIds),
    };
    if (processedData.client) delete processedData.client;
    if (processedData.quotation) delete processedData.quotation;
    if (processedData.assignedWorkers) delete processedData.assignedWorkers;
    if (processedData.reminderSent) delete processedData.reminderSent;
    if (processedData.createdAt) delete processedData.createdAt;
    if (processedData.updatedAt) delete processedData.updatedAt;

    try {
      return await httpClient<TaskResponse>(`/tasks/${id}`, {
        method: "PUT",
        body: JSON.stringify(processedData),
      });
    } catch (error: any) {
      if (
        error.message &&
        error.message.includes("Forbidden") &&
        (error.message.includes("sendgrid") ||
          error.message.includes("SendGrid"))
      ) {
        console.warn(
          "Error de envío de correo detectado. La tarea se actualizó pero no se pudieron enviar notificaciones."
        );
        try {
          const task = await httpClient<Task>(`/tasks/${id}`); // Asumiendo que tienes un endpoint para obtener una tarea por ID
          return {
            message: "Task updated successfully but email notifications failed",
            task,
          };
        } catch (getError) {
          throw error;
        }
      }
      throw error;
    }
  } catch (error) {
    console.error(`Error al actualizar tarea ${id}:`, error);
    throw error;
  }
}

export async function deleteTask(id: string): Promise<{ message: string }> {
  try {
    return await httpClient<{ message: string }>(`/tasks/${id}`, {
      method: "DELETE",
    });
  } catch (error) {
    console.error(`Error al eliminar tarea ${id}:`, error);
    throw error;
  }
}

export async function startTask(taskId: number): Promise<TaskResponse> {
  try {
    return await httpClient<TaskResponse>("/tasks/start", {
      method: "POST",
      body: JSON.stringify({ taskId }),
    });
  } catch (error) {
    console.error("Error al iniciar tarea:", error);
    throw error;
  }
}

export async function finalizeTask(
  data: FinalizeTaskData
): Promise<TaskResponse> {
  try {
    const processedData = {
      ...data,
      mediaUrls: data.mediaUrls || [],
      types: data.types || [],
      systems: data.systems || [],
      technicians: data.technicians || [],
    };
    return await httpClient<TaskResponse>("/tasks/finalize", {
      method: "POST",
      body: JSON.stringify(processedData), // Enviar como JSON si el backend espera JSON
    });
  } catch (error) {
    if (error instanceof Error && error.message.includes("Forbidden")) {
      console.warn(
        "Advertencia: No se pudo enviar el correo electrónico, pero la tarea fue finalizada"
      );
      try {
        const taskResponse = await httpClient<{ task: Task }>(
          `/tasks/${data.taskId}`,
          {
            method: "GET",
          }
        );
        return {
          message: "Task finalized successfully but email could not be sent",
          task: taskResponse.task,
        };
      } catch (secondError) {
        throw error;
      }
    }
    console.error("Error al finalizar tarea:", error);
    throw error;
  }
}

export async function downloadTaskReport(taskId: string): Promise<Blob> {
  try {
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/tasks/${taskId}/report-pdf`,
      {
        headers: {
          Authorization: `Bearer ${await getAuthToken()}`,
        },
      }
    );
    if (!response.ok) {
      throw new Error(`Error al descargar el informe: ${response.statusText}`);
    }
    return response.blob();
  } catch (error) {
    console.error(
      `Error al descargar informe técnico de tarea ${taskId}:`,
      error
    );
    throw error;
  }
}

export async function uploadTaskImageFormData(
  file: File,
  type: string = "work"
): Promise<string> {
  try {
    const formData = new FormData();
    formData.append("image", file);
    formData.append("type", type);
    const session = await import("next-auth/react").then((mod) =>
      mod.getSession()
    );
    const accessToken = session?.accessToken;
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/tasks/upload-image`,
      {
        method: "POST",
        headers: {
          ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        },
        body: formData,
      }
    );
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({
        message: `Error ${response.status}: ${response.statusText}`,
      }));
      throw new Error(
        errorData.message || `Error al subir imagen: ${response.statusText}`
      );
    }
    const result = await response.json();
    return result.imageUrl;
  } catch (error) {
    console.error("Error al subir imagen de tarea:", error);
    throw error;
  }
}


Ruta: services\uploads.ts
// services/uploads.ts
import { httpClient } from "@/lib/httpClient";
import { getSession } from "next-auth/react";

/**
 * Sube una imagen para una tarea (trabajo realizado o quien recibe)
 * @param file Archivo de imagen a subir
 * @param type Tipo de imagen ('work' o 'who-receives')
 * @returns URL de la imagen subida
 */
export async function uploadTaskImage(
  file: File, // El archivo ya debería estar comprimido y en formato JPEG/PNG por compressImage
  type: "work" | "who-receives"
): Promise<string> {
  try {
    const formData = new FormData();
    formData.append("image", file); // Enviar el archivo procesado
    formData.append("type", type);

    const session = await getSession();
    const accessToken = session?.accessToken;

    const response = await fetch(
      `${process.env.NEXT_PUBLIC_API_URL}/tasks/upload-image`,
      {
        method: "POST",
        headers: {
          ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {}),
        },
        credentials: "include", // Asegúrate que esto sea necesario y compatible con tu CORS
        body: formData,
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({
        message: `Error ${response.status}: ${response.statusText}`,
      }));
      throw new Error(
        errorData.message || `Error al subir imagen: ${response.statusText}`
      );
    }

    const data = await response.json();
    return data.imageUrl;
  } catch (error) {
    console.error("Error al subir imagen de tarea:", error);
    throw error;
  }
}

/**
 * Comprime una imagen antes de subirla y la convierte a JPEG.
 * @param file Archivo de imagen original
 * @param maxWidth Ancho máximo en píxeles
 * @param quality Calidad de compresión JPEG (0-1)
 * @returns Archivo comprimido como Blob en formato JPEG
 */
export async function compressImage(
  file: File,
  maxWidth = 1200, // Mantenido como en tu código original
  quality = 0.7 // Calidad para JPEG, 0.7 es un buen compromiso
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (event) => {
      const img = new Image();
      if (!event.target?.result) {
        return reject(new Error("Error al leer el archivo de imagen."));
      }
      img.src = event.target.result as string;

      img.onload = () => {
        let width = img.width;
        let height = img.height;

        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        if (!ctx) {
          return reject(new Error("No se pudo crear el contexto de canvas"));
        }

        canvas.width = width;
        canvas.height = height;

        // Dibujar imagen en el canvas (esto la convierte a un formato que el canvas entiende, usualmente PNG/JPEG internamente)
        ctx.drawImage(img, 0, 0, width, height);

        // Convertir a blob como JPEG
        canvas.toBlob(
          (blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error("Error al generar blob desde canvas"));
            }
          },
          "image/jpeg", // Forzar la salida a JPEG
          quality
        );
      };

      img.onerror = (error) => {
        console.error("Error al cargar la imagen en el elemento Image:", error);
        reject(
          new Error(
            "Error al cargar la imagen para compresión. Formato podría no ser soportado por el navegador."
          )
        );
      };
    };

    reader.onerror = (error) => {
      console.error("Error en FileReader:", error);
      reject(new Error("Error al leer el archivo de imagen."));
    };
  });
}

/**
 * Crea un archivo File a partir de un Blob.
 * Asegura que el nombre del archivo tenga la extensión .jpeg si se convirtió a JPEG.
 * @param blob Blob de datos
 * @param originalFileName Nombre del archivo original (para obtener la base del nombre)
 * @param options Opciones adicionales
 * @returns Objeto File
 */
export function blobToFile(
  blob: Blob,
  originalFileName: string, // Necesitamos el nombre original para generar uno nuevo
  options?: FilePropertyBag
): File {
  // Generar un nuevo nombre de archivo con extensión .jpeg
  const nameWithoutExtension =
    originalFileName.substring(0, originalFileName.lastIndexOf(".")) ||
    originalFileName;
  const newFileName = `${nameWithoutExtension}.jpeg`;

  return new File([blob], newFileName, {
    // Usar el nuevo nombre con extensión .jpeg
    type: "image/jpeg", // El tipo MIME ahora es image/jpeg
    lastModified: Date.now(),
    ...options,
  });
}


Ruta: services\users.ts
// web/services/users.ts
import { httpClient } from "@/lib/httpClient";

export interface User {
  id: number;
  name: string;
  email: string;
  role: "ADMIN" | "WORKER";
  password?: string;
  phone?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface UserResponse {
  message: string;
  user: User;
}

export async function getUsers(): Promise<User[]> {
  try {
    return await httpClient<User[]>("/users");
  } catch (error) {
    console.error("Error al obtener usuarios:", error);
    throw error;
  }
}

export async function getUserById(id: string): Promise<User> {
  try {
    return await httpClient<User>(`/users/${id}`);
  } catch (error) {
    console.error(`Error al obtener usuario ${id}:`, error);
    throw error;
  }
}

export async function createUser(user: User): Promise<UserResponse> {
  try {
    const payload: any = { ...user };
    if (!user.password) {
      // El backend ahora lo requiere explícitamente en su schema de creación
      throw new Error("La contraseña es requerida para crear un usuario.");
    }
    return await httpClient<UserResponse>("/users", {
      method: "POST",
      body: JSON.stringify(payload),
    });
  } catch (error) {
    console.error("Error al crear usuario:", error);
    throw error;
  }
}

export async function updateUser(
  id: string,
  user: Partial<User>
): Promise<UserResponse> {
  try {
    const { password, ...profileData } = user;
    return await httpClient<UserResponse>(`/users/${id}`, {
      method: "PUT",
      body: JSON.stringify(profileData),
    });
  } catch (error) {
    console.error(`Error al actualizar usuario ${id}:`, error);
    throw error;
  }
}

export async function adminSetUserPassword(
  userId: string,
  newPassword: string
): Promise<{ message: string }> {
  try {
    return await httpClient<{ message: string }>(`/users/${userId}/password`, {
      method: "PUT",
      body: JSON.stringify({ password: newPassword }),
    });
  } catch (error) {
    console.error(
      `Error al actualizar contraseña para usuario ${userId} por admin:`,
      error
    );
    throw error;
  }
}

export async function deleteUser(id: string): Promise<{ message: string }> {
  try {
    return await httpClient<{ message: string }>(`/users/${id}`, {
      method: "DELETE",
    });
  } catch (error) {
    console.error(`Error al eliminar usuario ${id}:`, error);
    throw error;
  }
}

export async function getUserProfile(): Promise<User> {
  try {
    return await httpClient<User>("/users/me");
  } catch (error) {
    console.error("Error al obtener perfil de usuario:", error);
    throw error;
  }
}

export async function updateUserProfile(
  userData: Partial<User>
): Promise<UserResponse> {
  try {
    const { password, ...profileData } = userData;
    return await httpClient<UserResponse>("/users/me", {
      method: "PUT",
      body: JSON.stringify(profileData),
    });
  } catch (error) {
    console.error("Error al actualizar perfil de usuario:", error);
    throw error;
  }
}


Ruta: tailwind.config.ts
// tailwind.config.ts
import { themes } from "./lib/themes";
import type { Config } from "tailwindcss";

export default {
  // darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        primary: {
          DEFAULT: themes.default.primary.DEFAULT,
          foreground: themes.default.primary.foreground,
          hover: themes.default.primary.hover,
          focus: themes.default.primary.focus,
        },
        secondary: {
          DEFAULT: themes.default.secondary.DEFAULT,
          foreground: themes.default.secondary.foreground,
          hover: themes.default.secondary.hover,
          focus: themes.default.secondary.focus,
        },
        background: {
          DEFAULT: themes.default.background.DEFAULT,
          secondary: themes.default.background.secondary,
        },
        border: {
          DEFAULT: themes.default.border.DEFAULT,
          focus: themes.default.border.focus,
        },
        ring: {
          DEFAULT: themes.default.ring.DEFAULT,
          focus: themes.default.ring.focus,
        },
        content: {
          subtle: themes.default.content.subtle,
          DEFAULT: themes.default.content.DEFAULT,
          emphasis: themes.default.content.emphasis,
        },
        accent: {
          DEFAULT: themes.default.accent.DEFAULT,
          hover: themes.default.accent.hover,
        },
        error: {
          DEFAULT: themes.default.error.DEFAULT,
          foreground: themes.default.error.foreground,
        },
        success: {
          DEFAULT: themes.default.success.DEFAULT,
          foreground: themes.default.success.foreground,
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        fadeIn: {
          from: { opacity: "0" },
          to: { opacity: "1" },
        },
        fadeOut: {
          from: { opacity: "1" },
          to: { opacity: "0" },
        },
        zoomIn: {
          from: { opacity: "0", transform: "scale(0.95)" },
          to: { opacity: "1", transform: "scale(1)" },
        },
        zoomOut: {
          from: { opacity: "1", transform: "scale(1)" },
          to: { opacity: "0", transform: "scale(0.95)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        fadeIn: "fadeIn 0.2s ease-out",
        fadeOut: "fadeOut 0.2s ease-out",
        zoomIn: "zoomIn 0.2s ease-out",
        zoomOut: "zoomOut 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;


Ruta: tsconfig.json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


Ruta: types\next-auth.d.ts
import "next-auth";
import "next-auth/jwt";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      email: string;
      name: string;
      role: string;
      image?: string | null;
    };
    expires: string; // Esta es la expiración de la sesión de NextAuth
    accessToken?: string; // Token de acceso de tu backend
    error?: "RefreshFailed" | "TokenExpired" | "SessionExpiredForceLogout"; // Para errores de token
  }

  interface User {
    // El objeto 'user' que devuelve tu provider 'authorize'
    id: string;
    email: string;
    name: string;
    role: string;
    image?: string | null;
    token?: string; // accessToken del backend
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    email: string;
    name: string;
    role: string;
    image?: string | null;
    accessToken?: string; // Token de acceso de tu backend
    backendTokenExpiresAt?: number; // Expiración del accessToken del backend en ms
    error?: "RefreshFailed" | "TokenExpired" | "SessionExpiredForceLogout"; // Para manejar errores de refresco
    // 'exp' es una propiedad estándar de JWT para la expiración del token de NextAuth (en segundos)
  }
}


Ruta: utils\date-format.ts
// utils/date-format.ts

/**
 * Formatea una fecha en un formato específico.
 *
 * @param date - La fecha a formatear
 * @param format - El formato de salida (por defecto: "dd/MM/yyyy")
 * @returns La fecha formateada como string
 *
 * Formatos disponibles:
 * - dd: día con ceros iniciales
 * - MM: mes con ceros iniciales
 * - MMM: nombre corto del mes
 * - MMMM: nombre completo del mes
 * - yyyy: año con 4 dígitos
 * - HH: hora formato 24h con ceros iniciales
 * - mm: minutos con ceros iniciales
 * - ss: segundos con ceros iniciales
 */
export function formatDate(
  date: Date | string | number,
  format: string = "dd/MM/yyyy"
): string {
  const d = new Date(date);

  if (isNaN(d.getTime())) {
    return "Fecha inválida";
  }

  const monthNames = [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre",
  ];

  const monthShortNames = [
    "ene",
    "feb",
    "mar",
    "abr",
    "may",
    "jun",
    "jul",
    "ago",
    "sep",
    "oct",
    "nov",
    "dic",
  ];

  const day = d.getDate().toString().padStart(2, "0");
  const month = (d.getMonth() + 1).toString().padStart(2, "0");
  const monthShort = monthShortNames[d.getMonth()];
  const monthFull = monthNames[d.getMonth()];
  const year = d.getFullYear();
  const hours = d.getHours().toString().padStart(2, "0");
  const minutes = d.getMinutes().toString().padStart(2, "0");
  const seconds = d.getSeconds().toString().padStart(2, "0");

  return format
    .replace("dd", day)
    .replace("MM", month)
    .replace("MMMM", monthFull)
    .replace("MMM", monthShort)
    .replace("yyyy", year.toString())
    .replace("HH", hours)
    .replace("mm", minutes)
    .replace("ss", seconds);
}

/**
 * Formatea una hora (horas y minutos) desde un objeto Date
 *
 * @param date - La fecha que contiene la hora
 * @returns String formateado como "HH:MM"
 */
export function formatTime(date: Date | string | number): string {
  const d = new Date(date);

  if (isNaN(d.getTime())) {
    return "Hora inválida";
  }

  return `${d.getHours().toString().padStart(2, "0")}:${d
    .getMinutes()
    .toString()
    .padStart(2, "0")}`;
}

/**
 * Devuelve el nombre del día de la semana
 *
 * @param date - La fecha
 * @param short - Si se debe devolver el nombre corto (por defecto: false)
 * @returns El nombre del día de la semana
 */
export function getWeekDayName(
  date: Date | string | number,
  short: boolean = false
): string {
  const d = new Date(date);

  if (isNaN(d.getTime())) {
    return "Día inválido";
  }

  const dayNames = [
    "Domingo",
    "Lunes",
    "Martes",
    "Miércoles",
    "Jueves",
    "Viernes",
    "Sábado",
  ];

  const dayShortNames = ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"];

  if (short) {
    return dayShortNames[d.getDay()];
  }

  return dayNames[d.getDay()];
}

/**
 * Añade días a una fecha
 *
 * @param date - La fecha inicial
 * @param days - El número de días a añadir (puede ser negativo)
 * @returns Una nueva fecha con los días añadidos
 */
export function addDays(date: Date | string | number, days: number): Date {
  const d = new Date(date);
  d.setDate(d.getDate() + days);
  return d;
}

/**
 * Añade meses a una fecha
 *
 * @param date - La fecha inicial
 * @param months - El número de meses a añadir (puede ser negativo)
 * @returns Una nueva fecha con los meses añadidos
 */
export function addMonths(date: Date | string | number, months: number): Date {
  const d = new Date(date);
  d.setMonth(d.getMonth() + months);
  return d;
}

/**
 * Compara dos fechas para saber si son el mismo día
 *
 * @param date1 - Primera fecha
 * @param date2 - Segunda fecha
 * @returns true si las fechas representan el mismo día, false en caso contrario
 */
export function isSameDay(
  date1: Date | string | number,
  date2: Date | string | number
): boolean {
  const d1 = new Date(date1);
  const d2 = new Date(date2);

  return (
    d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getDate() === d2.getDate()
  );
}

/**
 * Verifica si una fecha está en el futuro
 *
 * @param date - Fecha a comprobar
 * @returns true si la fecha es posterior a la fecha actual
 */
export function isFutureDate(date: Date | string | number): boolean {
  const d = new Date(date);
  const now = new Date();

  // Resetear horas para comparar solo las fechas
  d.setHours(0, 0, 0, 0);
  now.setHours(0, 0, 0, 0);

  return d > now;
}

/**
 * Verifica si una fecha está en el pasado
 *
 * @param date - Fecha a comprobar
 * @returns true si la fecha es anterior a la fecha actual
 */
export function isPastDate(date: Date | string | number): boolean {
  const d = new Date(date);
  const now = new Date();

  // Resetear horas para comparar solo las fechas
  d.setHours(0, 0, 0, 0);
  now.setHours(0, 0, 0, 0);

  return d < now;
}

/**
 * Calcula el número de días entre dos fechas
 *
 * @param startDate - Fecha de inicio
 * @param endDate - Fecha de fin
 * @returns Número de días entre las fechas (valor absoluto)
 */
export function daysBetween(
  startDate: Date | string | number,
  endDate: Date | string | number
): number {
  const start = new Date(startDate);
  const end = new Date(endDate);

  // Resetear horas para contar días completos
  start.setHours(0, 0, 0, 0);
  end.setHours(0, 0, 0, 0);

  // Convertir a milisegundos y calcular la diferencia
  const diffTime = Math.abs(end.getTime() - start.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return diffDays;
}

// ---- NUEVAS FUNCIONES PARA GESTIÓN DE ZONA HORARIA ----

/**
 * Obtiene la fecha actual en formato ISO (YYYY-MM-DD) ajustada a la zona horaria local
 * para evitar problemas con UTC
 *
 * @returns String con la fecha en formato ISO (YYYY-MM-DD)
 */
export function getTodayISOString(): string {
  const today = new Date();
  // Ajustar por zona horaria
  const todayAdjusted = new Date(
    today.getTime() - today.getTimezoneOffset() * 60000
  );
  return todayAdjusted.toISOString().split("T")[0];
}

/**
 * Convierte una cadena ISO (YYYY-MM-DD) a un objeto Date con la fecha correcta
 * independientemente de la zona horaria
 *
 * @param isoDateString - Fecha en formato ISO (YYYY-MM-DD)
 * @returns Objeto Date con la fecha correcta
 */
export function parseISOToDate(isoDateString: string): Date | null {
  if (!isoDateString) return null;

  // Convertir el string de fecha ISO a componentes numéricos
  const [year, month, day] = isoDateString.split("-").map(Number);

  // Si no hay componentes válidos, retornar null
  if (!year || !month || !day) return null;

  // Crear la fecha con año, mes (0-indexado) y día
  // Esto asegura que la fecha es correcta independientemente de la zona horaria
  return new Date(year, month - 1, day);
}

/**
 * Formatea una fecha ISO (YYYY-MM-DD) con el patrón especificado
 * preservando el día correcto independientemente de la zona horaria
 *
 * @param isoDateString - Fecha en formato ISO (YYYY-MM-DD)
 * @param format - Formato de salida (opcional)
 * @returns Fecha formateada según el patrón especificado
 */
export function formatISODate(
  isoDateString: string,
  format: string = "dd/MM/yyyy"
): string {
  if (!isoDateString) return "";

  const date = parseISOToDate(isoDateString);
  if (!date) return "Fecha inválida";

  return formatDate(date, format);
}

/**
 * Formatea una fecha obtenida de una base de datos o API para mostrarla correctamente
 * Es especialmente útil para evitar problemas de zona horaria entre el cliente y el servidor
 *
 * @param dateString - String de fecha que puede incluir información de tiempo (ISO o similar)
 * @param format - Formato de salida deseado
 * @returns Fecha formateada preservando el día correcto
 */
export function formatDateSafely(
  dateString: string | Date,
  format: string = "dd/MM/yyyy"
): string {
  if (!dateString) return "";

  let dateToFormat: Date;

  if (typeof dateString === "string") {
    // Para strings de fecha ISO, extraer solo la parte de la fecha
    const datePart = dateString.split("T")[0];
    const [year, month, day] = datePart.split("-").map(Number);

    // Crear fecha con los componentes específicos para evitar problemas de zona horaria
    dateToFormat = new Date(year, month - 1, day);
  } else {
    // Si ya es un objeto Date, usarlo directamente
    dateToFormat = dateString;
  }

  return formatDate(dateToFormat, format);
}


Ruta: utils\maintenance-utils.ts
// utils/maintenance-utils.ts

/**
 * Calcula la próxima fecha de mantenimiento basada en la fecha actual y la frecuencia
 *
 * @param currentDate - Fecha del último mantenimiento
 * @param frequency - Frecuencia de mantenimiento (MENSUAL, BIMESTRAL, TRIMESTRAL, SEMESTRAL, ANUAL)
 * @returns La fecha calculada para el próximo mantenimiento
 */
export function calculateNextMaintenanceDate(
  currentDate: Date,
  frequency: "MENSUAL" | "BIMESTRAL" | "TRIMESTRAL" | "SEMESTRAL" | "ANUAL"
): Date {
  const nextDate = new Date(currentDate);
  switch (frequency) {
    case "MENSUAL":
      nextDate.setMonth(nextDate.getMonth() + 1);
      break;
    case "BIMESTRAL":
      nextDate.setMonth(nextDate.getMonth() + 2);
      break;
    case "TRIMESTRAL":
      nextDate.setMonth(nextDate.getMonth() + 3);
      break;
    case "SEMESTRAL":
      nextDate.setMonth(nextDate.getMonth() + 6);
      break;
    case "ANUAL":
      nextDate.setFullYear(nextDate.getFullYear() + 1);
      break;
    default:
      // Por defecto, usar trimestral
      nextDate.setMonth(nextDate.getMonth() + 3);
  }

  return nextDate;
}

/**
 * Obtiene la etiqueta de estado de un mantenimiento según su fecha
 * @param {Date} nextDate - Fecha del próximo mantenimiento
 * @returns {string} - Estado: overdue, urgent, upcoming, scheduled
 */
export const getMaintenanceStatus = (nextDate) => {
  const now = new Date();
  const maintenanceDate = new Date(nextDate);
  const diffTime = maintenanceDate.getTime() - now.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return "overdue"; // Vencido
  if (diffDays <= 7) return "urgent"; // Urgente (próximos 7 días)
  if (diffDays <= 30) return "upcoming"; // Próximo (próximos 30 días)
  return "scheduled"; // Programado (más de 30 días)
};

/**
 * Verifica si un mantenimiento está vencido
 *
 * @param nextMaintenanceDate - Fecha del próximo mantenimiento
 * @returns true si el mantenimiento está vencido
 */
export function isMaintenanceOverdue(
  nextMaintenanceDate: Date | string
): boolean {
  return getMaintenanceStatus(nextMaintenanceDate) === "overdue";
}

/**
 * Verifica si un mantenimiento está urgente (dentro de los próximos 7 días)
 *
 * @param nextMaintenanceDate - Fecha del próximo mantenimiento
 * @returns true si el mantenimiento está en período urgente
 */
export function isMaintenanceUrgent(
  nextMaintenanceDate: Date | string
): boolean {
  return getMaintenanceStatus(nextMaintenanceDate) === "urgent";
}

/**
 * Verifica si un mantenimiento está próximo (dentro de los próximos 30 días)
 *
 * @param nextMaintenanceDate - Fecha del próximo mantenimiento
 * @returns true si el mantenimiento está próximo
 */
export function isMaintenanceUpcoming(
  nextMaintenanceDate: Date | string
): boolean {
  return getMaintenanceStatus(nextMaintenanceDate) === "upcoming";
}

/**
 * Obtiene descripción legible de la frecuencia de mantenimiento
 *
 * @param frequency - Valor de frecuencia (MENSUAL, BIMESTRAL, TRIMESTRAL, SEMESTRAL, ANUAL)
 * @returns Descripción en español de la frecuencia
 */
export function getFrequencyDescription(
  frequency: "MENSUAL" | "BIMESTRAL" | "TRIMESTRAL" | "SEMESTRAL" | "ANUAL"
): string {
  const frequencyMap: Record<string, string> = {
    MENSUAL: "Mensual",
    BIMESTRAL: "Bimestral (cada 2 meses)", // CORREGIDO: Texto descriptivo
    TRIMESTRAL: "Trimestral (cada 3 meses)",
    SEMESTRAL: "Semestral (cada 6 meses)",
    ANUAL: "Anual",
  };
  return frequencyMap[frequency] || frequency;
}

/**
 * Estima el número de mantenimientos en un año según la frecuencia
 *
 * @param frequency - Frecuencia de mantenimiento
 * @returns Número estimado de mantenimientos por año
 */
export function getYearlyMaintenanceCount(
  frequency: "MENSUAL" | "BIMESTRAL" | "TRIMESTRAL" | "SEMESTRAL" | "ANUAL"
): number {
  const countMap: Record<string, number> = {
    MENSUAL: 12,
    BIMESTRAL: 6,
    TRIMESTRAL: 4,
    SEMESTRAL: 2,
    ANUAL: 1,
  };
  return countMap[frequency] || 4; // Por defecto 4 (trimestral)
}


Ruta: utils\number-format.ts
/**
 * Formatea un número a moneda CLP (pesos chilenos)
 * - Redondea hacia arriba al entero más cercano
 * - Añade separador de miles con coma
 * - Agrega el símbolo $ al inicio
 *
 * @param value El valor a formatear
 * @returns Cadena formateada (ej: "$1,234,567")
 */
export function formatCurrency(value: number | string): string {
  // Convertir a número si es string
  const numValue = typeof value === "string" ? parseFloat(value) : value;

  // Si no es un número válido, devolver $0
  if (isNaN(numValue)) {
    return "$0";
  }

  // Redondear hacia arriba al entero más cercano
  const roundedValue = Math.ceil(numValue);

  // Formatear con separador de miles
  return "$" + roundedValue.toLocaleString("es-CL");
}

/**
 * Formatea un número con separador de miles
 * - Redondea hacia arriba al entero más cercano
 * - Añade separador de miles con coma
 *
 * @param value El valor a formatear
 * @returns Cadena formateada (ej: "1,234,567")
 */
export function formatNumber(value: number | string): string {
  // Convertir a número si es string
  const numValue = typeof value === "string" ? parseFloat(value) : value;

  // Si no es un número válido, devolver 0
  if (isNaN(numValue)) {
    return "0";
  }

  // Redondear hacia arriba al entero más cercano
  const roundedValue = Math.ceil(numValue);

  // Formatear con separador de miles
  return roundedValue.toLocaleString("es-CL");
}

/**
 * Redondea un número hacia arriba al entero más cercano
 *
 * @param value El valor a redondear
 * @returns Número redondeado hacia arriba
 */
export function roundUp(value: number | string): number {
  // Convertir a número si es string
  const numValue = typeof value === "string" ? parseFloat(value) : value;

  // Si no es un número válido, devolver 0
  if (isNaN(numValue)) {
    return 0;
  }

  // Redondear hacia arriba al entero más cercano
  return Math.ceil(numValue);
}

